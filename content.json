{"pages":[{"title":"About","text":"","link":"/about/index.html"},{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"Project","text":"","link":"/project/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Spring Boot教程汇总","text":"一.博客汇总:（全部看完） 唐亚峰 比较快餐化，带人上手的，但是没有讲很多原理层面的东西 bysocket泥瓦匠 有赞的大佬 附上 demo的地址 timebusker demo的链接 梁桂钊 阿里的大佬，还有个语雀，里面主要是一些答疑，可以作为技术提升参考着看； 还有微信公众号“服务端思维”，微信精选文章 就是这些关于数据库的文章让人醍醐灌顶，十分受启发 这有一个教程，github地址，里面有教程和demo didi翟永超的教程和demo汇总地址 很早就看过，简单的demo，但是却很经典，一看就懂 二.TODO(未待完续……)： 纯洁的微笑 公开课地址：《精通Spring Boot 42讲》 Spring Boot资料大全 小马哥的视频（暂时不看，在D:/Java学习）","link":"/2018/12/31/Spring-Boot教程汇总/"},{"title":"Spring Cloud教程汇总","text":"翟永超 ​ 教程 demo 方志朋 教程 文章汇总 demo源码 Spring Cloud资源大全 最齐全！！！","link":"/2019/01/01/Spring-Cloud教程汇总/"},{"title":"MyBatis学习指南","text":"MyBatis的学习指导方针： 通过看书籍和官方文档的方式进行入门； 然后再多编码实践，偏实战的方式进行巩固； 进阶通过学习源码的方式 由此指导方针制定的学习指南如下所示： 学习《MyBatis从入门到精通》 ​ 这本书比较容易懂，跟着书本理解并写完整本书的代码后，会对MyBatis有一个基本的了解，并且看完基本的xml映射文件都会写了，属于入门和偏实战的书籍。一定要好好看完，跟着写代码和理解。 学习MyBatis官方文档 ​ 从来没见过如此好懂的官方文档，之前小马哥说官方文档是学习过程中的一个重要来源，但是Spring Cloud的官方文档，貌似看了，还是对Spring Cloud的理解没有太大提升，可能是自己的功底还是不够吧。 学习官方文档，可以巩固之前《MyBatis从入门到精通》中所学的知识 一定要找例子多练习，只有练习与尝试，才能更好地掌握MyBatis的实战内容 学习《MyBatis技术内幕》 ​ 这本书偏源码，属于进阶的学习，当然学习源码还可以参考别人的博客。 目前，就是把第一章的简介看完再说。","link":"/2019/02/04/MyBatis学习指南/"},{"title":"Spring MVC源码初探（二） DispatcherServlet","text":"1.概述​ 依照目前的情况，只能对Spring MVC的源码做初步探索，所以说不要强求每一个地方都理解，这是不现实的。我们至少要做到对核心代码以及核心代码所蕴含的逻辑过程清楚，这样本系列的学习就达到目的了。 ​ 接下来会从doService方法，doPatch方法和processDispatchResult方法这三个方面接触下DispatcherServlet的核心代码逻辑，加深对Spring MVC基本原理的理解。 2.doService FlashMapper等具体后面学习到组件的时候再展开 doDispatch(request,response)会在下一小节展开 其他部分，按照代码注释理解应该没问题 3.doDispatch（真正处理请求的方法） doDispatch中首先检查是不是上传请求，如果是上传请求，则将request转换为Multi-partHttpServletRequest，并将multipartRequestParsed标志设置为true。其中使用到了Multipart-Resolver。 然后通过getHandler方法获取Handler处理器链，其中使用到了HandlerMapping，返回值为HandlerExecutionChain类型，其中包含着与当前request相匹配的Interceptor和Handler 。 根据Handler找到相应的HandlerAdapter。 接下来是处理GET、HEAD请求的Last-Modified。 接下来依次调用相应Interceptor的preHandle。 HandlerAdapter使用Handler处理请求。（具体怎么处理，以后的博客会展开描述） Handler处理完请求后，如果需要异步处理，则直接返回；如果不需要异步处理，当view为空时（如Handler返回值为void），设置默认view， 然后执行相应Interceptor的postHandle。设置默认view的过程中使用到了ViewNameTranslator。 调用processDispatchResult方法处理上面处理之后的结果（包含找到View并渲染输出给用户）。 PS: 异常处理结构 : doDispatch有两层异常捕获，内层是捕获在对请求进行处理的过程中抛出的异常，外层主要是在处理渲染页面时抛出的。内层的异常，也就是执行请求处理时的异常会设置到dispatchException变量，然后在processDispatchResult方法中进行处理，外层则是处理processDispatchResult方法抛出的异常。 还要补充的是：在最后的finally中判断是否请求启动了异步处理，如果启动了则调用相应异步处理的拦截器，否则如果是上传请求则删除上传请求过程中产生的临时资源。 4.processDispatchResult 4.1 异常处理processDispatchResult处理异常的方式其实就是将相应的错误页面设置到View，在其中的processHandlerException方法中用到了HandlerExceptionResolver。 processHandlerException方法代码如下： 这一部分未做深入分析，以后可以拿出来研究下 我们接着往下看 4.2 render render中首先对response设置了Local，过程中使用到了LocaleResolver， 然后判断View如果是String类型则调用resolveViewName方法使用ViewResolver得到实际的View， 最后调用View的render方法对页面进行具体渲染，渲染的过程中使用到了ThemeResolver。(ThemeResolver在后面的组件学习中会具体学习到) 最后通过mappedHandler的triggerAfterCompletion方法触发Interceptor的afterCompletion方法，这里的Interceptor也是按反方向执行的。 到这里processDispatchResult方法就执行完了。 具体代码就先不分析了 5. 总结5.1 doDispatch的流程图 5.2 形象理解Handler：也就是处理器，它直接对应着MVC中的C也就是Controller层 HandlerMapping：是用来查找Handler的，在Spring MVC中会处理很多请求，每个请求都需要一个Handler来处理，具体接收到一个请求后使用哪个Handler来处理呢？这就是HandlerMapping要做的事情。 HandlerAdapter ：使用Handler处理请求 通俗点的解释就是Handler是用来干活的工具，HandlerMapping用于根据需要干的活找到相应的工具，HandlerAdapter是使用工具干活的人。 View是用来展示数据的，而ViewResolver用来查找View 使用HandlerMapping找到干活的Handler，找到使用Handler的HandlerAdapter，让HandlerAdapter使用Handler干活，干完活后将结果写个报告交上去（通过View展示给用户）。 HandlerExecutionChain：处理请求的处理器链（包含处理器和对应的Interceptor） ModelAndView ：封装Model和View的容器，此变量在整个Spring MVC处理的过程中承担着非常重要角色","link":"/2019/01/03/Spring-MVC 源码初探（二）-DispatcherServlet/"},{"title":"Spring学习资料汇总","text":"1.书籍 《Spring揭秘》 王福强 《Spring实战》(第四版) 最经典的 《Spring源码深度解析》 学习源码的时候必看 2.系列教程张开涛的《跟我学Spring 3》 教程截图奉上： 后续有更好的教程，再补充 3.官方文档 Spring 4 官方文档 Spring Data JPA官方文档 Spring Security 参考手册","link":"/2019/01/01/Spring学习资料汇总/"},{"title":"Spring MVC基本原理","text":"一.核心架构图 二.核心架构的处理流程 首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制； DispatcherServlet——&gt;HandlerMapping， HandlerMapping 将会把请求映射为 HandlerExecutionChain 对象（包含一个 Handler 处理器（页面控制器）对象、多个 HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略； DispatcherServlet——&gt;HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器； HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个 ModelAndView 对象（包含模型数据、逻辑视图名）； ModelAndView 的逻辑视图名——&gt; ViewResolver， ViewResolver 将把逻辑视图名解析为具体的 View，通过这种策略模式，很容易更换其他视图技术； View——&gt;渲染，View 会根据传进来的 Model 模型数据进行渲染，此处的 Model 实际是一个 Map 数据结构，因此很容易支持其他视图技术； 返回控制权给 DispatcherServlet，由 DispatcherServlet 返回响应给用户","link":"/2018/12/29/Spring-MVC基本原理/"},{"title":"Spring MVC源码初探（一） FrameworkServlet","text":"1.概述​ Spring MVC有三个重要的Servlet，分别是HttpServletBean 、FrameworkServlet 和DispatcherServlet。 ​ 其中HttpServletBean没有涉及请求处理的流程，所以我们学习的时候，主要看FrameworkServlet和DispatcherServlet。 FrameworkServlet： 将不同类型的请求合并到了processRequest方法统一处理，processRequest方法中做了三件事： 调用了doService模板方法具体处理请求。 将当前请求的LocaleContext和ServletRequestAttributes在处理请求前设置到了LocaleContextHolder和 RequestContextHolder，并在请求处理完成后恢复， 请求处理完后发布了ServletRequestHandledEvent消息。 DispatcherServlet: doService方法给request设置了一些属性并将请求交给doDispatch方法具体处理。所以说核心代码都在doDispatch方法，我们分析DispatcherServlet的时候，应当重点研究doService方法中调用的doDispatch方法。 DispatcherServlet中的doDispatch方法完成Spring MVC中请求处理过程的顶层设计，它使用DispatcherServlet中的九大组件完成了具体的请求处理。 这些具体细节，等下一篇写到DispatcherServlet的时候会详述。 2.走进FrameworkServlet的世界1public abstract class FrameworkServlet extends HttpServletBean implements ApplicationContextAware ​ 我们可以看到FrameworkServlet继承了HttpServletBean,实现了ApplicationContextAware接口。其中实现ApplicationContextAware接口是为了获取ApplicationContext对象，如下是ApplicationContextAware接口的源码： 12345public interface ApplicationContextAware extends Aware { void setApplicationContext(ApplicationContext applicationContext) throws BeansException;} 2.1 service方法在FrameworkServlet中重写了service、doGet、doPost、doPut、doDelete、doOptions、doTrace方法 ,如下： 在这里，我们回顾下Servlet的处理过程，是在service方法中根据不同类型的请求路由到doGet、doPost、doPut、doDelete、doOptions、doTrace方法。我们看下HttpServlet中的service方法,如图： 此处我豁然开朗，我们之前写一个Servlet类的时候，就是继承HttpServlet，但是不用重写service方法，只需要写doGet和doPost方法，因为service方法，直接就会根据我们请求的方式，直接路由到doGet或者doPost方法。也就是说我们写的Servlet类，其实继承了父类HttpServlet中的service方法，所以就会帮助我们路由到具体的doXXX()方法。 而Spring MVC中，FrameworkServlet的service方法却是把PATCH请求和空请求单独拿出来，调用processRequest方法处理；而对于其他请求，就直接交给父类来处理（其实是给HttpServlet中的service方法处理）。但是doGet、doPost、doPut、doDelete都是自己处理请求，不用父类来处理。 总结一下，就是所有需要自己处理请求的，不依靠父类帮助处理的，都调用了processRequest()方法 2.1.1 processRequest方法processRequest方法是FrameworkServlet类在处理请求中最核心的方法。 首先我们来走一下processRequest方法的主要流程(上图的TODO：异步请求，暂时不考虑)，之后再分析下里面各个更小的细节 获取LocaleContextLoader中原先保存的LocalContext和当前请求的LocaleContext（详见2.1.2） 获取RequestContextHolder原先保存的RequstAttributes和当前请求的ServletRequestAttributes（详见2.1.3) 将当前请求的LocaleContext和ServletRequestAttributes设置到LocaleContextHolder和RequestContextHolder（详见2.1.4） 调用doService实际处理请求 恢复原来的LocaleContext和ServletRequestAttributes到LocaleContextLoader 发布ServletRequestHandledEvent消息(详见2.1.5) 2.1.2 LocalContext123456//保存Locale对象信息(本地化信息，如zh-cn)public interface LocaleContext { @Nullable Locale getLocale();} LocaleContext里面存放着Locale（也就是本地化信息，如zh-cn等） 2.1.3 RequestAttributesRequestAttributes是spring的一个接口，通过它可以get/set/removeAttribute。根据scope参数判断操作request还是session。这里具体使用的是ServletRequestAttributes类，在ServletRequestAttributes里面还封装了request、response和session，而且都提供了get方法，可以直接获取。 先看一下RequestAttributes接口中的方法 接着看一下ServletRequestAttributes： 封装了request、response和session，而且都提供了get方法，可以直接获取 提供了getAttribute、setAttribute和removeAttribute方法 重点看一下setAttribute方法，其他的两个方法应该都差不多 简单分析一下，就是根据scope属性去判断是对request还是session进行设置 2.1.4 LocaleContextHolder和RequestContextHolder LocaleContextHolder 详细的暂时不理解，留着以后TODO RequestContextHolder 2.1.5 publishRequestHandledEvent publishEvents可以在web.xml文件中配置Spring MVC的Servlet时配置，默认为true。 2.2 总结首先是在service方法里添加了对PATCH的处理，并将所有需要自己处理的请求都集中到了processRequest方法进行统一处理，这和HttpServlet里面根据request的类型将请求分配到各个不同的方法进行处理的过程正好相反。 然后就是processRequest方法，在processRequest里面主要的处理逻辑交给了doService，这是一个模板方法，在子类具体实现，另外就是对使用当前request获取到的LocaleContext和RequestAttributes进行了保存，以及处理完之后的恢复，在最后发布了ServletRequest-HandledEvent事件。 3.关于此部分业务容器的介绍，会在以后学习的过程中补充到这里TODO:","link":"/2018/12/31/Spring-MVC 源码初探（一）-FrameworkServlet/"},{"title":"Spring MVC源码初探（四）   HandlerMapping之  AbstractHandlerMapping","text":"一. HandlerMapping以及继承体系123456public inteface HandlerMapping{ //省略一些变量 @Nullable HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception; } ​ 由上述代码可知,HandlerMapping是一个接口，其核心方法是getHandler方法，该方法会返回一个HandlerExecutionChain对象，该对象中包含一个处理器和一系列的拦截器。getHandler方法由实现它的子类具体完成。 ​ 我们通过一张图看一下HandlerMapping的继承体系 ​ ​ 由上图我们可以看到，HandlerMapping是一个接口，AbstractHandlerMapping是实现它的抽象类，而顺着AbstractHandlerMapping可以看到两个分支，分别是AbstractUrlHandlerMapping和AbstractHandlerMethodMapping。 ​ 由此我们可以找到一个规律 ​ 先设计一个接口，然后再设计一个抽象类去实现这个接口，实现一些方法，再由这个抽象类的子类去实现更多的方法和功能。接口是最大的父亲，而抽象类像一个“中间产物”，后续继承抽象类的子类去做真正的事情，参与框架中的操作。由接口（起点）&gt;抽象类（中间）&gt;… （成品），这样的设计方法，似乎是可以通用的。 ​ 再想到Servlet也是一个接口，GenericServlet是实现它的抽象类，而HttpServlet这个抽象类继续继承GenericServlet；而我们新建一个Servlet是继承HttpServlet的产物，这个才是我们需要的，或者说，才是我们真正可以使用的Servlet。 ​ 我们可以由此看到AbstractHandlerMapping这个抽象类的重要性，那么就来看一下它的核心方法吧 二. AbstractHandlerMapping核心方法 initApplicationContext 这个方法在初始化的时候调用，其实它主要是初始化三个拦截器。 我们主要看一下其中的initInterceptors（）方法： initInterceptors()方法就是把这个类中的定义的拦截器集合（interceptors)一个个取出来 再调用adaptInterceptor(interceptor)，根据拦截器的类型，给其转换成一定类型的拦截器 再将转换类型后的拦截器添加到另一个集合adaptedInterceptors中 看一下这两个拦截器集合在AbstarctHandlerMapping中的定义 123private final List&lt;Object&gt; interceptors = new ArrayList&lt;&gt;();private final List&lt;HandlerInterceptor&gt; adaptedInterceptors = new ArrayList&lt;&gt;(); getHandler AbstractHandlerMapping重写了getHandler方法: 概述一下，getHandler方法就是根据请求获取处理器，如果处理器是String类型，就特殊处理一下；然后拿到处理器后，去调用getHandlerExecutionChain对象，返回HandlerExecutionChain对象（包含处理器和拦截器）。现在回想一下，initApplicationContext中初始化拦截器，是不是就很有用了。 getDefaultHandler 获取默认的处理器 obtainApplicationContext 获取ApplicationContext对象 getHandlerExecutionChain 判断处理器是否是HandlerExecutionChain类型，是的话，就将处理器转换成HandlerExecutionChain类型，如果不是，则新建一个HandlerExecutionChain对象 我的理解是：处理器是HandlerExecutionChain类型，是因为根本没有设置拦截器，就是最简单的demo那种 然后调用UrlPathHelper类的getLookupPathForRequest方法获取lookupPath(给定请求的映射查找路径) private UrlPathHelper urlPathHelper = new UrlPathHelper(); 然后遍历拦截器，符合条件，就将拦截器添加给HandlerExecutionChain对象 这个过程，就是根据请求，去找拦截器，因为此时处理器已经得到了。 三. 总结​ 我们很容易知道AbstractHandlerMapping在HandlerMapping体系中是一个很重要的抽象类,而这个抽象类做了两件事: 1. 初始化一系列的拦截器 2. 根据请求找到处理器 3. 将处理器和拦截器添加给HandlerExecutionChain对象 这个时候是不是很期待AbstractUrlHandlerMapping（子体系）和AbstractHandlerMethodMapping（子体系）在AbstractHandlerMapping的基础上又做了哪些工作呢？留坑，以后的文章会陆续揭秘。 在文章的最后，特别感谢艿艿大神提供的类图，自己在IDEA开发工具中找不到完整的类图，谢了！","link":"/2019/01/19/Spring-MVC源码初探（四）-  HandlerMapping之-AbstractHandlerMapping/"},{"title":"Spring MVC源码初探（六）HandlerMapping之AbstractHandlerMethodMapping","text":"1.​概述​ 我们今天来看AbstractHandlerMethodMapping体系，这是AbstractHandlerMapping的第二个体系，又是用的最多的一个体系。该体系包括：AbstractHandlerMethodMapping、RequestMap pingInfoHandlerMapping和RequestMappingHandlerMapping。 ​ 虽然该体系结构简单，一目了然，但是丝毫没有简单的感觉，这个体系理解下来还是比较吃力的。本系列目前遇到的最难啃的，就是这个体系。但是最难啃，不代表就回避这一体系的源码，这个体系啃下来就代表我们的HandlerMapping大的体系就完整地啃下来了。看完这一部分，就要开始进军HandlerAdapter了。 ​ AbstractHandlerMethodMapping 系列是将Method作为Handler来使用的，这其实是我们最熟悉的关于Spring MVC的内容，例如@RequestMapping所注释的方法就是这种Handler，它专门有一个类型HandlerMethod，也就是Method类型的Handler 。 1234@RequestMapping(\"/phones\")public void test(){ } 如图，这是AbstractHandlerMethodMapping体系的类图： 2. AbstractHandlerMethodMapping​ 鉴于这个体系实在是有难度，当时看了一天，现在写也比较吃力，所以就会有所省略，也算是能力所限吧。 2.1 getHandlerInternal​ 我们先从getHandlerInternal方法来开始看，前面AbstractHandlerMapping 中的getHandlerInternal方法是一个模板方法，交给两个子类分支实现，AbstractUrlHandlerMapping体系中实现了该方法，那么我们现在看一下AbstractHandlerMethodMapping体系中的getHandlerInternal方法。 ​ ​ 2.1.1 lookupHandlerMethod​ 我们再看一下第三步的lookupHandlerMethod的详细代码。 看一下addMatchingMappings方法。 3. 总结​ 这篇实在写不下去了，就一个AbstractHandlerMethodMapping类中的各种内部类和Map已经很复杂了，留着坑，目前先凑一篇吧，或者有可能以后再补充吧。","link":"/2019/02/09/Spring-MVC源码初探（六）HandlerMapping之AbstractHandlerMethodMapping/"},{"title":"Spring MVC源码初探（五）HandlerMapping之AbstractUrlHandlerMapping","text":"1. ​简介​ 今天这篇博客，我们来看一下AbstractHandlerMapping的一个分支：AbstarctUrlHandlerMapping。我们发现其实HandlerMapping的接口，就是定义了一个获取HandlerExecutionChain对象的方法，该对象可以获取Handler处理器和一系列的拦截器Inteceptors。而这个方法就是交给抽象类AbstractHandlerMapping来具体实现的，但是该方中使用的getHandlerInternal方法是交给子类去实现的。 ​ 如图是AbstractHandlerMapping的getHandlerInternal方法，是留给子类实现的。 ​ AbstractUrlHandlerMapping有两个子类：SimpleUrlHandlerMapping、AbstractDetectingUrlHandlerMapping；AbstractDetectingUrlHandlerMapping有一个子类：BeanNameUrlHandlerMapping。 ​ 接下来，我们先看一下AbstractUrlHandlerMapping本身，再去看几个子类。 2. AbstractUrlHandlerMapping2.1 getHandlerInternal​ ​ 该方法是对AbstractUrlHandlerMapping的重写，是通过request请求获取Handler对象。 首先从Map中查找Handler 如果Map中没有Handler，说明Map中没存Handler，则分为如下三种情况去获取Handler 如果lookupPath为/，就去获取原始的处理器 123if (\"/\".equals(lookupPath)) { rawHandler = getRootHandler();} 1234@Nullablepublic Object getRootHandler() { return this.rootHandler;} 123//处理\"/\"请求的处理器 @Nullable private Object rootHandler; 这样就很清楚了 ​ 2. 如果不是第1种情况，就去获得默认的处理器 ​ rawHandler = getDefaultHandler(); ​ ​ 1234@Nullablepublic Object getDefaultHandler() { return this.defaultHandler;} ​ 下面的defalutHandler是在父类AbstractHandlerMapping中定义的 12@Nullableprivate Object defaultHandler; 经过上面的步骤，应该获取到处理器Handler了，如果处理器是String类型，就根据字符串获取真正的处理器 接着就是校验请求和处理器是否匹配，这里调用了一个模板方法来完成校验，但是这个模板方法子类也没有给它实现，所以这是个空操作 然后就是给rawHandler注册两个拦截器，返回一个HandlerExecution对象 123//给查询到Handler注册两个拦截器(TODO:拦截器的作用暂时不明白）handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, null); ​ 详细看一下buildPathExposingHandler方法： ​ ​ 这是添加两个内部拦截器的具体过程： ​ 这俩内部拦截器的主要作用是将与当前url实际匹配的Pattern、匹配条件（后面介绍）和url模板参数等设置到request的属性里，这样在后面的处理过程中就可以直接从request属性中获取，而不需要再重新查找一遍了 2.1.1 lookupHandler​ 我们重点看下getHandlerInternal方法中的lookupHandler方法，该方法是从map中获取处理器的过程 ​ 首先map的定义如下： ​ 12//保存url与handlerprivate final Map&lt;String, Object&gt; handlerMap = new LinkedHashMap&lt;&gt;(); ​ lookupHandler： 如果是精确的url，就直接从map中获取处理器，并且给其添加拦截器； 如果是book/*/u这类url，比较模糊的，也要进行处理 2.2 registerHandler 1 2.3 registerHandler 2 注册处理器的目的，就是将urlPath交给处理器处理，一个url交给一个处理器去处理，就是这么一个过程。 先获取处理器 判断处理器是否为空 处理器不为空的时候： ​ 如果处理器和根据url查找到的处理器不一致，说明异常，因为一个url只能给一个处理器处理，出现多个就是不正常，出异常了 处理为空，需要分情况处理，看else部分的代码就理解了 3. SimpleUrlHandlerMapping接着我们来看下AbstractUrlHandlerMapping的子类SimpleUrlHandlerMapping 3.1 initApplicationContext​ SimpleUrlHandlerMapping 在AbstractHandlerMapping的基础上进行了重写，原有方法只是初始化了一些拦截器，但是没有初始化处理器，重写后的initApplicationContext开始注册了一系列的处理器。 ​ ​ 注册多个Hanlder方法我们在3.2看下 3.2 registerHandlers 注册Handler方法，核心是调用的AbstractUrlHandlerMapping的registerHandler2方法。 4. AbstractDetectingUrlHandlerMapping​ 该类也是AbstractUrlHandlerMapping的子类，我们主要看一下它的detectHandlers方法 ​ ​ 其中的2.3步，是调用的父类AbstractUrlHandlerMapping的registerHandler方法来注册处理器， ​ 我认为，注册处理器就是让一个处理器处理一个url 获取整个容器中所有的beanName 遍历beanName，对每个beanName，解析出它的url，将url和beanName进行处理器的注册 ​ 其中determineUrlsForHandler方法，是模板方法，交给子类去操作的。 4.1 BeanNameUrlHandlerMapping​ BeanNameUrlHandlerMapping重写了determineUrlsForHandler方法，我们来看一下代码： 这边我不太明白，beanName为什么会以”/“开头，先留个疑问吧。 5. 总结 类图一看，宏观体系一目了然，下一篇我们接着看AbstractHandlerMapping的第二个体系：AbstractHandlerMethodMapping","link":"/2019/02/09/Spring-MVC源码初探（五）HandlerMapping之AbstractUrlHandlerMapping/"},{"title":"《SQL必知必会》笔记","text":"主键： 主键不能为空 任意两行都不具有相同的主键值 主键列中的值不允许修改或更新 主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行） 数据库是一个物理存储的概念，保存有组织的数据的容器（通常是一个文件或一组文件）； 而MySQL，Oracle等数据库软件是数据库管理系统DBMS； 数据库是通过DBMS创建和操纵的容器，而具体它究竟是什么，形式如何，各种数据库都不一样。 1select DISTINCT id from table1 只会返回不同的id字段 不能部分使用DISTINCT： DISTINCT关键字作用于所有的列，不仅仅是跟在其后的那一列。例如，你指定SELECT DISTINCT vend_id, prod_price，除非指定的两列完全相同，否则所有的行都会被检索出来。 123SELECT prod_name FROM ProductsLIMIT 5; 只返回符合条件的前5条记录 123SELECT prod_nameFROM Products LIMIT 5 OFFSET 5; LIMIT 5 OFFSET 5指示MySQL等DBMS返回从第5行起的5行数据。第一个数字是指从哪儿开始，第二个数字是检索的行数。 SQL中order by排序默认是升序的，如果要使用降序，要配合DESC关键字 123SELECT prod_id, prod_price, prod_nameFROM ProductsORDER BY prod_price DESC; 结果： 1234567891011prod_id prod_price prod_name------- ---------- --------------------BR03 11.9900 18 inch teddy bearRYL01 9.4900 King dollRYL02 9.4900 Queen dollBR02 8.9900 12 inch teddy bearBR01 5.9900 8 inch teddy bearRGAN01 4.9900 Raggedy AnnBNBG01 3.4900 Fish bean bag toyBNBG02 3.4900 Bird bean bag toyBNBG03 3.4900 Rabbit bean bag toy 123SELECT prod_id, prod_price, prod_nameFROM ProductsORDER BY prod_price DESC, prod_name; 这里，先按照prod_price降序排，再按照prod_name升序排 DESC关键字只应用到直接位于其前面的列名 在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后 范围查询 123SELECT prod_name, prod_priceFROM ProductsWHERE prod_price BETWEEN 5 AND 10; 空值查询 123SELECT prod_nameFROM ProductsWHERE prod_price IS NULL; 在AND与OR同时存在的SQL语句中，要合适地添加括号()，使得SQL语句按照我们的预想去执行。 1234SELECT prod_name, prod_priceFROM ProductsWHERE (vend_id = 'DLL01' OR vend_id = ‘BRS01’)AND prod_price &gt;= 10; SQL语句使用通配符进行过滤 LIKE操作符 123SELECT prod_id, prod_name FROM Products WHERE prod_name LIKE 'Fish%'; 在执行这条子句时，将检索任意以Fish起头的词。%告诉DBMS接受Fish之后的任意字符，不管它有多少字符。 ​ 123SELECT prod_id, prod_name FROM Products WHERE prod_name LIKE '%bean bag%'; 搜索模式`&apos;%bean bag%&apos;`表示匹配任何位置上包含文本`bean bag`的值，不论它之前或之后出现什么字 符。 ​ ​ 123SELECT prod_nameFROM ProductsWHERE prod_name LIKE 'F%y'; ​ 找出以F起头、以y结尾的所有产品 ​ 注意：通配符%看起来像是可以匹配任何东西，但有个例外，这就是NULL。子句WHERE prod_name LIKE ‘%’不会匹配产品名称为NULL的行。 使用通配符的技巧： 在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。 函数 使用函数的时候，用不了索引 聚合函数 | SQL聚集函数 | || :————– | —————- || 函 数 | 说 明 || AVG() | 返回某列的平均值 || COUNT() | 返回某列的行数 || MAX() | 返回某列的最大值 || MIN() | 返回某列的最小值 || SUM() | 返回某列值之和 | 分组数据 group by 123SELECT vend_id, COUNT(*) AS num_prodsFROM ProductsGROUP BY vend_id; GROUP BY子句指示DBMS按vend_id排序并分组数据。这就会对每个vend_id而不是整个表计算num_prods一次。从输出中可以看到，供应商BRS01有3个产品，供应商DLL01有4个产品，而供应商FNG01有2个产品。 子查询 select … from t where id=(select…..)","link":"/2019/02/01/《SQL必知必会》/"},{"title":"官方文档记录","text":"一. Spring Spring Framework 4.x.x Spring Security 参考手册 4.0.2 英文原版官方文档 二. Spring Cloud 三. MyBatis","link":"/2019/02/05/官方文档记录/"},{"title":"芋道源码面试题","text":"Spring面试题 http://svip.iocoder.cn/Spring/Interview/ Spring MVC面试题 http://svip.iocoder.cn/Spring-MVC/Interview/ Spring Boot面试题 http://svip.iocoder.cn/Spring-Boot/Interview/ Mybatis面试题 http://svip.iocoder.cn/MyBatis/Interview/ PS:其他面试题聚集在： http://svip.iocoder.cn/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/ 另外：面试题汇总在面试简历收藏夹","link":"/2019/01/01/面试题/"},{"title":"ArrayList分析","text":"本文章基于JDK8ArrayList简介ArrayList是一个动态数组，也是我们最常用的集合。 ​ 它允许任何符合规则的元素插入甚至包括null。 ​ 每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。 ​ 随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。 所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。 注意 ：ArrayList的subList结果，不能强转为ArrayList，否则会抛出ClassCastException异常。 ArrayList的底层是数组，所以ArrayList的操作，其实就是基于对数组的操作 结构 ArrayList定义了一个初始化容量10，如果我们不自定义初始化容量的话，那么它的默认容量就是10 1234/** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; Object[] elementData就是ArrayList容器，其中装着ArrayList元素， 我们研究ArrayList的操作，就是对该容器进行各种操作 size表示的是当前elementData数组中的元素有多少，也就是ArrayList的元素有多少 123456789101112131415161718192021222324252627/** * Shared empty array instance used for empty instances. */private static final Object[] EMPTY_ELEMENTDATA = {};/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};/**装ArrayList元素的数组 * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */transient Object[] elementData; // non-private to simplify nested class access/** * The size of the ArrayList (the number of elements it contains). * ArrayList元素的个数 * @serial */private int size; 三个构造方法 1234567891011121314151617181920212223242526272829//构造具有自定义的初始容量的空List public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } }//构造一个初始容量为10的空Listpublic ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; }//构造一个包含制定集合元素的List public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; } } 基本用法 简单实例： 123456List&lt;String&gt; stringList=new ArrayList&lt;String&gt;(30); stringList.add(\"老马\"); stringList.add(\"老弟\"); for(String string:stringList){ System.out.println(string); } 结果： 12老马老弟 基本原理123transient Object[] elementData;private int size; 首先elementData就是ArrayList的容器，然后size就是元素的个数，一系列的操作就是围绕着两个变量进行的。 add该方法是将元素添加到ArrayList的末尾 12345public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;} add方法会首先调用 ensureCapacityInternal(size + 1); 该方法确保数组容量是足够的 123private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } calculateCapacity(elementData, minCapacity)： 该方法判断数组是否是空的，如果是空的，则返回默认的容量10，否则返回新增元素后元素的个数 123456private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } 该方法是调用ensureExplicitCapacity完成的： 1234567private void ensureExplicitCapacity(int minCapacity) { modCount++;//记录修改次数 // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);//扩容操作 } 1234567891011private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } 计算机编程的一个思想：封装复杂操作，提供简化接口 迭代123for(String string:stringList){ System.out.println(string); } 对于我们上述的foreach语句，会被编译器转化为： 1234Iterator&lt;String&gt; iterator =stringList.iterator(); while (iterator.hasNext()){//判断是否有元素没有访问 System.out.println(iterator.next());//输出下一个元素 } ArrayList实现了List接口，List接口实现了Collection接口，而Collection接口实现了Iterable接口。 看一下Iterable接口的代码： 123456public interface Iterable&lt;T&gt; { Iterator&lt;T&gt; iterator(); ...... } 12345678910111213public interface Iterator&lt;E&gt; { E next(); default void remove() { throw new UnsupportedOperationException(\"remove\"); } default void forEachRemaining(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); while (hasNext()) action.accept(next()); } Iterable表示对象可以被迭代，iterator()获取迭代器，利用迭代器来完成迭代工作 那么我们的ArrayList实现了Iterable接口，就要实现 Iterator&lt;T&gt; iterator();方法，具体实现是通过内部类private class Itr来实现的。看源码一看就知道。 123public Iterator&lt;E&gt; iterator() { return new Itr(); } 只要对象实现了Iterable接口，就可以使用for-each，编译器会自动将for-each转化为Iterable的方式 listIterator123456789public ListIterator&lt;E&gt; listIterator(int index) { if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(\"Index: \"+index); return new ListItr(index); }public ListIterator&lt;E&gt; listIterator() { return new ListItr(0); ArrayList还提供了两个返回Iterable接口的方法 看下ListIterator接口的方法 12345678910111213141516171819public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; { boolean hasNext(); E next(); boolean hasPrevious(); E previous(); int nextIndex(); int previousIndex(); void remove(); void set(E e); void add(E e); 其他方法 ArrayList可以将集合元素转化成数组返回： 1234567891011121314//返回Object数组public Object[] toArray() { return Arrays.copyOf(elementData, size); }//返回具体类型的数组 public &lt;T&gt; T[] toArray(T[] a) { if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; } ​ 12345List&lt;String&gt; list=new List&lt;String&gt;();list.add(\"1\");...String[] array=new String[3];list.toArray(array); 总结ArrayList不是线程安全的，并且它插入，删除的效率比较低。","link":"/2019/02/11/ArrayList分析/"},{"title":"《MyBatis从入门到精通》笔记","text":"入门 导入相应的依赖包 123456789101112131415161718192021222324252627282930313233343536&lt;!--Junit单元测试--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--MySQL驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt;&lt;/dependency&gt;&lt;!--MyBatis依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--Slf4j日志门面--&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt;&lt;!--Log4j日志--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 创建数据库表以及对应的实体类 不要求表的字段名称与实体类的属性名一模一样 配置log4j.properties 12345678910#全局配置log4j.rootLogger=ERROR,stdout#MyBatis日志配置(为了看SQL语句）log4j.logger.tk.mybatis.simple.mapper=TRACE#控制台输出配置log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 配置Mybatis 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org// DTD Config 3 . 0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--指定使用LOG4J输出日志--&gt; &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt; &lt;/settings&gt; &lt;!--实体类的位置--&gt; &lt;typeAliases&gt; &lt;package name=\"tk.mybatis.simple.model\"/&gt; &lt;/typeAliases&gt; &lt;!--配置数据库连接--&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt; &lt;property name=\"\" value=\"\"/&gt; &lt;/transactionManager&gt; &lt;dataSource type=\"UNPOOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"1027\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--mapper文件--&gt; &lt;mappers&gt; &lt;mapper resource=\"tk/mybatis/simple/mapper/CountryMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 配置mapper文件 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"tk.mybatis.simple.mapper.CountryMapper\"&gt; &lt;resultMap id=\"AllCountries\" type=\"tk.mybatis.simple.model.Country\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"country_name\" property=\"countryname\"/&gt; &lt;result column=\"country_code\" property=\"countrycode\"/&gt; &lt;/resultMap&gt; &lt;!--暂时没有写mapper接口--&gt; &lt;select id=\"selectAll\" resultMap=\"AllCountries\"&gt; select id,country_name,country_code from country &lt;/select&gt;&lt;/mapper&gt; 注意此处我们可以不写mapper接口，因为我们现在只是做单元测试，没有service层调用mapper接口的对应方法，所以mapper接口可以不存在 另外，resultType获取到的结果为null，改用resultMap就行了，这是因为数据库表格的字段名和实体类的属性名不一样，导致resultType获取不到结果 编写测试类来测试刚刚的编码结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package tk.mybatis.simple.mapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.BeforeClass;import org.junit.Test;import tk.mybatis.simple.model.Country;import java.io.IOException;import java.io.Reader;import java.util.List;/** * @Auther: ajin * @Date: 2019/2/1 15:37 * @Description: */public class CountryMapperTest { private static SqlSessionFactory sessionFactory; @BeforeClass public static void init() { try { //注意，此处会有IO异常，这个很容易理解的 Reader reader = Resources.getResourceAsReader(\"mybatis-config.xml\"); sessionFactory = new SqlSessionFactoryBuilder().build(reader); //Reader负责把mybatis的配置文件和mapper.xml读取出来，然后它就不做其他工作了，所以此处要关闭它 reader.close(); } catch (IOException exception) { exception.printStackTrace(); } } @Test public void testSelectAll() { //获取SqlSession对象 SqlSession session = sessionFactory.openSession(); try { //SqlSession去调用底层的JDBC代码查询获得结果集ResultSet, // 然后我们把ResultSet映射成我们需要的resultType/resultMap(实体类对象的属性) List&lt;Country&gt; countryList = session.selectList(\"selectAll\"); //调用打印方法，在控制台输出运行结果 printCountryList(countryList); } finally { //关闭SqlSession对象 session.close(); } } //该方法单独拿出来写，比较规范，而且private,比较贴切，因为这个方法只在本测试类的方法中调用 private void printCountryList(List&lt;Country&gt; countryList) { for (Country country : countryList) { System.out.printf(\"%-4d%4s%4s\\n\", country.getId(), country.getCountryname(), country.getCountrycode()); } }} xml方式基于RBAC的权限管理RBAC Role-Based Access Controll 基于角色的访问控制 简单来说就是，不同的角色拥有不同的权限，不同的权限就是指对资源的操作（增、删、改、查） ### 编码 实体类属性的byte[]类型，对应的是数据库的BLOB 、 LONGVARBINARY 以及一些和二进制流有关的字段类型 在实体类中不要使用基本类型，包括byte 、 int 、short 、 long 、 float 、double 、 char 、 boolean 。会出错的。 由于数据库区分 date 、 time 、 datetime 类型，但是 Java 中一般都使用 java.util. Date类型 。 因此为了保证数据类型的正确，需要手动指定日期类型， date 、 time 、 datetime 对应的 JDBC 类型分别为 DATE 、 TIME 、TIMESTAMP。 12345678910111213&lt;!--此处的parametertype可以不用配置--&gt;&lt;insert id=\"insert\" &gt; insert into sys_user values(#{id},#{userName},#{userPassword},#{userEmail}, #{userInfo},#{headImg,jdbcType=BLOB},#{createTime,jdbcType=TIMESTAMP})&lt;/insert&gt;&lt;!--这种方式适合数据库带自增主键的--&gt;&lt;insert id=\"insert2\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into sys_user(user_name,user_password,user_email, user_info,head_img,create_time) values(#{userName},#{userPassword},#{userEmail}, #{userInfo},#{headImg,jdbcType=BLOB},#{createTime,jdbcType=TIMESTAMP})&lt;/insert&gt; 下面的insert标签比上面的多了useGeneratedKeys和 keyProperty这两个属性，我们来看一下。 useGeneratedKeys：该属性被设置为true后，MyBatis会使用JDBC的getGeneratedKeys()取出由数据库内部生成的主键，然后获得主键值后，将其赋值给keyProperty的id属性。 当需要设置多个属性时，使用逗号隔开，这种情况下通常还需要设置 keyColumn 属性 ， 按顺序指定数据库的列，这里列的值会和 keyProperty 配置的属性一一对应。 由于要使用数据库返回的主键值，所以 SQL 上下两部分的列中去掉了 id 列和对应的＃{ id }属性。 注解MyBatis 注解方式就是将 SQL 语句直接写在接口上。这种方式的优点是 ， 对于需求比较简单的系统，效率较高。缺点是 ， 当 SQL 有变化时都需要重新编译代码， 一般情况下不建议使用注解 方式 注解的方式不建议使用，就学习过，当一个了解 动态SQL有一些细节要注意，但是更重要的是要动手写代码 高级结果查询（特别重要）高级结果映射1.一对一映射 记录下这几种方式 自动映射12345678910111213141516171819&lt;!--MyBatis一对一自动映射--&gt; &lt;select id=\"selectUserAndRoleById\" resultType=\"tk.mybatis.model.SysUser\"&gt; select u.id, u.user_name userName, u.user_password userPassword, u.user_email userEmail, u.user_info userInfo, u.head_img headImg, u.create_time createTime, r.id \"role.id\", r.role_name \"role.name\", r.enabled \"role.enabled\", r.create_by \"role.createBy\", r.create_time \"role.createTime\" from sys_user u inner join sys_user_role ur on u.id=ur.user_id inner join sys_role r on ur.role_id=r.id where u.id=#{id} &lt;/select&gt; 这个通过在SysUser实体类中加入SysRole(role)对象，然后通过两次关联查询查到最中的结果，主要看下r.id….这些内容 通过ResultMap12345678910111213141516171819202122&lt;resultMap id=\"UserMap\" type=\"tk.mybatis.model.SysUser\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"user_name\" property=\"userName\"/&gt; &lt;result column=\"user_password\" property=\"userPassword\"/&gt; &lt;result column=\"user_email\" property=\"userEmail\"/&gt; &lt;result column=\"user_info\" property=\"userInfo\"/&gt; &lt;result column=\"head_img\" property=\"headImg\" jdbcType=\"BLOB\"/&gt; &lt;result column=\"create_time\" property=\"createTime\" jdbcType=\"TIMESTAMP\"/&gt;&lt;/resultMap&gt;&lt;!--现在继承UserMap就行,就不用写多余的属性了--&gt;&lt;resultMap id=\"UserRoleMap\" extends=\"UserMap\" type=\"tk.mybatis.model.SysUser\"&gt; &lt;!--新增role相关属性--&gt; &lt;result property=\"role.id\" column=\"role_id\"/&gt; &lt;result property=\"role.roleName\" column=\"role_name\"/&gt; &lt;result property=\"role.enabled\" column=\"enabled\"/&gt; &lt;result property=\"role.createBy\" column=\"create_by\"/&gt; &lt;result property=\"role.createTime\" column=\"create_time\" jdbcType=\"TIMESTAMP\"/&gt;&lt;/resultMap&gt; 1234567891011121314151617&lt;select id=\"selectUserAndRoleById2\" resultMap=\"UserRoleMap\"&gt; select u.id, u.user_name, u.user_password, u.user_email, u.user_info, u.head_img, u.create_time, r.id role.id, r.role_name , r.enabled enabled, r.create_by create_by, r.create_time role_create_time from sys_user u inner join sys_user_role ur on u.id=ur.user_id inner join sys_role r on ur.role_id=r.id where u.id=#{id}&lt;/select&gt; 个人不是很喜欢这种方式，所以简单了解 使用 resultMap 的 association 标签配置一对一映射12345678910&lt;!--使用association标签来完成一对一映射--&gt;&lt;resultMap id=\"UserRoleMap2\" extends=\"UserMap\" type=\"tk.mybatis.model.SysUser\"&gt; &lt;association property=\"role\" columnPrefix=\"role_\" javaType=\"tk.mybatis.model.SysRole\"&gt; &lt;result property=\"id\" column=\"id\"/&gt; &lt;result property=\"roleName\" column=\"role_name\"/&gt; &lt;result property=\"enabled\" column=\"enabled\"/&gt; &lt;result property=\"createBy\" column=\"create_by\"/&gt; &lt;result property=\"createTime\" column=\"create_time\" jdbcType=\"TIMESTAMP\"/&gt; &lt;/association&gt;&lt;/resultMap&gt; 123456789101112131415161718&lt;!--使用association标签--&gt;&lt;select id=\"selectUserAndRoleById3\" resultMap=\"UserRoleMap\"&gt; select u.id, u.user_name, u.user_password, u.user_email, u.user_info, u.head_img, u.create_time, r.id role_id, r.role_name role_role_name, r.enabled role_enabled, r.create_by role_create_by, r.create_time role_create_time from sys_user u inner join sys_user_role ur on u.id=ur.user_id inner join sys_role r on ur.role_id=r.id where u.id=#{id}&lt;/select&gt; 此处我的理解就是：这个select标签，role表的别名写在这，是为了映射给id为UserRoleMap2的ResultMap标签中的column属性 association 标签的嵌套查询​ 需要UserMapper和RoleMapper做两次查询，第一次关联查询，第二次简单查询 2. 一对多映射collection 集合的嵌套结果映射 在SysUser类中增加属性以及get set方法 123456 /** * 用户的角色集合 用来实现一对多映射 **/ private List&lt;SysRole&gt; roleList; //此处省略其get set 方法 UserMapper.xml 123456789&lt;resultMap id=\"UserMap\" type=\"tk.mybatis.model.SysUser\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"user_name\" property=\"userName\"/&gt; &lt;result column=\"user_password\" property=\"userPassword\"/&gt; &lt;result column=\"user_email\" property=\"userEmail\"/&gt; &lt;result column=\"user_info\" property=\"userInfo\"/&gt; &lt;result column=\"head_img\" property=\"headImg\" jdbcType=\"BLOB\"/&gt; &lt;result column=\"create_time\" property=\"createTime\" jdbcType=\"TIMESTAMP\"/&gt; &lt;/resultMap&gt; 1234&lt;!--使用collection标签来实现一对多查询--&gt; &lt;resultMap id=\"userRoleListMap\" extends=\"UserMap\" type=\"tk.mybatis.model.SysUser\"&gt; &lt;collection property=\"roleList\" columnPrefix=\"role_\" resultMap=\"tk.mybatis.mapper.RoleMapper.roleMap\"/&gt; &lt;/resultMap&gt; 1234567891011121314151617&lt;!--collection标签实现一对多的映射--&gt;&lt;select id=\"selectAllUserAndRoles\" resultMap=\"userRoleListMap\"&gt; select u.id, u.user_name, u.user_password, u.user_info, u.head_img, u.create_time, r.id role_id, r.role_name role_role_name, r.enabled role_enabled, r.create_by role_create_by, r.create_time role_create_time from sys_user u inner join sys_user_role ur on u.id=ur.user_id inner join sys_role r on ur.role_id=r.id&lt;/select&gt; RoleMapper.xml 12345678910111213&lt;resultMap id=\"roleMap\" type=\"tk.mybatis.model.SysRole\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"roleName\" column=\"role_name\"/&gt; &lt;result property=\"enabled\" column=\"enabled\"/&gt; &lt;result property=\"createBy\" column=\"create_by\"/&gt; &lt;result property=\"createTime\" column=\"create_time\" jdbcType=\"TIMESTAMP\"/&gt;&lt;/resultMap&gt;&lt;select id=\"selectRoleById\" resultMap=\"roleMap\"&gt; select * from sys_role where id=#{id}&lt;/select&gt; 写UserMapper接口中的对应方法 123456/** * 获取所有的用户以及对应的所有角色 * @return * @Param **/ List&lt;SysUser&gt; selectAllUserAndRoles(); 测试方法 1234567891011121314151617@Test public void testSelectAllUserAndRoles(){ SqlSession session=getSqlSession(); try { UserMapper userMapper= session.getMapper(UserMapper.class); List&lt;SysUser&gt; userList= userMapper.selectAllUserAndRoles(); System.out.println(\"用户总数：\"+userList.size()); for (SysUser user: userList){ System.out.println(\"用户名：\"+user.getUserName()); for(SysRole role:user.getRoleList()) { System.out.println(\"本用户拥有的角色名：\"+role.getRoleName()); } } } finally { session.close(); } } 通过上面的例子我们很容易得知用户和角色的关系是多对多，具体到一个用户的时候，可能是一对多，也可能是一对一的关系，总之我们当成一对多来处理就对了 collection 集合的嵌套查询两次分开的关联查询，两次inner join 3.鉴别器映射 简单了解，很少使用 存储过程略过 枚举在数据库中enabled字段，对应SysRole实体类中的引入的枚举类对象Enabled 1234public enum Enabled { disabled,//禁用 0 enabled;//启用 1} SysRole类的修改 1234567 /** * 有效标志 * *///private Integer enabled; private Enabled enabled;//此处省略get set方法 产生一个问题：这个枚举值如何与数据库进行交互呢？ 在数据库中，不存在能和Enabled枚举值对应的数据库类型，所以在和数据库交互的时候，不能直接使用枚举类型。 在查询数据时，需要将数据库int类型的值转换成Java中的枚举值 在保存，更新或者作为查询条件时，需要将枚举值替换成数据库中的int类型 这样思路就清楚了 MyBatis高级结果映射一个重要的习惯，就是一点一点的去映射，然后再多次进行单元测试，检测自己的思路和xml文件是否写得正确。 一定要单元测试。 缓存MyBatis的一级缓存只存在SqlSession中，而二级缓存存在SqlSessionFactory中 自身实现集成EhCache缓存个人觉得应用不是太多 集成Redis缓存 关于二级缓存，建议使用以查询为主的情境中，而且要注意关联查询产生的脏数据，并且要去解决脏数据。 完毕","link":"/2019/02/07/《MyBatis从入门到精通》笔记/"},{"title":"对象与类","text":"封装​ 封装的关键在于绝对不能让类中的方法直接访问其他类的实例域（属性），程序仅通过对象的方法与对象数据进行交互。 ​ 关于这一点，最明显的事例： ​ Java中实体类，只有通过get set方法才能访问其属性，不能直接通过对象的属性直接访问 ​ 有了封装，我的get set 方法不变，但是对于属性，我可以做一些操作和变化，但是其他类的方法还是会通过get方法来访问属性。无论我对属性做了什么变化，它们都无需关心。 ​ 1. 封装，外部只能通过方法来访问到属性，但是却不能对属性做任何修改，这个也是对类的一种保护； ​ 2. 而且封装可以对get set方法做一些处理，但是外界只管调用即可，不用关心内部get、get方法的细节 对象​ ​ 对象的三个主要特性： 对象的行为——可以对对象施加哪些操作或方法 对象的状态——当施加那些方法时，对象如何响应 对象标识——如何辨别具有相同行为和状态的不同对象 类之间的关系 依赖 “uses-a“ ​ 如果一个类的方法操纵另一个类的对象，则说明一个类依赖于另一个类 ​ 应该尽可能让相互依赖的类减少到最少，也就是说，让类之间的耦合减少到最小； ​ 因为如果A类依赖于B类，那么如果B类变化，产生了bug，那么对A类也会产生影响 聚合 “has-a“ ​ 类A的对象包含类B的对象 继承 “is-a“ ​ VipOrder类继承自Order类，那么VipOrder类除了拥有Order类的特性，还拥有其他自身的特性 构造器​ 在Java中，我们通常用构造器创建新的对象实例。 123451. 构造器与类名相同2. 每个类有一个以上的构造器3. 构造器可以没有参数，也可以有任意多个参数4. 构造器是没有返回值的5. 构造器总是随着new 一起调用的 千万不要再构造器中定义与实例域重名的局部变量 无参构造器​ 如果不显式声明无参构造器，那么系统会提供一个无参构造器。 对于默认构造器的话，没有参数的初始化，那么数据类型就是0，对象类型就是null，布尔类型就是false ​ 1. 如果类中有一个有参构造器，但是没有无参构造器，则在构造对象时，如果没有提供参数，就会被视为不合法。 ​ 如： ​ Employee(String name,double salary){ ​ …} ​ new Employee()会报错 我们发现构造器多个的时候，也会发生重载 构造器里面的操作，主要是初始化 一个构造器可以调用另一个构造器 this(,.....); 对象与对象变量​ 对象变量就是引用变量的意思， ​ Date presentTime=new Date().toString(); ​ 引用变量可以让对象被重复使用 我们说引用变量不是对象，它就是一个变量，它可以引用一个某类型的对象 final修饰的变量​ final修饰的实例域，在new 构造器创建一个对象实例后，必须给这个实例域进行设置值， ​ 并且在后面的操作过程中，对其不再修改。 这样的值，是不用给其设置set方法的，因为它本身就不能被修改. 如果尝试对其进行修改，IDE会直接报错 举例子： private static final String ALL_USE_VAR=”……”; private static final Logger logger=LoggerFactory.getLogger(UserInfo.class); 12345private final String A_VAR; public A(String a) { A_VAR=a; } 由我的实践得出结论： 可以通过构造器中去给final修饰的变量进行赋值，完成初始化 也可以直接给其赋值 private final String A_VAR=&quot;1111&quot;; static关键字 static修饰的变量属于整个类，所有该类的实例对象共享该变量。（静态变量） 静态方法（static修饰的方法）：静态方法也属于整个类，而不是属于哪个对象；然后静态方法只能访问静态变量，不能访问类中的非静态变量。 可以使用类名来访问静态方法： 例如： Aclass.staticMethod() 同样地，也可以通过类名来访问静态变量 Aclass.staticVar 引申一下，如果是非静态变量或者是非静态方法，那么我们可以通过先new一个对象出来，然后用对象实例去访问非静态变量和非静态方法 方法参数 在Java当中，方法得到的参数，是所有参数值的一个拷贝，方法不会改变原参数的值，它只是将原参数的值拿过来用一下。 double percent=10; harry.raiseSalary(percent); 这个方法无论如何实现，内部逻辑是什么，percent参数的值始终不会发生改变 ​ 方法参数有两种类型： 基本数据类型 对象引用类型 Java中方法参数的使用情况： 一个方法不能修改一个基本数据类型的参数 一个方法可以改变一个对象参数的状态 Java采取的是值调用，对于对象引用来说，方法获取的参数，不是对象，而是对象对应的引用变量。 一个方法不可以让一个对象参数引用一个新的对象 重载多个方法，方法名相同，参数不同（不考虑方法的返回值类型是否一致），这就产生了重载，overloading。 注：此处的参数不同，是两个方面： 参数个数不同 参数类型不同 重载解析：编译器根据参数个数和参数类型来判断，具体调用哪个方法；如果找不到方法，就会报编译错误。 垃圾回收器Java有自动的垃圾回收器，所以不需要人工回收内存 包​ 我们在Java项目中，会有多个不同的包，使用包的主要原因，就是确保类名的唯一性。 ​ 例如：我们在两个包中新建名为Employee类，没有任何问题 ​ import导入包 ​ import java.util.List; Java中private、protected、public和default的区别 public： 具有最大的访问权限，可以访问任何一个在classpath下的类、接口、异常等。它往往用于对外的情况，也就是对象或类对外的一种接口的形式。 protected： 主要的作用就是用来保护子类的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西 default： 有时候也称为friendly，它是针对本包访问而设计的，任何处于本包下的类、接口、异常等，都可以相互访问，即使是父类没有用protected修饰的成员也可以。 private： 访问权限仅限于类的内部，是一种封装的体现，例如，大多数成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问。 类设计技巧 一定要保证数据私有 绝对不要破坏封装性！ 数据的表示形式可能会改变，但是数据的使用方式却不会经常发生变化。 当数据保持私有的时候，它们的表示形式变化不会对类的使用者产生影响，即使产生bug也容易检测 一定要对数据进行初始化 Java语言不会对局部变量进行初始化，但是会对实例域进行初始化。但是就算是这样，我们对Java中用到的变量，都要显示地初始化所有数据。 初始化，可以通过提供默认值地方式，也可以在构造器中设置默认值。 不要在类中使用过多的基本类型 我们可以用其他类来代替这些基本类型 1private String street,city,province; 替换成Address类 不是所有的域都需要get和set方法 在开发过程中，我们的实体类，get,set随便写， 但是有些属性，我们不希望被修改，那么就可以不设置set方法； 并且有的属性，不希望被获取，那么就可以不设置get方法。 将职责过多的类进行分解 类名和方法名要体现出它们的职责 变量名也要体现出它们的职责，不要乱命名","link":"/2019/02/10/对象与类/"},{"title":"Spring MVC 源码初探（三）容器的创建过程","text":"1. 容器的概述​ 一般情况下，我们会在一个 Web 应用中配置两个容器。一个容器用于加载 Web 层的类，比如我们的接口 Controller、HandlerMapping、ViewResolver 等。我们把这个容器叫做 web 容器。另一个容器用于加载业务逻辑相关的类，比如 service、dao 层的一些类。我们就把这个容器称为业务容器。 ​ 在容器初始化的过程中，业务容器会先于web容器进行初始化。实际上，我们把业务容器作为web容器的父容器。这么说，是因为web容器中的bean会依赖业务容器的bean。很常见的，web层处理请求的时候，常常会调用service层的代码。 ​ ​ 在具体分析容器的创建之前，我们可以先忘记Spring Boot“约定优于配置”的理念，看下Spring MVC的配置文件： 123456789101112131415161718192021222324252627282930&lt;!-- 省略非关键的配置 --&gt;&lt;!-- [1] Spring配置 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 指定Spring Bean的配置文件所在目录。可以通过ServletContext对象获取。默认配置在WEB-INF目录下 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- ====================================== --&gt;&lt;!-- [2] Spring MVC配置 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 可以自定义servlet.xml配置文件的位置和名称，默认为WEB-INF目录下，名称为[&lt;servlet-name&gt;]-servlet.xml，如spring-servlet.xml &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring-servlet.xml&lt;/param-value&gt; // 默认 &lt;/init-param&gt; --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 2. 业务容器的创建过程2.1 ContextLoaderListener​ 在Servlet容器（Tomcat,Jetty)启动的时候，会被ContextLoaderListener监听到，从而调用contextInitialized(ServletContextEvent event)方法，实现对Root WebApplicationContext容器的初始化。 ​ ContextLoaderListener的配置如下： 123456789101112&lt;web-app&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:application.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 省略其他配置 --&gt;&lt;/web-app&gt; 如上所示，&lt;context-param&gt;中的内容可以通过ServletContext获取到，则业务容器可以通过ServletContext对象获取到application.xml配置文件中的内容了。 ​ 我们从源码来看一下业务容器的创建过程： 12345678910111213141516171819202122232425262728293031public class ContextLoaderListener extends ContextLoader implements ServletContextListener { public ContextLoaderListener() { } public ContextLoaderListener(WebApplicationContext context) { super(context); } /** * 在Servlet容器（Tomcat,Jetty)启动的时候，会被ContextLoaderListener监听到， * 从而调用contextInitialized(ServletContextEvent event)方法， * 实现对Root WebApplicationContext容器的初始化 */ @Override public void contextInitialized(ServletContextEvent event) { //初始化WebApplicationContext容器 initWebApplicationContext(event.getServletContext()); } /** * 在Servlet 容器关闭时，销毁 WebApplicationContext 容器。 * Close the root web application context. */ @Override public void contextDestroyed(ServletContextEvent event) { //销毁WebApplicationContext容器，销毁逻辑暂时先留着 closeWebApplicationContext(event.getServletContext()); ContextCleanupListener.cleanupAttributes(event.getServletContext()); }} ​ 根据注释，不难理解，业务容器创建的时候，调用了父类ContextLoader的 initWebApplicationContext(event.getServletContext())方法，传入的是通过ServletEvent对象获取的ServletContext对象。我们继续看一下Contextloader中的调用方法 2.2 ContextLoader2.2.1 initWebApplicationContext1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public WebApplicationContext initWebApplicationContext(ServletContext servletContext) { // &lt;1&gt; 如果 ServletContext 中 ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE 属性值 // 不为空时，表明有其他监听器设置了这个属性。Spring 认为不能替换掉别的监听器设置 // 的属性值，所以这里抛出异常。 if(servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) { throw new IllegalStateException( \"Cannot initialize context because there is already a root application context present - \" + \"check whether you have multiple ContextLoader* definitions in your web.xml!\"); } //&lt;2&gt;打印日志 servletContext.log(\"Initializing Spring root WebApplicationContext\"); Log logger = LogFactory.getLog(ContextLoader.class); if (logger.isInfoEnabled()) { logger.info(\"Root WebApplicationContext: initialization started\"); } //记录开始时间 long startTime = System.currentTimeMillis(); try { // Store context in local instance variable, to guarantee that // it is available on ServletContext shutdown. if (this.context == null) { //初始化context，也就是创建context this.context = createWebApplicationContext(servletContext); } // &lt;4&gt; 如果是 ConfigurableWebApplicationContext 的子类，如果未刷新，则进行配置和刷新 if (this.context instanceof ConfigurableWebApplicationContext) { ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context; if (!cwac.isActive()) { // &lt;4.1&gt; 未刷新( 激活 ) // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) {//这个if语句，一般走不进来的 /** * &lt;4.2&gt; 无父容器，则进行加载和设置 * 加载父 ApplicationContext，一般情况下，业务容器不会有父容器， * 除非进行配置 * **/ // The context instance was injected without an explicit parent -&gt; // determine parent for root web application context, if any. ApplicationContext parent = loadParentContext(servletContext); cwac.setParent(parent); } // &lt;4.3&gt; 配置 context 对象，并进行刷新 configureAndRefreshWebApplicationContext(cwac, servletContext); } } // &lt;5&gt; 记录在 servletContext 中 servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context); // &lt;6&gt; 记录到 currentContext 或 currentContextPerThread 中 ClassLoader ccl = Thread.currentThread().getContextClassLoader(); if (ccl == ContextLoader.class.getClassLoader()) { currentContext = this.context; } else if (ccl != null) { currentContextPerThread.put(ccl, this.context); } // &lt;7&gt; 打印日志 if (logger.isInfoEnabled()) { long elapsedTime = System.currentTimeMillis() - startTime; logger.info(\"Root WebApplicationContext initialized in \" + elapsedTime + \" ms\"); } // &lt;8&gt; 返回 context return this.context; } catch (RuntimeException | Error ex) { // &lt;9&gt; 当发生异常，记录异常到 WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE 中， // 不再重新初始化。 logger.error(\"Context initialization failed\", ex); servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex); throw ex; }} 该方法为给定的servlet上下文（Servlet Context）初始化Spring的Web应用程序上下文 WebApplicationContext 首先 Spring 会检测 ServletContext 中 ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE 属性有没有被设置，若被设置过，则抛出异常。若未设置，则调用 createWebApplicationContext 方法创建容器。 创建好后，再调用 configureAndRefreshWebApplicationContext 方法配置并刷新容器。 最后，调用 setAttribute 方法将容器设置到 ServletContext 中。经过以上几步，整个创建流程就结束了。 流程并不复杂，可简单总结为创建容器 → 配置并刷新容器 → 设置容器到 ServletContext 中 2.2.2 createWebApplicationContext1234567891011121314//创建WebApplicationContext对象（业务容器 dao service...）protected WebApplicationContext createWebApplicationContext(ServletContext sc) { // 判断创建什么类型的容器，默认类型为 XmlWebApplicationContext // &lt;1&gt; 获得 context 的类 Class&lt;?&gt; contextClass = determineContextClass(sc); // &lt;2&gt; 判断 context 的类，是否符合 ConfigurableWebApplicationContext 的类型 if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) { throw new ApplicationContextException(\"Custom context class [\" + contextClass.getName() + \"] is not of type [\" + ConfigurableWebApplicationContext.class.getName() + \"]\"); } // &lt;3&gt; 创建 context 的类的对象( 通过反射创建容器 ) return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);} 该方法首先会调用 determineContextClass 判断创建什么类型的容器，默认为 XmlWebApplicationContext。 12345678910111213141516171819202122232425262728293031323334353637383940public static final String CONTEXT_CLASS_PARAM = \"contextClass\";protected Class&lt;?&gt; determineContextClass(ServletContext servletContext) { // 获得参数 contextClass 的值 /* * 读取用户自定义配置，比如： * &lt;context-param&gt; * &lt;param-name&gt;contextClass&lt;/param-name&gt; * &lt;param-value&gt;XXXConfigWebApplicationContext&lt;/param-value&gt; * &lt;/context-param&gt; */ String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM); // 情况一，如果值非空，则获得该类 if (contextClassName != null) { try { return ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader()); } catch (ClassNotFoundException ex) { throw new ApplicationContextException( \"Failed to load custom context class [\" + contextClassName + \"]\", ex); } // 情况二，从 defaultStrategies 获得该类 } else { /* * 若无自定义配置，则获取默认的容器类型，默认类型为 XmlWebApplicationContext。 * defaultStrategies 读取的配置文件为 ContextLoader.properties， * 该配置文件内容如下： * org.springframework.web.context.WebApplicationContext = * org.springframework.web.context.support.XmlWebApplicationContext */ contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName()); try { return ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader()); } catch (ClassNotFoundException ex) { throw new ApplicationContextException( \"Failed to load default context class [\" + contextClassName + \"]\", ex); } }} 然后调用 instantiateClass 方法通过反射的方式创建容器实例 2.2.3 configureAndRefreshWebApplicationContext123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) { // &lt;1&gt; 如果 wac 使用了默认编号，则重新设置 id 属性 if (ObjectUtils.identityToString(wac).equals(wac.getId())) { // The application context id is still set to its original default value // -&gt; assign a more useful id based on available information // 情况一，使用 contextId 属性 ; 从 ServletContext 中获取用户配置的 contextId 属性 // public static final String CONTEXT_ID_PARAM = \"contextId\"; String idParam = sc.getInitParameter(CONTEXT_ID_PARAM); if (idParam != null) { // 设置容器 id wac.setId(idParam); } else { // 情况二，自动生成 // 用户未配置 contextId，则设置一个默认的容器 id // Generate default id... wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + ObjectUtils.getDisplayString(sc.getContextPath())); } } // &lt;2&gt;设置 context 的 ServletContext 属性 wac.setServletContext(sc); // &lt;3&gt; 设置 context 的配置文件地址 // 获取 contextConfigLocation 配置 /** &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; */ //public static final String CONFIG_LOCATION_PARAM = \"contextConfigLocation\"; String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM); if (configLocationParam != null) { //并将contextConfigLocation 配置设置到业务容器 //相当于获取业务容器的bean配置信息 wac.setConfigLocation(configLocationParam); } // The wac environment's #initPropertySources will be called in any case when the context // is refreshed; do it eagerly here to ensure servlet property sources are in place for // use in any post-processing or initialization that occurs below prior to #refresh // &lt;4&gt; TODO 芋艿的解析暂时没写 ConfigurableEnvironment env = wac.getEnvironment(); if (env instanceof ConfigurableWebEnvironment) { ((ConfigurableWebEnvironment) env).initPropertySources(sc, null); } // &lt;5&gt; 执行自定义初始化 context TODO 芋艿，暂时忽略 customizeContext(sc, wac); // 刷新 context 容器，执行初始化 wac.refresh();} 设置容器 id 获取 contextConfigLocation 配置，并设置到容器中 刷新容器 2.2.4 closeWebApplicationContext12345678910111213141516171819public void closeWebApplicationContext(ServletContext servletContext) { servletContext.log(\"Closing Spring root WebApplicationContext\"); try { // 关闭 context if (this.context instanceof ConfigurableWebApplicationContext) { ((ConfigurableWebApplicationContext) this.context).close(); } } finally { // 移除 currentContext 或 currentContextPerThread ClassLoader ccl = Thread.currentThread().getContextClassLoader(); if (ccl == ContextLoader.class.getClassLoader()) { currentContext = null; } else if (ccl != null) { currentContextPerThread.remove(ccl); } // 从 ServletContext 中移除 servletContext.removeAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE); }} 3. Web容器的创建过程3.1 HttpServletBean3.1.1 init12345678910111213141516171819202122232425262728293031@Overridepublic final void init() throws ServletException { // 获取 ServletConfig 中的配置信息 // Set bean properties from init parameters. PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties); if (!pvs.isEmpty()) { try { /* * 为当前对象（比如 DispatcherServlet 对象）创建一个 BeanWrapper， * 方便读/写对象属性。 */ BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext()); bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment())); //为HttpServletBean初始化BeanWrapper,给具体的子类去重写，因为在该类中，initBeanWrapper是空方法 initBeanWrapper(bw); // 设置配置信息到目标对象中 bw.setPropertyValues(pvs, true); } catch (BeansException ex) { if (logger.isErrorEnabled()) { logger.error(\"Failed to set bean properties on servlet '\" + getServletName() + \"'\", ex); } throw ex; } } // 进行后续的初始化 // 让子类做他们喜欢的任何初始化，在该类中initServletBean()为空，留给子类重写 // Let subclasses do whatever initialization they like. initServletBean();} 该方法是创建 Web 容器的入口,将 ServletConfig 中的配置信息设置到 HttpServletBean 的子类对象中（比如 DispatcherServlet) 我们并未从上面的源码中发现创建容器的痕迹。 initServletBean 这个方法稍显奇怪，是个空方法。这个方法的访问级别为 protected，子类可进行覆盖。HttpServletBean 的子类 FrameworkServlet 覆写了这个方法。 3.2 FrameworkServlet3.2.1 initServletBean123456789101112131415161718192021222324252627282930@Override protected final void initServletBean() throws ServletException { getServletContext().log(\"Initializing Spring \" + getClass().getSimpleName() + \" '\" + getServletName() + \"'\"); if (logger.isInfoEnabled()) { logger.info(\"Initializing Servlet '\" + getServletName() + \"'\"); } long startTime = System.currentTimeMillis(); try { // 初始化容器 this.webApplicationContext = initWebApplicationContext(); initFrameworkServlet(); } catch (ServletException | RuntimeException ex) { logger.error(\"Context initialization failed\", ex); throw ex; } if (logger.isDebugEnabled()) { String value = this.enableLoggingRequestDetails ? \"shown which may lead to unsafe logging of potentially sensitive data\" : \"masked to prevent unsafe logging of potentially sensitive data\"; logger.debug(\"enableLoggingRequestDetails='\" + this.enableLoggingRequestDetails + \"': request parameters and headers will be \" + value); } if (logger.isInfoEnabled()) { logger.info(\"Completed initialization in \" + (System.currentTimeMillis() - startTime) + \" ms\"); } } 3.2.2 initWebApplicationContext1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071protected WebApplicationContext initWebApplicationContext() { // 从 ServletContext 中获取容器，也就是 ContextLoaderListener 创建的容器 WebApplicationContext rootContext =//父容器，也就是业务容器 WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; /* * 若下面的条件成立，则需要从外部设置 WebApplicationContext。 * * 有两个途径可以设置 * * WebApplicationContext，以 DispatcherServlet 为例： * 1. 通过 DispatcherServlet 有参构造方法传入 WebApplicationContext 对象 * 2. 将 DispatcherServlet 配置到其他容器中，由其他容器通过 * setApplicationContext 方法进行设置 * * 途径1 可参考 AbstractDispatcherServletInitializer 中的 * registerDispatcherServlet 方法源码。一般情况下，代码执行到此处， * this.webApplicationContext 为 null，大家可自行调试进行验证。 */ if (this.webApplicationContext != null) { // A context instance was injected at construction time -&gt; use it wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) { ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) { // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) { // The context instance was injected without an explicit parent -&gt; set // the root application context (if any; may be null) as the parent // 设置 rootContext 为父容器 cwac.setParent(rootContext); } // 配置并刷新容器 configureAndRefreshWebApplicationContext(cwac); } } } if (wac == null) { // No context instance was injected at construction time -&gt; see if one // has been registered in the servlet context. If one exists, it is assumed // that the parent context (if any) has already been set and that the // user has performed any initialization such as setting the context id // 尝试从 ServletContext 中获取容器 wac = findWebApplicationContext(); } if (wac == null) { // No context instance is defined for this servlet -&gt; create a local one // 创建容器，并将 rootContext 作为父容器 wac = createWebApplicationContext(rootContext); } if (!this.refreshEventReceived) { // Either the context is not a ConfigurableApplicationContext with refresh // support or the context injected at construction time had already been // refreshed -&gt; trigger initial onRefresh manually here. synchronized (this.onRefreshMonitor) { onRefresh(wac); } } if (this.publishContext) { // Publish the context as a servlet context attribute. // 将创建好的容器设置到 ServletContext 中 String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); } return wac;} ​ 可以总结下Web容器的创建过程: 从 ServletContext 中获取 ContextLoaderListener 创建的容器(业务容器) 若 this.webApplicationContext != null 条件成立，仅设置父容器和刷新容器即可 尝试从 ServletContext 中获取容器，若容器不为空，则无需执行步骤4 创建容器，并将 rootContext 作为父容器 设置容器到 ServletContext 中 3.2.3 configureAndRefreshWebApplicationContext12345678910111213141516171819202122232425262728293031323334protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) { if (ObjectUtils.identityToString(wac).equals(wac.getId())) { // The application context id is still set to its original default value // -&gt; assign a more useful id based on available information if (this.contextId != null) { // 设置容器 id wac.setId(this.contextId); } else { // 生成默认 id // Generate default id... wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + ObjectUtils.getDisplayString(getServletContext().getContextPath()) + '/' + getServletName()); } } wac.setServletContext(getServletContext()); wac.setServletConfig(getServletConfig()); wac.setNamespace(getNamespace()); wac.addApplicationListener(new SourceFilteringListener(wac, new ContextRefreshListener())); // The wac environment's #initPropertySources will be called in any case when the context // is refreshed; do it eagerly here to ensure servlet property sources are in place for // use in any post-processing or initialization that occurs below prior to #refresh ConfigurableEnvironment env = wac.getEnvironment(); if (env instanceof ConfigurableWebEnvironment) { ((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig()); } // 后置处理，子类可以覆盖进行一些自定义操作。在 Spring MVC 未使用到，是个空方法。 postProcessWebApplicationContext(wac); applyInitializers(wac); // 刷新容器 wac.refresh();} 3.2.4 createWebApplicationContext123456789101112131415161718192021222324protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) { // 获取容器类型，默认为 XmlWebApplicationContext.class Class&lt;?&gt; contextClass = getContextClass(); if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) { throw new ApplicationContextException( \"Fatal initialization error in servlet with name '\" + getServletName() + \"': custom WebApplicationContext class [\" + contextClass.getName() + \"] is not of type ConfigurableWebApplicationContext\"); } // 通过反射实例化容器 ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass); wac.setEnvironment(getEnvironment()); wac.setParent(parent); String configLocation = getContextConfigLocation(); if (configLocation != null) { wac.setConfigLocation(configLocation); } // 配置并刷新容器 configureAndRefreshWebApplicationContext(wac); return wac;} ​ 参考资料：田小波：Spring MVC 原理探秘 - 容器的创建过程","link":"/2019/01/12/Spring-MVC-源码初探（三）容器的创建过程/"}],"tags":[{"name":"学习指南","slug":"学习指南","link":"/tags/学习指南/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Spring Cloud","slug":"Spring-Cloud","link":"/tags/Spring-Cloud/"},{"name":"MyBatis","slug":"MyBatis","link":"/tags/MyBatis/"},{"name":"Spring MVC","slug":"Spring-MVC","link":"/tags/Spring-MVC/"},{"name":"数据库","slug":"数据库","link":"/tags/数据库/"},{"name":"面试题","slug":"面试题","link":"/tags/面试题/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[]}