<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="时间旅行者" type="application/atom+xml">






<meta name="description" content="Java学习记录博客">
<meta property="og:type" content="website">
<meta property="og:title" content="时间旅行者">
<meta property="og:url" content="https://www.liutianruo.com/page/3/index.html">
<meta property="og:site_name" content="时间旅行者">
<meta property="og:description" content="Java学习记录博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="时间旅行者">
<meta name="twitter:description" content="Java学习记录博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.liutianruo.com/page/3/">





  <title>时间旅行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">时间旅行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-categories"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/14/深入Java-IO/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/深入Java-IO/" itemprop="url">深入Java IO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T21:34:59+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>机智的我，又在知识星球找到了IO的干货，那就跟着干货深入整理一下IO的全面知识点。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol>
<li><p>什么是流，什么是比特，什么是字节，什么是字符 </p>
<ul>
<li>流：流是一串连续不断的数据集合，可以一段一段的写入长的数据流，读取数据流的时候是不知道流的分段 情况的，只能从前往后读取数据流</li>
<li>比特：是二进制的最小单位，0或者1</li>
<li>字节：是计算机操作数据的最小单位，8位bit，（-128~</li>
<li>字符：用户可读写的最小单位，16位bit，（0~65535） </li>
</ul>
</li>
<li><p>什么是IO，包含哪几种流 </p>
<blockquote>
<p>它是指计算机与外部世界或者一个程序与计算机的其余部分的之间的接口。它对于任何计算机系统都非常关键，因而所有 I/O 的主体实际上是内置在操作系统中的。单独的程序一般是让系统为它们完成大部分的工作。 在 Java 编程中，直到最近一直使用 流 的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象 </p>
</blockquote>
<p>字节流，字符流，输入流，输出流 </p>
</li>
<li><p>什么是字节流和字符流，区别，之间如何转换 </p>
<ul>
<li><p>字节流：操作的是byte类型的数据，直接对文件本身进行操作，主要操作类是<code>OutputStream</code>、<code>InputStream</code>的子类</p>
</li>
<li><p>字符流：操作的是字符类型的数据，使用<strong>缓冲区</strong>缓冲字符，不关闭流就不会输出任何内容，主要操作类是 Reader、Writer的子类</p>
</li>
</ul>
</li>
<li><p>什么是输入流和输出流</p>
<ul>
<li>输入流：把数据写入存储介质的操作</li>
<li>输出流：从存储介质中读取数据的操作</li>
</ul>
</li>
</ol>
<h1 id="NIO-BIO-AIO"><a href="#NIO-BIO-AIO" class="headerlink" title="NIO,BIO,AIO"></a>NIO,BIO,AIO</h1><ol>
<li><p>什么是<code>NIO</code></p>
<p>NIO与IO的作用和目的是相同的，都是计算机与外部世界或者一个程序与计算机的其余部分的之间的接口，只<br>不过，IO是以流的方式处理数据，而NIO是以块的方式处理数据<br>IO：流式数据创建过滤器很容易，面向流的IO慢<br>NIO：按照块处理比按照流处理的快，但是缺少优雅性和简单性 </p>
</li>
<li><p>什么是<code>AIO</code></p>
<p>Java AIO即Async非阻塞，是异步非阻塞的IO。 </p>
</li>
<li><p>什么是<code>BIO</code></p>
<p>Java BIO即Block I/O ， 同步并阻塞的IO。</p>
</li>
</ol>
<ol start="4">
<li><p>NIO,BIO,AIO之间的区别与联系 </p>
<p>BIO：同步阻塞IO模式，必须等待这件事情做完了才去做下一件事情<br>AIO：异步非阻塞IO模式，不用等待这件事情做完了才去做下一件事，这件事情做完了就会自动告诉我他做完<br>了<br>NIO：同时支持阻塞与非阻塞模式 </p>
</li>
</ol>
<ol start="5">
<li><p>Java中BIO、NIO、AIO分别适用哪些场景 </p>
<p><code>BIO</code>：适用于连接数较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前<br>的唯一选择，但程序直观简单易理解</p>
<p><code>NIO</code>方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较<br>复杂，JDK1.4开始支持。</p>
<p><code>AIO</code>方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，<br>编程比较复杂，JDK7开始支持 </p>
</li>
<li><p>IO流需不需要关闭,如果关闭的话应该如何关闭。需要注意什么 </p>
<ul>
<li>IO流一定要关闭，不然会内存泄漏，进而导致内存溢出</li>
<li>一般在finally块中关闭，并且关闭流的操作可能会抛出异常，要对其进行捕获 </li>
</ul>
</li>
<li><p>什么是同步，什么是异步</p>
<p>A调用B<br>同步：A调用B后，B马上去执行，执行完成会告诉A，A本次调用会得到结果<br>异步：A调用B后，B并不会马上执行，但是一定会执行，执行完成会告诉A，A本次调用不会得到结 果</p>
</li>
<li><p>什么是阻塞？什么是非阻塞？ </p>
<p>A调用B</p>
<p>阻塞：A调用B之后一直等待B的结果，等不到就不做别的事情<br>非阻塞：A调用B之后就去做自己事情了，不需要等待B完成 </p>
</li>
<li><p>同步，异步 和 阻塞，非阻塞之间的区别？ </p>
<p>同步，异步，是描述被调用方的。 阻塞，非阻塞，是描述调用方的。 同步不一定阻塞，异步也不一定非阻塞。没有必然关系。 </p>
</li>
</ol>
<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><ol>
<li>IO模型有哪5种？ </li>
</ol>
<ul>
<li>阻塞式IO模型</li>
<li>非阻塞IO模型</li>
<li>IO复用模型</li>
<li>信号驱动IO模型</li>
<li>异步IO模型 </li>
</ul>
<ol start="2">
<li><p>阻塞IO</p>
<p>当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就<br>会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户<br>线程，用户线程才解除block状态。 </p>
</li>
<li><p>非阻塞IO</p>
<p>当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它<br>就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了<br>用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。 </p>
</li>
<li><p>什么是多路复用IO模型 </p>
<blockquote>
<p>不断去轮询多个<code>socket</code>的状态，只有当<code>socket</code>真正有读写事件时，才真正调用实际的IO读写操作。<br>多路复用IO比较适合连接数比较多的情况。<br>多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。 </p>
</blockquote>
</li>
<li><p>什么是信号驱动IO模型 </p>
<p>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线<br>程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中<br>调用IO读写操作来进行实际的IO请求操作。</p>
</li>
<li><p>什么是异步IO模型 </p>
<p>当进程发起一个 IO 操作，进程返回（不阻塞），但也不能返回结果；内核 把整个 IO 处理完后，会通知进程<br>结果。如果 IO 操作成功则进程直接获取到数据。 </p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/14/单例模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/单例模式/" itemprop="url">单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T20:11:15+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近感觉设计模式这一块好久都没有看了，觉得有必要补补，正好碰见H大知识星球里面有专门的学习资料，就打算跟着学习一下，并用博客的方式来记录学习过程。</p>
<p>这篇博客主要看下单例模式。</p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li><p>什么是单例模式？</p>
<p>通俗来说，就是单个实例。单例模式是最简单的设计模式之一，属于创建型模式。</p>
<p>GOF书中说：保证每个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<blockquote>
<p>也就是说，一个实例，并且还要提供访问该实例的方式</p>
</blockquote>
<p>单例模式体现在类声明中，单例的类负责创建自己的对象，同时确保只有单个对象被创建；</p>
<p>并且这个类提供了一种访问其唯一对象的方式，可以直接访问，不需要实例化该类的对象</p>
</li>
<li><p>单例的优点？</p>
<ul>
<li><p>节省维护对象的开销：创建、内存占用、回收</p>
</li>
<li><p>实例状态易于维护，一般单例不维护状态，当多个线程就行更改状态时，会产生并发问题</p>
</li>
</ul>
</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在学习单例模式的实现之前，我们需要有一个认识，对象可以通过构造器创建出来，如果谁都能使用这个构造器，那就无法实现单例。因此我们需要将构造器方法设置为<code>private</code>,不给别人new的机会。</p>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxsq.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: ajin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">//   饿汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance=<span class="keyword">new</span> Singleton();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试是否是单例模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton1=Singleton.getInstance();</span><br><span class="line">        Singleton singleton2=Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton1==singleton2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出：<code>true</code></p>
<blockquote>
<p>对于饿汉式来说，就是想要拿到这个实例的时候就能立即拿到，而不需要等待时间。</p>
<p>所以，通过static的静态初始化方式，在该类第一次被加载的时候，就有一个Singleton1<br>的实例被创建出来了。这样就保证在第一次想要使用该对象时，它已经被初始化好了 </p>
</blockquote>
<p>饿汉式单例，在类被加载的时候对象就会实例化。这也许会造成不必要的消耗，因为<br>有可能这个实例根本就不会被用到。而且，如果这个类被多次加载的话也会造成多次实例<br>化 </p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类就是把创建单例对象放在了静态内部类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxsq.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类实现单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassSingeton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InnerClassSingeton instance=<span class="keyword">new</span> InnerClassSingeton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InnerClassSingeton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  InnerClassSingeton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInner.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxsq.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程不安全的懒汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUnSafeSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadUnSafeSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadUnSafeSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> ThreadUnSafeSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance=<span class="keyword">new</span> ThreadUnSafeSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种懒汉式线程不安全，如果多个线程同时访问<code>getInstance()</code>会导致创建多个不同的对象。</p>
<p>而饿汉式就不会有这种情况，因为单例对象早就创建好了，所以多线程情况下，不会创建多个对象。</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>为了能够线程安全，我们只需要<code>synchronized</code>加锁即可，实现原子性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxsq.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程安全的懒汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeSigleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ThreadSafeSigleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadSafeSigleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadUnSafeSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ThreadSafeSigleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> ThreadSafeSigleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/14/MyBatis插件介绍/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/MyBatis插件介绍/" itemprop="url">MyBatis插件介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T15:50:47+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>其实MyBatis插件开发，就是在SQL语句执行过程中的某一点进行拦截。</p>
<p>MyBatis允许使用插件来拦截的接口和方法如下所示：（这些可以被拦截)</p>
<ul>
<li>Executor ( update 、 query 、 flushStatements 、 commit 、 rollback 、<br>getTransaction 、 close 、 isClosed)</li>
<li>ParameterHandler ( getParameterObj ect 、 setParameters)</li>
<li>Resul tSetHandler ( handleResul tSets 、 handleCursorResultSe ts 、<br>handleOutputParameters)</li>
<li>StatementHandler (prepare 、 parameterize 、 batch 、 update 、 query) </li>
</ul>
<h1 id="拦截器接口介绍"><a href="#拦截器接口介绍" class="headerlink" title="拦截器接口介绍"></a>拦截器接口介绍</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 用来传递插件的参数，可以通过参数来改变插件的行为</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="setProperties"><a href="#setProperties" class="headerlink" title="setProperties()"></a>setProperties()</h2><p>我们在mybatis-config.xml文件中作如下的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--声明一个插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">”</span> <span class="attr">tk.mybatis.simple.plugin</span> <span class="attr">.</span> <span class="attr">XXXInterceptor</span> " &gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">property</span> <span class="attr">name</span> ＝ ” <span class="attr">propl</span> ” <span class="attr">value</span> ＝” <span class="attr">value</span> <span class="attr">l</span> ”/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> ＝ ” <span class="attr">prop2</span> ” <span class="attr">value</span> ＝” <span class="attr">value2</span>“/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里面的property标签定义了拦截器的参数，这两个参数可以通过<code>setProperties()</code>传递给我们的拦截器</p>
</blockquote>
<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin()"></a>plugin()</h2><p><code>Object plugin(Object target);</code></p>
<p><code>target</code>:拦截器要拦截的对象</p>
<blockquote>
<p>该方法会在创建被拦截的接口实现类时调用</p>
</blockquote>
<p>该方法的实现很简单 ，只需要调用 MyBatis 提供的<br><code>Plugin (org . apache. ibatis. plugin. Plugin ）</code>类的 <code>wrap</code> 静态方法就可以通过 Java 的<br>动态代理拦截目标对象。这个接口方法通常的实现代码如下 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Plugin.wrap(target , <span class="keyword">this</span>) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>wrap</code>方法会自动判断<strong>拦截器的签名和被拦截对象的接口</strong>是否匹配，只有匹配的<br>情况下才会使用动态代理拦截目标对象，因此在上面的实现方法中不必做额外的逻辑判断 。 </p>
<h2 id="intercept"><a href="#intercept" class="headerlink" title="intercept()"></a>intercept()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"> <span class="comment">// 获取当前被拦截的对象</span></span><br><span class="line">Object target ＝invocation.getTarget ();</span><br><span class="line"> <span class="comment">// 获取当前被拦截的方法</span></span><br><span class="line">Method method = invocation.getMethod() ;</span><br><span class="line"> <span class="comment">// 获取被拦截方法的参数</span></span><br><span class="line">Object[] args = invocation.getArgs() ;</span><br><span class="line"> <span class="comment">// 返回执行的结果</span></span><br><span class="line">Object result ＝invocation .proceed ();</span><br><span class="line"><span class="keyword">return</span> result </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="拦截器签名介绍"><a href="#拦截器签名介绍" class="headerlink" title="拦截器签名介绍"></a>拦截器签名介绍</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@Signature</span> (</span><br><span class="line">type = ResultSetHandler.class ,</span><br><span class="line">method = ” handleResultSets ”,</span><br><span class="line">args = &#123;Statement. <span class="class"><span class="keyword">class</span>&#125;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>type</code>    设置拦截的接口</p>
</li>
<li><p><code>method</code>  设置拦截接口的方法</p>
</li>
<li><p><code>args</code> 设置拦截方法的参数类型数组，通过方法名和参数类型可以确定唯一一个方法</p>
</li>
</ul>
<p>在我的项目当中是这样定义的拦截器签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123; <span class="meta">@Signature</span>(type = Executor.class, method = <span class="string">"update"</span>, args = &#123; MappedStatement.class, Object.class &#125;),</span><br><span class="line">		<span class="meta">@Signature</span>(type = Executor.class, method = <span class="string">"query"</span>, args = &#123; MappedStatement.class, Object.class,</span><br><span class="line">				RowBounds.class, ResultHandler.class &#125;) &#125;)</span><br></pre></td></tr></table></figure>
<p>我需要对<code>Executor</code>接口进行拦截，先拦截其update方法，再拦截器query方法，被拦截方法中的参数根据update和query方法来决定。</p>
<p>这是Executor接口中的两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line"> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure>
<p>我的理解是<code>MapppedStatement</code>对象对应的是我们XXXmapper.xml文件中<code>&lt;select&gt;&lt;/select&gt;</code>标签对象，Executor是一个执行器，负责通过动态代理来执行<code>MappedStatement</code>。</p>
<blockquote>
<p>我们就是要拦截这个执行器，让SQL语句在执行之前动态地选择数据源，也就是查询语句走从库，增删改语句走主库。</p>
</blockquote>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>我的项目需要对sql语句进行拦截，使得其动态地选择数据源；所以我就拦截了Executor接口，并编写了动态选择数据源的逻辑。这样就体现了主从同步的作用，从库用来读，主库负责写。</p>
<p>核心的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取BoundSql（Sql语句对象）</span></span><br><span class="line">BoundSql boundSql = ms.getSqlSource().getBoundSql(objects[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// 获取SQL语句</span></span><br><span class="line">String sql = boundSql.getSql().toLowerCase(Locale.CHINA).replaceAll(<span class="string">"[\\t\\n\\r]"</span>, <span class="string">" "</span>);</span><br><span class="line"><span class="keyword">if</span> (sql.matches(REGEX)) &#123;</span><br><span class="line">                   <span class="comment">// 设置访问主库</span></span><br><span class="line">	lookupKey = DynamicDataSourceHolder.DB_MASTER;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 设置访问从库</span></span><br><span class="line">	lookupKey = DynamicDataSourceHolder.DB_SLAVE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/14/揭秘-SpringBootApplication/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/揭秘-SpringBootApplication/" itemprop="url">揭秘@SpringBootApplication</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T13:48:09+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Boot/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Boot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于SpringBoot，我们项目中能看到的影子应该就是它的启动类了，启动类添加了一个注解<code>@SpringBootApplication</code>，究竟这个注解有什么用意，今天就来看下它的真面目。</p>
<h1 id="揭秘"><a href="#揭秘" class="headerlink" title="揭秘"></a>揭秘</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM,</span><br><span class="line">				classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure>
<p>从上面可知<code>@SpringBootApplication</code>注解包含了三个子注解：<code>@SpringBootConfiguration</code>，<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>。</p>
<p>比较陌生的是<code>@SpringBootConfiguration</code>，我们再点进去看一下它的庐山真面目：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来它是<code>@Configuraion</code>伪装的，这样不就很熟悉了嘛。</p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = Component.class)</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Configuration其实就是以JavaConfig的形式装配bean。同时Spring Boot当中消灭了xml的配置，我们如果需要配置一些信息，只需要以JavaConfig的形式进行配置就好了，这样bean就加载进IoC容器了</p>
<h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="ComponentScan"></a>ComponentScan</h2><p>这个配置可以让我们在类上添加@Service，@Controller等注解的同时，无需配置任何信息，IoC容器就可以识别到这些注解的bean。</p>
<h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><p>这个注解是非常核心的，从名称来看，就是可以实现自动配置，这个就和“约定优于配置”理念契合了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>可以看到该注解就是借助于<code>AutoConfigurationImportSelector</code>类来实现自动配置，也就是将所有符合自动配置条件的bean加载进IoC容器。<br>有了<code>AutoConfigurationImportSelector</code>，<code>@EnableAutoConfiguation</code>就可以帮助Spring Boot应用将所有符合条件的<code>@Configuration</code>配置都加载到当前Spring Boot创建并使用的IoC容器中。</p>
<h3 id="SpringFactoriesLoader"><a href="#SpringFactoriesLoader" class="headerlink" title="SpringFactoriesLoader"></a>SpringFactoriesLoader</h3><p>当然它需要借助于<code>SpringFactoriesLoader</code>工具类来实现自动配置。而<code>SpringFactoriesLoader</code>这个类就是将classpath:META-INF/spring.factories中的信息取出来为我所用。</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture321.png" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所 以 ，<code>@EnableAutoConfiguration</code>自 动 配 置 的原理如下 ： 从  classpath 中搜寻所有 META-INF/spring.factories 配置文件，并将其中 org.spring-framework.boot.autoconfigure.EnableAutoConfiguration 对 应 的 配 置 项 通 过 反 射 实 例 化 为 对 应 的 标 注<code>@Configuration</code>的JavaConfig形 式 的<br>IoC容器配置类，然后汇总为一个并加载到IoC容器。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/14/Spring-Boot启动流程分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/Spring-Boot启动流程分析/" itemprop="url">Spring Boot启动流程分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T12:01:14+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Boot/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Boot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring Boot简化了我们的开发，省去了Spring中大量的配置工作，有一个概念叫“约定优于配置”，咱们这篇博客不会分析这个，在后续博客会更新自动配置的内容，也就是<code>@SpringBootApplication</code>的分析。</p>
<p>今天主要看一下Spring Boot项目的启动类，了解下Spring Boot项目的启动流程。</p>
<h1 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h1><p><code>SpringApplication</code> 是 Spring Boot 引导启动类，与 Spring 上下⽂、事件、监听器以及环境等组件<br>关系紧密，其中提供了控制 Spring Boot 应⽤特征的⾏为⽅法。</p>
<blockquote>
<p>上面这段话，在<code>SpringApplication#run()</code>方法中，我们会得到最直观的理解。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(SpringBootDemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>准确来说，就是run方法完成了Spring Boot的启动，其实我们的引导启动还可以换一种方式来写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication springApplication=<span class="keyword">new</span> SpringApplication(SpringBootDemoApplication.class);</span><br><span class="line">		<span class="comment">// 不设置web环境</span></span><br><span class="line">		springApplication.setWebEnvironment(<span class="keyword">false</span>);</span><br><span class="line">		springApplication.run(args);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以通过setXX做一些属性的自定义设置，比如设置banner或者web环境等等，然后再去启动。</p>
</blockquote>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>我们不得去看一下构造函数部分，因为SpringApplication.run(args)方法实则是new SpringApplication()对象之后再调用的run()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SpringApplication.run(SpringapplicationdemoApplication.class, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt; primarySource,</span></span></span><br><span class="line"><span class="function"><span class="params">			String... args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> run(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources,</span></span></span><br><span class="line"><span class="function"><span class="params">			String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>最终构造方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">		Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    	<span class="comment">// 1. 判断应用的类型</span></span><br><span class="line">		<span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    	<span class="comment">// 2. 使用 SpringFactoriesLoader查找并加载</span></span><br><span class="line">		<span class="comment">// classpath下 META-INF/spring.factories文件中所有可用的		   ApplicationContextInitializer</span></span><br><span class="line">		setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">				ApplicationContextInitializer.class));</span><br><span class="line">    	<span class="comment">//3.使用 SpringFactoriesLoader查找并加载</span></span><br><span class="line">		<span class="comment">// classpath下 META-INF/spring.factories文件中的所有可用的 ApplicationListener</span></span><br><span class="line">		setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">		<span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>判断应用的类型    <strong>REACTIVE/NONE/SERVLET</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> WebApplicationType <span class="title">deduceFromClasspath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="keyword">null</span>)</span><br><span class="line">				&amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="keyword">null</span>)</span><br><span class="line">				&amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="keyword">null</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> WebApplicationType.REACTIVE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="keyword">null</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> WebApplicationType.NONE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> WebApplicationType.SERVLET;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>WebApplicationType其实就是一个保存应用类型的枚举</p>
</blockquote>
</li>
<li><p>获取<code>ApplicationContextInitializer</code></p>
<p><code>ApplicationContextInitializer</code>用于在<code>ConfigurableApplicationContext</code>进行refresh之前的初始化工作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextInitializer</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">ConfigurableApplicationContext</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Initialize the given application context.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> applicationContext the application to configure</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(C applicationContext)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>获取<code>ApplicationListener</code></p>
<blockquote>
<p>这部分需要展开</p>
</blockquote>
<p>Spring的<strong>事件监听器</strong>模式，简单概括为：在Spring上下文对象启动前，添加事件监听器，然后Spring上下文正式启动后，就可以监听属于自己监听范围的事件</p>
<ol>
<li><p>Java中的事件对象是EventObject，而Spring中的事件对象是ApplicationEvent，是继承自EventObject的抽象类</p>
<p><img src="http://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture1.png" alt=""></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationEvent</span> <span class="keyword">extends</span> <span class="title">EventObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** use serialVersionUID from Spring 1.2 for interoperability */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7099057708183571937L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** System time when the event happened */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestamp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new ApplicationEvent.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> source the object on which the event initially occurred (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ApplicationEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(source);</span><br><span class="line">		<span class="keyword">this</span>.timestamp = System.currentTimeMillis();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the system time in milliseconds when the event happened.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.timestamp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以自定义一个Spring的事件对象，继承自抽象类ApplicationEvent，并自定义事件对象的周期</p>
</blockquote>
<ol start="2">
<li>AnnotationConfigApplicationContext上下文对象</li>
</ol>
</li>
</ol>
<p>   <img src="http://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture2.png" alt=""></p>
<ol start="3">
<li><p>ApplicationListener是默认的监听器对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Handle an application event.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> event the event to respond to</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E event)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样地，我们不但可以自定义事件对象，也可以自定义监听器对象</p>
</blockquote>
<p>完整的事件/监听器模式的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringEventListenerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 1.增加监听器</span></span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> MyApplicationListener());</span><br><span class="line">        <span class="comment">// context.register(MyApplicationListener.class);</span></span><br><span class="line">        <span class="comment">// 2.上下文的启动</span></span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="comment">// 3.发布事件（上下文启动后才可以发布事件）</span></span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> MyApplicationEvent(<span class="string">"Hello,World"</span>));</span><br><span class="line">        <span class="comment">// 发布事件后，监听器会自动监听到事件</span></span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> MyApplicationEvent(<span class="string">"Hello,World"</span>));</span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> MyApplicationEvent(<span class="string">"Hello,World"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义一个事件监听器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Handle an application event.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> event the event to respond to</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyApplicationEvent event)</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"MyApplicationListener receieves event: %s\n"</span>, event.getSource());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义一个事件对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyApplicationEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(source);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>事件 ，事件的监听器，上下文对象，这三者需要区分清楚</p>
</blockquote>
<h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p>创建了SpringApplication后，我们来看run方法。</p>
<p><code>run</code>方法是SpringApplication类的核心。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">		StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">		stopWatch.start();</span><br><span class="line">		ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">		Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		configureHeadlessProperty();</span><br><span class="line">         <span class="comment">// 1.获取并创建SpringApplicationRunListeners</span></span><br><span class="line">		SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">         <span class="comment">// 2.启动SpringApplicationRunListeners中所有的监听器</span></span><br><span class="line">		listeners.starting();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">					args);</span><br><span class="line">            <span class="comment">// 3.创建参数，并配置Environment</span></span><br><span class="line">			ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">					applicationArguments);</span><br><span class="line">			configureIgnoreBeanInfo(environment);</span><br><span class="line">            <span class="comment">// 4.设置banner，也就是我们启动的时候，控制台打印的图片</span></span><br><span class="line">			Banner printedBanner = printBanner(environment);</span><br><span class="line">            <span class="comment">// 5.创建上下文对象，一般是两种，web和非web</span></span><br><span class="line">			context = createApplicationContext();</span><br><span class="line">			exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">					SpringBootExceptionReporter.class,</span><br><span class="line">					<span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">            <span class="comment">//  6.初始化context，设置environment给它，以及加载其他配置信息</span></span><br><span class="line">			prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">					printedBanner);</span><br><span class="line">            <span class="comment">// 7.启动上下文</span></span><br><span class="line">			refreshContext(context);</span><br><span class="line">            <span class="comment">// 8.启动完成后，可以做一些事情（这是个模板方法）</span></span><br><span class="line">			afterRefresh(context, applicationArguments);</span><br><span class="line">			stopWatch.stop();</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">				<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">						.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">			&#125;</span><br><span class="line">			listeners.started(context);</span><br><span class="line">			callRunners(context, applicationArguments);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			listeners.running(context);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> context;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>主要流程如下所示：</p>
<ol>
<li>通过 <code>SpringFactoriesLoader</code> 加载 <code>META-INF/spring.factories</code> 文件，获取并创建 <code>SpringApplicationRunListener</code> 对象</li>
<li>然后由 <code>SpringApplicationRunListener</code> 来发出 starting 消息</li>
<li>创建参数，并配置当前 SpringBoot 应用将要使用的 Environment</li>
<li>完成之后，依然由 <code>SpringApplicationRunListener</code> 来发出 environmentPrepared 消息</li>
<li>创建 <code>ApplicationContext</code></li>
<li>初始化 <code>ApplicationContext</code>，并设置 Environment，加载相关配置等</li>
<li>由 <code>SpringApplicationRunListener</code> 来发出 <code>contextPrepared</code> 消息，告知SpringBoot 应用使用的 <code>ApplicationContext</code> 已准备OK</li>
<li>将各种 beans 装载入 <code>ApplicationContext</code>，继续由 <code>SpringApplicationRunListener</code> 来发出 contextLoaded 消息，告知 SpringBoot 应用使用的 <code>ApplicationContext</code> 已装填OK</li>
<li>refresh ApplicationContext，完成IoC容器可用的最后一步</li>
<li>由 <code>SpringApplicationRunListener</code> 来发出 started 消息</li>
<li>完成最终的程序的启动</li>
<li>由 <code>SpringApplicationRunListener</code> 来发出 running 消息，告知程序已运行起来了</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>这里需要区分两个启动，上下文的启动和程序的启动，核心是上下文的启动，上下文启动后，还需要进行程序的启动。</p>
<p>程序启动代码如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callRunners</span><span class="params">(ApplicationContext context, ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">		List&lt;Object&gt; runners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</span><br><span class="line">		runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</span><br><span class="line">		AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line">		<span class="keyword">for</span> (Object runner : <span class="keyword">new</span> LinkedHashSet&lt;&gt;(runners)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (runner <span class="keyword">instanceof</span> ApplicationRunner) &#123;</span><br><span class="line">				callRunner((ApplicationRunner) runner, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (runner <span class="keyword">instanceof</span> CommandLineRunner) &#123;</span><br><span class="line">				callRunner((CommandLineRunner) runner, args);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主要有ApplicationRunner和CommmandLineRunner这两个</p>
</blockquote>
<p>根据类型判断，采取哪一个来调用callRunner方法完成启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Callback used to run the bean.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args incoming application arguments</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception on error</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Callback used to run the bean.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args incoming main method arguments</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception on error</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：这里的<code>SpringApplicationRunListener</code>对象主要是对<code>Environment</code>和<code>ApplicationContext</code>进行监听，并发布消息。</p>
<hr>
<p>参考文章：<a href="https://mp.weixin.qq.com/s/qbMMZdMsbIpG77diGVwWtg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qbMMZdMsbIpG77diGVwWtg</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/13/MySQL主从同步原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/13/MySQL主从同步原理/" itemprop="url">MySQL主从同步原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-13T13:27:54+08:00">
                2019-04-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当系统应用访问量大大增加的时候，单台服务器的性能出现瓶颈，数据库的读写效率就会大大降低，这时候就需要主从同步，也就是一个主库带着多个从库，主库主要负责写，并将数据同步到从库，而从库负责读，这样就缓解了数据库的读写压力。并且，当主库宕机的时候，会自动切换一个旧的从库，将其升级成新的主库。</p>
<p>那么我们就来看看数据库主从同步的原理</p>
<h1 id="主从同步简介"><a href="#主从同步简介" class="headerlink" title="主从同步简介"></a>主从同步简介</h1><p>主从同步，对于主库与从库的配置，可以我们在服务器上进行配置。配置主要就是建立主库与从库的关系，核心就是主库赋予从库一个用户账号来从主库那里同步数据。</p>
<blockquote>
<p>我在设置同步账号的时候，由于从库的密码级别调得很高，导致同步出错。之前觉得MySQL的密码没必要设置得这么简单，但是后来发现，在企业级开发中，为了保证安全性，必须设置复杂的密码，并且最好不要使用root用户来连接数据库。并且3306端是人人皆知，我们可以修改成别的端口，以防止数据库被攻击。</p>
</blockquote>
<p>关于配置层面，就是应用程序层面动态选择主库还是从库，主库是写操作，从库是读操作。比如如果使用了MyBatis，就可以采用其自定义的插件来实现对SQL语句的拦截，实现读操作走从库，写操作访问主库。</p>
<blockquote>
<p>关于MyBatis的插件实现动态访问主库和从库，会在之后的学习中有涉及，并尽可能地输出到我的个人博客。</p>
</blockquote>
<h1 id="binlog简介"><a href="#binlog简介" class="headerlink" title="binlog简介"></a>binlog简介</h1><p>MySQL实现<strong>主从同步</strong>，离不开<code>binlog</code>。我们需要首先了解下<code>binlog</code>。</p>
<p>binlog日志用于记录所有更新了数据或者已经潜在更新了数据（例如，没有匹配任何行的一个DELETE）的所有语句。语句以“事件”的形式保存，它描述数据更改，它是以二进制的形式保存在磁盘中。我们可以通过mysql提供的查看工具<code>mysqlbinlog</code>文件中的内容，例如 mysqlbinlog mysql-bin.00001 | more，这里注意一下binlog文件的后缀名00001，binlog文件大小和个数会不断的增加，当MySQL停止或重启时，会产生一个新的binlog文件，后缀名会按序号递增，例如mysql-bin.00002、mysql-bin.00003，并且当binlog文件大小超过 max_binlog_size系统变量配置时也会产生新的binlog文件。</p>
<p>主库的<code>binlog</code>可以将主库的数据同步到从库，然后从库将这些数据写入到数据库当中，这样就实现了主从同步。</p>
<h2 id="binlog日志格式"><a href="#binlog日志格式" class="headerlink" title="binlog日志格式"></a>binlog日志格式</h2><p>（1） <code>statement</code> ： 记录每一条更改数据的sql;</p>
<ul>
<li>优点：binlog文件较小，节约I/O，性能较高。</li>
<li>缺点：不是所有的数据更改都会写入binlog文件中，尤其是使用MySQL中的一些特殊函数（如LOAD_FILE()、UUID()等）和一些不确定的语句操作，从而导致主从数据无法复制的问题。</li>
</ul>
<p>（2） <code>row</code>： 不记录sql，只记录<strong>每行数据的更改细节</strong></p>
<ul>
<li>优点：详细的记录了每一行数据的更改细节，这也意味着不会由于使用一些特殊函数或其他情况导致不能复制的问题。</li>
<li>缺点：由于row格式记录了每一行数据的更改细节，会产生大量的binlog日志内容，性能不佳，并且会增大主从同步延迟出现的几率。</li>
</ul>
<p>（3） <code>mixed</code>：一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。</p>
<blockquote>
<p>从库的数据库版本要不低于主库的版本，是为了让从库接收到主库的binlog后，能够正确执行。</p>
</blockquote>
<h1 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h1><p>mysql主从复制需要三个线程，master（binlog dump thread）、slave（I/O thread 、SQL thread）。</p>
<p><strong>master</strong></p>
<p>（1）<code>binlog dump</code>线程：当主库中有数据更新时，那么主库就会根据按照设置的binlog格式，将此次更新的事件类型写入到主库的binlog文件中，此时主库会创建log dump线程通知slave有数据更新，当I/O线程请求日志内容时，会将此时的binlog名称和当前更新的位置同时传给slave的I/O线程。</p>
<p><strong>slave</strong></p>
<p>（2）<code>I/O</code>线程：该线程会连接到master，向log dump线程请求一份指定binlog文件位置的副本，并将请求回来的binlog存到本地的relay log中，relay log和binlog日志一样也是记录了数据更新的事件，它也是按照递增后缀名的方式，产生多个relay log（ host_name-relay-bin.000001）文件，slave会使用一个index文件（ host_name-relay-bin.index）来追踪当前正在使用的relay log文件。</p>
<p>（3）<code>SQL</code>线程：该线程检测到relay log有更新后，会读取并在本地做redo操作，将发生在主库的事件在本地重新执行一遍，来保证主从数据同步。此外，如果一个relay log文件中的全部事件都执行完毕，那么SQL线程会自动将该relay log 文件删除掉。</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/linkedkeeper0_b3fa3bae-e0f3-4a9b-b16f-4e4da63362b9.jpg" alt=""></p>
<p>这里面需要注意是从库开启了一个IO线程，将主库的binlog内容写入到Relay log中，然后SQL线程检测到Relay log的更新，就将数据同步到数据库中。</p>
<blockquote>
<p>为了性能考虑，不会直接将主库的binlog写给从库，而是通过Relay log先接受主库数据，然后再同步到从库中。</p>
</blockquote>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol>
<li><p>主从同步有延迟吗？</p>
<blockquote>
<p>有的，因为从库的同步比较消耗时间</p>
</blockquote>
</li>
<li><p>主从同步能完全缓解数据库的压力吗？</p>
<blockquote>
<p>不能，因为数据库还会承受一定的压力，高并发下性能还会下降，这时候可以通过消息队列进行削峰处理，限制PQS；也可以说采用Redis等缓存中间件来缓解从库的读请求压力；另外还可以进行分库分表，将数据库的大表拆分成小表，然后分摊到每个小表的请求就会很少，这样，数据库的压力也就减小了</p>
</blockquote>
</li>
<li><p>你们的数据库服务器有没有采用主从同步？</p>
<blockquote>
<p>我们的系统，是一主一从，主库主要负责写入数据，从库负责同步主库写入的数据并且接收后台管理系统（运营）和用户的读请求；另外，我们采用了缓存ehcache，缓解了数据库从库的压力；特别地，对于一些冷数据，我们提前从从库中读取出来，作为一个js静态文件写入到云服务器的磁盘中，然后用户访问前台页面的时候，就直接从js文件中获取。这样做的话，缓解了缓存服务器的压力，并且可以更迅速的获取数据，加快了前台页面的响应速度。</p>
</blockquote>
</li>
</ol>
<p><strong>一点思考</strong></p>
<p>主从同步的架构下，主库与从库的延迟是客观存在的；这一点对于关系数据库是这样的，对Redis也同样适用，因为不是自己本机的数据，同步到另一台机器，这个同步就会产生延迟，我们能做的就是缩小延迟。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/12/数据结构基本总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/数据结构基本总结/" itemprop="url">数据结构基本总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-12T19:25:41+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>数据结构是计算机存储、组织数据的方式。数据结构是指相互直接存在一种或多种特殊关系的数据元素的集合。</p>
<blockquote>
<p>简单来说，就是组织数据的集合。</p>
</blockquote>
<h2 id="线性结构VS非线性结构"><a href="#线性结构VS非线性结构" class="headerlink" title="线性结构VS非线性结构"></a>线性结构VS非线性结构</h2><p><strong>线性结构是一个有序数据元素的集合</strong>。它应该满足下面的特征：</p>
<ul>
<li>集合中必存在唯一的一个“第一个元素”</li>
<li>集合中必存在唯一的一个“最后的元素”</li>
<li>除最后一元素之外，其它数据元素均有唯一的“后继”</li>
<li>除第一个元素之外，其它数据元素均有唯一的“前驱”</li>
</ul>
<p>常见的线性结构由栈，队列等</p>
<p><strong>非线性结构：其逻辑特征是一个节点元素可以有多个直接前驱或多个直接后继。</strong></p>
<p>符合条件的数据结构有图、树和其它</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一种线性结构</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种<strong>后进先出</strong>(LIFO)的线性表，是一种基于数组的存储结构。</p>
<ul>
<li>LIFO(Last In First Out)表示后进先出，后进来的元素第一个弹出栈空间。类似于自动餐托盘，最后放上去的托盘，往往先被拿出来使用。</li>
<li>仅允许在表的一端进行插入和移除元素。这一端被称为栈顶，相对地，把另一端称为栈底</li>
<li>向一个栈插入新元素称作进栈、入栈或压栈，这是将新元素放在栈顶元素上面，使之成为新的栈顶元素。</li>
<li>从一个栈删除元素又称为出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素</li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种先进先出（FIFO）受限的线性表。受限体现在于其允许在表的前端（front）进行删除操作，在表的末尾（rear）进行插入【优先队列这些排除在外】操作。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote>
<p>首先需要对数组的优缺点做一个介绍</p>
</blockquote>
<p><strong>优点</strong>：</p>
<ul>
<li>存储多个元素</li>
<li>访问比较便捷，数组元素[index]即可访问</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><p>数组的创建通常需要申请一段连续的内存空间，并且大小是固定的（大多数的编程语言数组都是固定的），所以在进行扩容的时候难以掌控。</p>
</li>
<li><p>一般情况下，申请一个更大的数组，会是之前数组的倍数，比如两倍。然后，再将原数组中的元素复制过去</p>
</li>
<li><p>插入数据越是靠前，其成本很高，因为需要进行大量元素的位移。</p>
</li>
</ul>
<blockquote>
<p>相对数组，链表亦可以存储多个元素，而且存储的元素在内容中不必是连续的空间；<br>在插入和删除数据时，时间复杂度可以达到O(1)。</p>
</blockquote>
<p><strong>但是链表查找元素还是需要从头开始遍历的</strong></p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture316.png" alt=""></p>
<p>链表是由一组节点组成的集合。每个节点都使用一个对象的引用指向它的后继</p>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p> 树的定义：</p>
<ul>
<li><p>树（Tree）：n(n &gt;= 0)个节点构成的有限集合。</p>
<ul>
<li><p>当<code>n = 0</code>时，称为空树；</p>
</li>
<li><p>对任意一棵空树<code>(n &gt; 0)</code>，它具备以下性质：</p>
<pre><code>树中有一个称为根(Root)的特殊节点，用`r(root)`表示；
</code></pre><p>  其余节点可分为<code>m(m &gt; 0)</code>个互不相交的有限集<code>T1,T2,…Tm</code>，其中每个集合本省又是一棵树，称为原来树的子树（SubTree）</p>
</li>
</ul>
</li>
</ul>
<p>注意：</p>
<p>​    子树之间<code>不可以相交</code>；</p>
<p>​    除了根节点外，每个节点有且仅有一个父节点；</p>
<p>​    一个<code>N</code>个节点的树有<code>N-1</code>条边。</p>
<p>树的术语：</p>
<ul>
<li><p>节点的度（Degree）：节点的子树个数。</p>
</li>
<li><p>树的度：树的所有节点中最大的度数（树的度通常为节点个数的N-1）。</p>
</li>
<li><p>叶节点（Leaf）：度为0的节点（也称叶子节点）。</p>
</li>
<li><p>父节点（Parent）：有子树的节点是其子树的父节点。</p>
</li>
<li><p>子节点（Child）：若A节点是B节点的父节点，则称B节点是A节点的子节点。</p>
</li>
<li><p>兄弟节点（Sibling）：具有同一个父节点的各节点彼此是兄弟节点。</p>
</li>
<li><p>路径和路径长度：从节点n1到nk的路径为一个节点序列n1,n2,n3,…,nk，ni是ni+1的父节点。路径所包含边的个数为路径长度。</p>
</li>
<li><p>节点的层次（Level）：规定根节点在第0层，它的子节点是第1层，子节点的子节点是第2层，以此类推。</p>
</li>
<li><p>树的深度（Depth）：树中所有节点中的最大层次是这棵树的深度（因为上面是从第0层开始，深度 = 第最大层数 + 1）</p>
</li>
</ul>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture317.png" alt=""></p>
<p>二叉树的定义：</p>
<ul>
<li><p>二叉树可以为空，也就是没有节点</p>
</li>
<li><p>二叉树若不为空，则它是由根节点和称为其左子树<code>TL</code>和右子树<code>RT</code>的两个不相交的二叉树组成</p>
</li>
<li><p>二叉树每个节点的子节点不允许超过<code>两个</code></p>
</li>
<li><p>二叉树的五种形态：</p>
<ul>
<li>空</li>
</ul>
<ul>
<li>只有根节点</li>
<li>只有左子树</li>
<li>只有右子树</li>
<li>左右子树均有</li>
</ul>
</li>
</ul>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture318.png" alt=""></p>
<p><strong>二叉查找树</strong></p>
<p><strong>二叉查找树</strong>，也称二叉搜索树或二叉排序树，是一种特殊的二叉树，相对值较<code>小</code>的值保存在<code>左</code>节点中，较<code>大</code>的值保存在<code>右</code>节点中。</p>
<p>二叉查找树特殊的结构使它能够快速的进行查找、插入和删除数据。</p>
<blockquote>
<p>留意下二叉查找树的三种遍历方式</p>
</blockquote>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture319.png" alt=""></p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p><strong>图</strong>由边的集合及顶点的集合组成。</p>
<p>我们来了解下图的相关术语：</p>
<ul>
<li><p>顶点：图中的一个节点。</p>
</li>
<li><p>边：表示顶点和顶点之间的连线。</p>
</li>
<li><p>相邻顶点：由一条边连接在一起的顶点称为相邻顶点。</p>
</li>
<li><p>度：一个顶点的度是相邻顶点的数量。比如<code>0</code>顶点和其它两个顶点相连，<code>0</code>顶点的度就是<code>2</code></p>
</li>
<li><p>路径：路径是顶点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1,v2...,vn</span><br></pre></td></tr></table></figure>
<p>的一个连续序列。</p>
</li>
<li><p>简单路径：简单路径要求不包含重复的顶点。</p>
</li>
<li><p>回路：第一个顶点和最后一个顶点相同的路径称为回路。</p>
</li>
<li><p>有向图和无向图</p>
</li>
<li><p>有向图表示图中的<code>边</code>是<code>有</code>方向的。</p>
</li>
<li><p>无向图表示图中的<code>边</code>是<code>无</code>方向的。</p>
</li>
<li><p>带权图和无权图</p>
</li>
<li><p>带权图表示图中的边<code>有权重</code>。</p>
</li>
<li><p>无权图表示图中的边<code>无权重</code>。</p>
</li>
</ul>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture320.png" alt=""></p>
<p>图可以用于现实中的很多系统建模，比如：</p>
<ul>
<li>对交通流量建模</li>
<li>顶点可以表示街道的十字路口, 边可以表示街道.</li>
<li>加权的边可以表示限速或者车道的数量或者街道的距离.</li>
<li>建模人员可以用这个系统来判定最佳路线以及最可能堵车的街道.</li>
</ul>
<hr>
<p>原文地址：<a href="https://github.com/reng99/blogs" target="_blank" rel="noopener">https://github.com/reng99/blogs</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/12/Spring事务处理机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/Spring事务处理机制/" itemprop="url">Spring事务处理机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-12T17:07:25+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="事务的介绍"><a href="#事务的介绍" class="headerlink" title="事务的介绍"></a>事务的介绍</h1><p>Spring默认的声明式事务，在遇到checked异常的情况下，还是会提交的，当遇到uncheckedException也就是<code>RuntimeException</code>体系中的异常，就会自动回滚事务，保证事务的原子性，完整性等特性。</p>
<p><strong>事务的四个特性</strong>：</p>
<ul>
<li>原子性             要么全部成功，要么全部回滚</li>
<li>一致性            转账用户之间金额总数在事务过程中不发生变化</li>
<li>隔离性         各个并发事务之间是独立的</li>
<li>持久性           事务提交后对数据库的改变要持久化到磁盘</li>
</ul>
<h1 id="Spring事务的属性和使用入口"><a href="#Spring事务的属性和使用入口" class="headerlink" title="Spring事务的属性和使用入口"></a>Spring事务的属性和使用入口</h1><h2 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h2><p>传播行为，隔离级别，事务超时，只读事务，回滚规则</p>
<blockquote>
<p>通常在使用Spring事务处理机制的时候，我们不会采用编程式事务，通常采用<strong>声明式事务</strong></p>
</blockquote>
<p><strong>传播行为</strong>：</p>
<p><code>Propagation propagation() default Propagation.REQUIRED;</code><br>事务默认的传播行为是<code>REQUIRED</code>，也就是方法中只存在一个事务，会有事务合并的一个过程<br>（支持当前事务，如果不存在则创建新事务。 类似于同名的EJB事务属性。 这是声明式事务的默认设置）</p>
<p><strong>隔离级别</strong>：</p>
<p><code>Isolation isolation() default Isolation.DEFAULT;</code><br>默认情况下，Spring采用的是连接的数据库的隔离级别</p>
<p><strong>事务超时</strong></p>
<p><code>int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;</code><br>默认情况下，事务超时的时间和连接的数据库保持一致</p>
<p><strong>只读事务</strong></p>
<p><code>boolean readOnly() default false;</code><br>默认情况下，事务不是只读的。<br>但是如果是一些查询，我们可以定义该事务为只读事务，这样数据库会对只读事务做一些优化</p>
<p><strong>回滚规则</strong></p>
<p><code>Class&lt;? extends Throwable&gt;[] rollbackFor() default {};</code><br> 抛出指定异常的时候，事务会回滚</p>
<p><code>String[] rollbackForClassName() default {};</code> <strong>不推荐使用</strong></p>
<blockquote>
<p>设置需要回滚的异常类（数组) </p>
</blockquote>
<p><code>Class&lt;? extends Throwable&gt;[] noRollbackFor() default {};</code><br><code>String[] noRollbackForClassName() default {};</code> <strong>不推荐使用</strong><br>设置不需要进行回滚的异常类</p>
<h2 id="使用入口"><a href="#使用入口" class="headerlink" title="使用入口"></a>使用入口</h2><p><strong><code>@Transactional</code></strong></p>
<ul>
<li>该注解只有应用到<code>public</code>方法才有效，</li>
<li>在Spring的默认事务处理机制中，只会将抛出<code>RuntimeException</code>的事务进行回滚</li>
</ul>
<h1 id="Spring事务管理接口"><a href="#Spring事务管理接口" class="headerlink" title="Spring事务管理接口"></a>Spring事务管理接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>; <span class="comment">// 获取事务的状态信息</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br></pre></td></tr></table></figure>
<p>Spring只是提供了事务管理的接口，具体的实现，交给持久化框架来实现</p>
<h1 id="Spring事务机制的验证"><a href="#Spring事务机制的验证" class="headerlink" title="Spring事务机制的验证"></a>Spring事务机制的验证</h1><p><strong>总结</strong></p>
<ul>
<li>Spring的声明式事务中，如果<strong>主动捕获异常</strong>，默认不会回滚事务，所以捕获异常的操作，我们最好放在controller层进行捕获异常</li>
<li>如果抛出的不是<code>RuntimeException</code>，事务也不会回滚</li>
</ul>
<p><strong>Spring事务对指定异常和rollBackOnly异常的处理</strong></p>
<ul>
<li><p>抛出<code>RuntimeException</code>,事务可以回滚</p>
</li>
<li><p>指定异常，事务可以回滚<br><code>@Transactional(rollbackFor={AExcetion.class})</code></p>
</li>
<li><p><code>RollbackOnly</code> 事务可以回滚</p>
</li>
</ul>
<blockquote>
<p><strong>当一个没有开启事务的方法去调用一个开启事务的方法，事务是否能够回滚？</strong></p>
</blockquote>
<p>  <strong>同一个类中</strong>，一个不标注事务的方法去调用标注了事务的方法，事务会失效，不会发生回滚</p>
<p>  <strong>在不同的类中</strong>，一个不标注事务的方法去调用标注了事务的方法，事务会发生回滚</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    实际使用事务的时候，一定要记得抛出<code>RuntimeException</code>，这样事务才可以回滚。我觉得，这是最稳健的做法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/12/JVM——垃圾回收/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/JVM——垃圾回收/" itemprop="url">JVM——垃圾回收</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-12T09:41:58+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h2><blockquote>
<p>垃圾回收主要回收的是堆内存空间中的对象。</p>
</blockquote>
<p>对象被判定为垃圾的标准：</p>
<ul>
<li>没有被其他对象和引用变量引用</li>
</ul>
<h3 id="判断对象为垃圾的算法："><a href="#判断对象为垃圾的算法：" class="headerlink" title="判断对象为垃圾的算法："></a>判断对象为垃圾的算法：</h3><ul>
<li>引用计数算法</li>
<li>可达性分析算法</li>
</ul>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><blockquote>
<p>判断对象的引用数量</p>
</blockquote>
<ul>
<li><p>通过判断对象的 引用数量来决定对象是否可以被回收</p>
</li>
<li><p>堆中的每一个对象实例都有一个计数器，被引用则+1，完成引用则-1</p>
<blockquote>
<p>比如某方法中声明了一个引用变量指向某对象实例，在方法执行结束后，该引用变量就会自动被回收，所以就完成了引用，则该对象实例的计数器-1</p>
</blockquote>
</li>
<li><p>任何引用计数为0的对象实例可以被当作垃圾收集</p>
</li>
</ul>
<p>优点：执行效率高，程序执行受影响比较小（简单粗暴）</p>
<p>缺点： 无法检测出循环引用的情况，导致内存泄漏</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><blockquote>
<p>通过判断对象的引用链是否可传达来决定对象是否可以被回收</p>
</blockquote>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture207.png" alt=""></p>
<p>可以作为GC Root的对象：</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture208.png" alt=""></p>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记-清除算法（Mark-and-Sweep）"><a href="#标记-清除算法（Mark-and-Sweep）" class="headerlink" title="标记-清除算法（Mark and Sweep）"></a>标记-清除算法（Mark and Sweep）</h4><p>标记：从根集合进行扫描，对存活的对象进行标记</p>
<p>清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture209.png" alt=""></p>
<p>缺点：碎片化</p>
<h4 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h4><blockquote>
<p>多用于新生代垃圾收集器</p>
</blockquote>
<ul>
<li>分为对象面和空闲面</li>
<li>对象在对象面上创建</li>
<li>存活的对象被从对象面复制到空闲面</li>
<li>将对象面所有对象内存清除</li>
</ul>
<blockquote>
<p>适用于对象存活率比较低的场景，不用考虑内存碎片等复杂情况；对象存活率比较高的情况下，复制操作很耗时</p>
</blockquote>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture210.png" alt=""></p>
<h4 id="标记-整理算法（Compacting"><a href="#标记-整理算法（Compacting" class="headerlink" title="标记-整理算法（Compacting)"></a>标记-整理算法（Compacting)</h4><blockquote>
<p>老年代，解决了内存碎片的问题，但是还是有一个按照内存地址排序的过程。</p>
</blockquote>
<ul>
<li>标记：从根集合去扫描，对存活的对象进行标记</li>
<li>清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收</li>
</ul>
<p> <img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture211.png" alt=""></p>
<p>优点：避免了内存的不连续性；</p>
<p>​        不用设置两块内存互换；（和复制算法相比）</p>
<p>​        适用于对象存活率较高的场景</p>
<h4 id="分代收集算法（Generational-Collector"><a href="#分代收集算法（Generational-Collector" class="headerlink" title="分代收集算法（Generational Collector)"></a>分代收集算法（Generational Collector)</h4><blockquote>
<p>对前几种垃圾回收算法的综合运用</p>
</blockquote>
<ul>
<li>垃圾回收算法的组合拳</li>
<li>按照对象生命周期的不同划分区域以采用不同的垃圾回收算法</li>
<li>目的：提高JVM的回收效率</li>
</ul>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture212.png" alt=""></p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture213.png" alt=""></p>
<p>年轻代对象存活率低，使用复制算法；</p>
<p>老年代对象存活率高，使用标记-整理算法</p>
<blockquote>
<p>分代收集算法GC的分类：</p>
</blockquote>
<ul>
<li><p>Minor GC </p>
<blockquote>
<p>年轻代：尽可能快速收集掉哪些生命周期短的对象</p>
</blockquote>
<ul>
<li><p>Eden 区 </p>
<p>对象刚被创建出来的时候，会被优先分配到Eden区；当然如果内存不够了，也会被分配到Surivor区，甚至被分配到老年代中 </p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>两个Survivor区</p>
<p>From区，To区</p>
<blockquote>
<p>这两个Survivor区，具体哪个区被分配为From区，哪个区被分配为To区也不是固定的，随着垃圾回收的进行而相互转换</p>
</blockquote>
<p>年轻代的目标是快速收集掉那些生命周期短的对象</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture214.png" alt=""></p>
</li>
</ul>
<ul>
<li>Full GC</li>
</ul>
<blockquote>
<p>对象如何晋升到老年代？</p>
</blockquote>
<ul>
<li>经历一定Minor次数还能存活的对象（对象每经历一次Minor GC，则对象年龄自动加一，达到一定的年龄，默认15岁，则被晋升为老年代</li>
</ul>
<ul>
<li><p>Survivor区中放不下的对象</p>
<p>我们从年轻代开始讲起，对象刚创建出来在Eden Space中分配，当Eden空间满了(没有足够的空间)，则进行一次Minor GC，每一次Minor GC结束后，Eden区就会被清空，Eden区中依然存活的对象，会被放到两个Survivor中的一个中，当Survivor中放不下了，就会将对象放到老年代中。</p>
</li>
</ul>
<ul>
<li><p>新生成的大对象（-XX:+PretenuerSizeThreshold可控制大对象的大小，达到了一定的Size后，对象自动被放入老</p>
<p>年代中）</p>
</li>
</ul>
<blockquote>
<p>以上三种情况都是可以用参数进行配置的</p>
</blockquote>
<p>常用的调优参数：</p>
<ul>
<li><p>-XX:SurvivorRatio：Eden和Survivor的比值，默认8：1</p>
</li>
<li><p>-XX:NewRatio：老年代与年轻代的内存大小比例 </p>
<p>新生代与老年代内存的总大小是由-Xms - Xmx来控制的</p>
</li>
<li><p>-XX:MaxTenuringThreshold：对象从年轻代晋升到老年代经历GC的最大次数</p>
</li>
</ul>
<p>老年代：存放生命周期较长的对象</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture215.png" alt=""></p>
<p>老年代采用标记-清理算法或者标记-整理算法来回收垃圾</p>
<ul>
<li><p>Full GC和Major GC</p>
<p>Full GC比Minor GC慢很多，但执行效率低</p>
<p>Full GC发生的频率要比Minor GC发生的频率要低很多（因为老年代保存的是生命周期比较长的对象）</p>
</li>
</ul>
<blockquote>
<p>触发Full GC的条件：</p>
</blockquote>
<ul>
<li><p>老年代空间不足（不要创建太大的对象）</p>
</li>
<li><p>永久代空间不足（针对JDK7以前的版本）</p>
<blockquote>
<p>JDK 8采用元空间来代替永久代空间，减少了Full GC的频率</p>
</blockquote>
</li>
<li><p>CMS GC 时出现的<code>promotion fail ，concurrent mode failure</code></p>
<blockquote>
<p><code>promotion fail</code>是指在Minor GC时，Survivor中放不下对象，就把对象放老年代了，老年代也放不下了，就会触发<code>Full GC</code></p>
<p><code>，concurrent mode failure</code>：老年代空间不足</p>
</blockquote>
</li>
<li><p>Minor GC晋升到老年代的平均大小大于老年代的剩余空间</p>
<blockquote>
<p>Minro GC晋升到老年代，会检查老年代的剩余空间，如果不足，就会触发Full GC</p>
</blockquote>
</li>
<li><p>程序调用System.gc()提示虚拟机去回收对象，但是具体由虚拟机判断回不回收</p>
</li>
<li><p>使用RMI来进行RPC或者管理你的JDK应用时，每小时执行一次Full GC</p>
</li>
</ul>
<h3 id="常见的垃圾收集器"><a href="#常见的垃圾收集器" class="headerlink" title="常见的垃圾收集器"></a>常见的垃圾收集器</h3><p>理论知识：</p>
<ol>
<li>Stop-the-World（除了GC线程外，其他线程都处于等待状态）</li>
</ol>
<ul>
<li>JVM由于要执行GC而停止了应用程序的执行</li>
<li>任何一种GC算法中都会发生</li>
<li>多数GC优化通过减少Stop-the-world发生的时间来提高程序性能</li>
</ul>
<ol start="2">
<li><p>Safepoint 安全点</p>
<ul>
<li>分析过程中对象引用关系不会发生变化的点</li>
<li>产生Safepoint的地方：方法调用；循环跳转；异常跳转</li>
<li>安全点数量得适中</li>
</ul>
<p>我理解为静态点，这样GC才可以找到一个稳定得点来执行</p>
</li>
</ol>
<h4 id="JVM的运行模式"><a href="#JVM的运行模式" class="headerlink" title="JVM的运行模式"></a>JVM的运行模式</h4><ul>
<li>Server 启动的JVM，是轻量级的JVM，进行了很多优化</li>
<li>Client  启动较快  </li>
</ul>
<h4 id="垃圾收集器之间的联系"><a href="#垃圾收集器之间的联系" class="headerlink" title="垃圾收集器之间的联系"></a>垃圾收集器之间的联系</h4><p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture216.png" alt=""></p>
<p>年轻代常见的垃圾回收器</p>
<ul>
<li><p>Serial 收集器（-XX:+UseSerialGC，复制算法） </p>
<ul>
<li><p>单线程收集，进行垃圾收集时，必须暂停所有工作线程</p>
</li>
<li><p>简单高效，Client模式下默认的年轻代收集器</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture217.png" alt=""></p>
</li>
</ul>
</li>
<li><p>ParNew收集器（-XX:+UseParNewGC，复制算法）</p>
<ul>
<li>多线程收集，其余的行为，特点和Serial收集器一样</li>
<li>单核执行效率不如Serial，在多核下执行具有优势</li>
</ul>
</li>
<li><p>Parallel Scavenge收集器（-XX:+UseParallelGC)  复制算法</p>
<p>系统吞吐量=CPU运行用户代码时间/（运行用户代码时间+垃圾收集时间）</p>
<ul>
<li>多线程。多核下执行具有优势，Server模式默认的年轻代收集器</li>
<li>比起关注用户线程停顿时间，更关注系统的吞吐量</li>
</ul>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture218.png" alt=""></p>
</li>
</ul>
<p>老年代常见的垃圾收集器</p>
<ul>
<li>Serial Old收集器（-XX:+UseSerialOldGC,标记整理算法）<ul>
<li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li>
<li>简单高效，Client模式下默认的老年代收集器</li>
</ul>
</li>
<li>Parallel Old收集器（-XX:+UserParallelOldGC,标记整理算法）<ul>
<li>多线程，吞吐量优先</li>
</ul>
</li>
</ul>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture219.png" alt=""></p>
<ul>
<li><p>CMS收集器（-XX:+UseConcMarkSweepGC，标记清除算法）</p>
<p>几乎做到垃圾收集线程与用户线程同时工作，缩短了stop the world的时间</p>
<ul>
<li>初始标记阶段：stop the world :smiley:</li>
<li>并发标记：并发追溯标记，程序不会停顿</li>
<li>并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象</li>
<li>重新标记：暂停虚拟机，扫描CMS堆中剩余的对象​ :smile:</li>
<li>并发清理：清理垃圾对象，程序不会卡顿</li>
<li>并发重置：重置CMS收集器的数据结构</li>
</ul>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture220.png" alt=""></p>
<blockquote>
<p>会产生内存碎片</p>
</blockquote>
</li>
<li><p>G1收集器（-XX:+UseG1GC，复制+标记-整理算法）<strong>同时用于老年代与新生代的垃圾收集器</strong></p>
<p>Garbage First的特点：</p>
<ul>
<li>并行与并发   减少 stop the world 的时间</li>
<li>分代收集     独立管理整个堆空间</li>
<li>空间整合 标记整理算法，不会产生碎片，因为由内存空间整合的过程</li>
<li>可预测的停顿          </li>
</ul>
</li>
</ul>
<ul>
<li><p>将整个Java堆内存划分成多个大小相等的Region</p>
</li>
<li><p>年轻代与老年代不再物理隔离 </p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture221.png" alt=""></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/12/JVM——Java内存模型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/JVM——Java内存模型/" itemprop="url">JVM——Java内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-12T09:06:42+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JVM内存结构-VS-Java内存模型-VSJava对象模型"><a href="#JVM内存结构-VS-Java内存模型-VSJava对象模型" class="headerlink" title="JVM内存结构 VS Java内存模型 VSJava对象模型"></a>JVM内存结构 VS Java内存模型 VSJava对象模型</h1><h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><p> 虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。</p>
<blockquote>
<p>白话来讲，就是JVM运行Java程序的时候产生的内存（该内存是由JVM进行管理的，比如垃圾回收就是对堆内存中的垃圾对象进行回收）</p>
</blockquote>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。JSR-133: Java Memory Model and Thread Specification中描述了，JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。</p>
<p>引用下H大的话：<br>简单总结下，Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。</p>
<p>详细内容，学习多线程与并发的时候再去深入</p>
<h2 id="Java对象模型"><a href="#Java对象模型" class="headerlink" title="Java对象模型"></a>Java对象模型</h2><p>Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。<br>Java对象模型其实就是Java对象在JVM中的表现形式。</p>
<p>具体内容，以后再深入</p>
<blockquote>
<p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了两部分信息，对象头以及元数据。对象头中有一些运行时数据，其中就包括和多线程相关的锁的信息。元数据其实维护的是指针，指向的是对象所属的类的<code>instanceKlass</code>。</p>
</blockquote>
<h1 id="Java内存模型的理解（JMM"><a href="#Java内存模型的理解（JMM" class="headerlink" title="Java内存模型的理解（JMM)"></a>Java内存模型的理解（JMM)</h1><p>并发编程，为了保证数据的安全，需要满足以下三个特性：</p>
<p><strong>原子性</strong>是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</p>
<p><strong>可见性</strong>是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p><strong>有序性</strong>即程序执行的顺序按照代码的先后顺序执行。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性：一个线程对<strong>共享变量</strong>值的修改，能够及时地被其他线程看到</p>
<p>共享变量：如果一个变量在多个线程的工作内存都存在副本，那么这个变量就是这几个线程的共享变量</p>
<p>Java内存模型：（JMM)<br>Java Memory Model，描述了Java程序中各种变量（<strong>线程共享变量</strong>）的访问规则，以及JVM中将变量存储到内存和从内存中读取出变量这样的底层细节</p>
<ul>
<li>所有的变量都存储在主内存中</li>
<li>每个线程都有自己独立的工作空间，里面保存该线程使用到的变量的副本（也就是说主内存中该变量的一份拷贝）</li>
</ul>
<p>我们跟着图再理解一下<br><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture315.png" alt="JMM"></p>
<p>​            其中主内存中有共享变量X</p>
<p><strong>两条规定</strong></p>
<ul>
<li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写</li>
<li>不同线程之间无法直接访问其他线程工作内存中的变量值，线程之间变量的传递需要通过主内存来完成</li>
</ul>
<blockquote>
<p>所以共享变量值的传递，就需要借助于主内存来完成。</p>
</blockquote>
<h3 id="共享变量可见性实现的原理"><a href="#共享变量可见性实现的原理" class="headerlink" title="共享变量可见性实现的原理"></a>共享变量可见性实现的原理</h3><p>线程1对共享变量的修改要想被线程2及时看到，需要经过如下的两个步骤：</p>
<ol>
<li>把工作内存1（线程1的工作空间）中更新过的共享变量刷新到主内存中</li>
<li>线程2把主内存中最新的共享变量值更新到工作内存2（线程2的工作空间）中</li>
</ol>
<p>这两个步骤任何一个步骤出现了差错，就无法实现共享变量的可见性</p>
<h2 id="synchronized实现可见性原理"><a href="#synchronized实现可见性原理" class="headerlink" title="synchronized实现可见性原理"></a>synchronized实现可见性原理</h2><p>Java语言层次方面支持的可见性实现方式：（不包含j.u.c包里面的一些实现方式）</p>
<ol>
<li>synchronized</li>
<li>volatile</li>
</ol>
<p>synchronized能够实现：</p>
<ul>
<li>原子性（同步）</li>
<li>可见性</li>
</ul>
<p><strong>JMM关于synchronized的两条规定</strong></p>
<ol>
<li>线程解锁前，必须将共享变量的最新值刷新到主内存中</li>
<li>线程加锁时，将清空工作空间中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（<strong>注意：加锁和解锁指的是同一把锁</strong>）</li>
</ol>
<blockquote>
<p>线程解锁前对共享变量的修改在下次加锁时对其他线程可见</p>
</blockquote>
<p>线程执行互斥代码的过程：</p>
<ol>
<li>获得互斥锁</li>
<li>清空自己的工作内存</li>
<li>从主内存拷贝变量的最新副本到工作内存</li>
<li>执行代码</li>
<li>将更改后的共享变量的值刷新到主内存</li>
<li>释放互斥锁</li>
</ol>
<blockquote>
<p>补充知识点</p>
</blockquote>
<p><strong>重排序</strong>：代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能所做的优化</p>
<ol>
<li>编译器优化的重排序（编译器优化）</li>
<li>指令级并行重排序（处理器优化）</li>
<li>内存系统的重排序（处理器优化）</li>
</ol>
<p>一个直观的认识：<br>代码顺序：                 执行顺序:<br>int number=1;               int result=0;<br>int result=0;                int number=1;</p>
<blockquote>
<p>执行顺序和代码书写顺序不一定一致</p>
</blockquote>
<p><strong>as-if-serial</strong></p>
<p>as-if-serial：无论如何重排序，程序执行的结果应该与代码书写顺序执行的结果一致<br>（Java编译器，运行时和处理器都会保证Java在<strong>单线程</strong>下遵循as-if-serial语义）</p>
<p>重排序不会给单线程带来内存可见性的问题</p>
<p>多线程中程序交错执行，重排序可能会造成内存可见性问题</p>
<p>导致共享变量在线程间不可见的原因：                    <strong>synchronized解决方案</strong></p>
<ol>
<li>线程的交叉执行                      —&gt; 原子性</li>
<li>重排序结合线程的交叉执行             —&gt; 原子性</li>
<li>共享变量更新后的值没有在工作空间与主内存之间及时更新   —&gt; 可见性</li>
</ol>
<p>总结：</p>
<ol>
<li>当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。</li>
<li>当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。</li>
<li>当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。</li>
</ol>
<h2 id="volatile实现可见性"><a href="#volatile实现可见性" class="headerlink" title="volatile实现可见性"></a>volatile实现可见性</h2><p><strong>volatile</strong>关键字:</p>
<ul>
<li>能够保证volatile变量的可见性</li>
<li>并不能保证volatile变量复合操作的原子性</li>
</ul>
<p><strong>volatile如何实现内存可见性</strong>：</p>
<p>深入来说，通过加入内存屏障和禁止重排序优化来实现的</p>
<ul>
<li>对volatile变量执行写操作的时候，会在写操作后面加入一条store屏障指令</li>
<li>对volatile变量执行读操作的时候，会在读操作之前加入一条load屏障指令</li>
</ul>
<blockquote>
<p>前面这两条可以保证缓冲区的内存失效，使得对volatile变量的修改能够获取到最新值；读的时候获取的是最新值</p>
</blockquote>
<p>通俗理解：<br>volatile变量在每次被线程访问的时候，都强迫从主内存<strong>重读</strong>该变量的值，而当该变量改变时，又会强迫线程将最新的值强制刷新到主内存中。这样任何时刻，不同的线程都能看到该变量的最新值</p>
<p><strong>线程写volatile变量的过程</strong></p>
<ol>
<li>改变线程工作内存中volatile变量<strong>副本</strong>的值</li>
<li>将改变后的副本的值从工作内存刷新到主内存中</li>
</ol>
<p><strong>线程读volatile变量的过程</strong></p>
<ol>
<li>从主内存中读取volatile变量的最新值到线程的工作空间</li>
<li>从工作内存中读取volatile变量的副本</li>
</ol>
<h3 id="volatile变量不能实现原子性"><a href="#volatile变量不能实现原子性" class="headerlink" title="volatile变量不能实现原子性"></a>volatile变量不能实现原子性</h3><blockquote>
<p>volatile不能保证volatile变量复合操作的原子性</p>
</blockquote>
<p><strong>原子性：一个或某几个操作只能在一个线程执行完之后，另一个线程才能开始执行该操作，也就是说这些操作是不可分割的，线程不能在这些操作上交替执行</strong></p>
<p>文中的 i++ 包括 3 个操作</p>
<p>读取 i 的值</p>
<p>i 的值 +1 </p>
<p>将 i 赋值给 i</p>
<p>在这 3 个操作中可能会有其他线程开始执行,因此不是原子性的</p>
<p>精辟深刻!!!</p>
<p><strong><code>i++</code>操作的原子性：</strong></p>
<ul>
<li>使用<code>synchronized</code>关键字</li>
<li>使用<code>ReentrantLock</code>(j.u.c.locks包下)</li>
<li>使用<code>AtomicInteger</code></li>
</ul>
<p><strong>volatile使用场合</strong></p>
<p>要在多线程中安全的使用volatile变量，必须同时满足：</p>
<ol>
<li>对变量的写入操作不依赖于当前值</li>
</ol>
<ul>
<li>不满足 i++ count=count*5</li>
<li>满足 boolean</li>
</ul>
<ol start="2">
<li>该变量没有包含在具有其他变量的不变式中</li>
</ol>
<h2 id="synchronized-VS-volatile"><a href="#synchronized-VS-volatile" class="headerlink" title="synchronized VS volatile"></a>synchronized VS volatile</h2><ul>
<li>volatile不需要加锁，比synchronized更轻量级，不会阻塞线程</li>
<li>从内存可见性角度，volatile读相当于加锁，volatile写相当于解锁</li>
<li>synchronized既能保证原子性也能保证可见性，而volatile只能保证可见性，不能保证原子性</li>
</ul>
<blockquote>
<p>共享数据的访问权限都必须定义为private</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘天霸</p>
              <p class="site-description motion-element" itemprop="description">Java学习记录博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘天霸</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
