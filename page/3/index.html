<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="时间旅行者" type="application/atom+xml">






<meta name="description" content="Java学习记录博客">
<meta property="og:type" content="website">
<meta property="og:title" content="时间旅行者">
<meta property="og:url" content="https://www.liutianruo.com/page/3/index.html">
<meta property="og:site_name" content="时间旅行者">
<meta property="og:description" content="Java学习记录博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="时间旅行者">
<meta name="twitter:description" content="Java学习记录博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.liutianruo.com/page/3/">





  <title>时间旅行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">时间旅行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-categories"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/14/揭秘-SpringBootApplication/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/揭秘-SpringBootApplication/" itemprop="url">揭秘@SpringBootApplication</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T13:48:09+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Boot/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Boot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于SpringBoot，我们项目中能看到的影子应该就是它的启动类了，启动类添加了一个注解<code>@SpringBootApplication</code>，究竟这个注解有什么用意，今天就来看下它的真面目。</p>
<h1 id="揭秘"><a href="#揭秘" class="headerlink" title="揭秘"></a>揭秘</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM,</span><br><span class="line">				classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure>
<p>从上面可知<code>@SpringBootApplication</code>注解包含了三个子注解：<code>@SpringBootConfiguration</code>，<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>。</p>
<p>比较陌生的是<code>@SpringBootConfiguration</code>，我们再点进去看一下它的庐山真面目：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来它是<code>@Configuraion</code>伪装的，这样不就很熟悉了嘛。</p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = Component.class)</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Configuration其实就是以JavaConfig的形式装配bean。同时Spring Boot当中消灭了xml的配置，我们如果需要配置一些信息，只需要以JavaConfig的形式进行配置就好了，这样bean就加载进IoC容器了</p>
<h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="ComponentScan"></a>ComponentScan</h2><p>这个配置可以让我们在类上添加@Service，@Controller等注解的同时，无需配置任何信息，IoC容器就可以识别到这些注解的bean。</p>
<h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><p>这个注解是非常核心的，从名称来看，就是可以实现自动配置，这个就和“约定优于配置”理念契合了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>可以看到该注解就是借助于<code>AutoConfigurationImportSelector</code>类来实现自动配置，也就是将所有符合自动配置条件的bean加载进IoC容器。<br>有了<code>AutoConfigurationImportSelector</code>，<code>@EnableAutoConfiguation</code>就可以帮助Spring Boot应用将所有符合条件的<code>@Configuration</code>配置都加载到当前Spring Boot创建并使用的IoC容器中。</p>
<h3 id="SpringFactoriesLoader"><a href="#SpringFactoriesLoader" class="headerlink" title="SpringFactoriesLoader"></a>SpringFactoriesLoader</h3><p>当然它需要借助于<code>SpringFactoriesLoader</code>工具类来实现自动配置。而<code>SpringFactoriesLoader</code>这个类就是将classpath:META-INF/spring.factories中的信息取出来为我所用。</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture321.png" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所 以 ，<code>@EnableAutoConfiguration</code>自 动 配 置 的原理如下 ： 从  classpath 中搜寻所有 META-INF/spring.factories 配置文件，并将其中 org.spring-framework.boot.autoconfigure.EnableAutoConfiguration 对 应 的 配 置 项 通 过 反 射 实 例 化 为 对 应 的 标 注<code>@Configuration</code>的JavaConfig形 式 的<br>IoC容器配置类，然后汇总为一个并加载到IoC容器。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/14/Spring-Boot启动流程分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/Spring-Boot启动流程分析/" itemprop="url">Spring Boot启动流程分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T12:01:14+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Boot/" itemprop="url" rel="index">
                    <span itemprop="name">Spring Boot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring Boot简化了我们的开发，省去了Spring中大量的配置工作，有一个概念叫“约定优于配置”，咱们这篇博客不会分析这个，在后续博客会更新自动配置的内容，也就是<code>@SpringBootApplication</code>的分析。</p>
<p>今天主要看一下Spring Boot项目的启动类，了解下Spring Boot项目的启动流程。</p>
<h1 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h1><p><code>SpringApplication</code> 是 Spring Boot 引导启动类，与 Spring 上下⽂、事件、监听器以及环境等组件<br>关系紧密，其中提供了控制 Spring Boot 应⽤特征的⾏为⽅法。</p>
<blockquote>
<p>上面这段话，在<code>SpringApplication#run()</code>方法中，我们会得到最直观的理解。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(SpringBootDemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>准确来说，就是run方法完成了Spring Boot的启动，其实我们的引导启动还可以换一种方式来写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication springApplication=<span class="keyword">new</span> SpringApplication(SpringBootDemoApplication.class);</span><br><span class="line">		<span class="comment">// 不设置web环境</span></span><br><span class="line">		springApplication.setWebEnvironment(<span class="keyword">false</span>);</span><br><span class="line">		springApplication.run(args);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以通过setXX做一些属性的自定义设置，比如设置banner或者web环境等等，然后再去启动。</p>
</blockquote>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>我们不得去看一下构造函数部分，因为SpringApplication.run(args)方法实则是new SpringApplication()对象之后再调用的run()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SpringApplication.run(SpringapplicationdemoApplication.class, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt; primarySource,</span></span></span><br><span class="line"><span class="function"><span class="params">			String... args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> run(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources,</span></span></span><br><span class="line"><span class="function"><span class="params">			String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>最终构造方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">		Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    	<span class="comment">// 1. 判断应用的类型</span></span><br><span class="line">		<span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    	<span class="comment">// 2. 使用 SpringFactoriesLoader查找并加载</span></span><br><span class="line">		<span class="comment">// classpath下 META-INF/spring.factories文件中所有可用的		   ApplicationContextInitializer</span></span><br><span class="line">		setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">				ApplicationContextInitializer.class));</span><br><span class="line">    	<span class="comment">//3.使用 SpringFactoriesLoader查找并加载</span></span><br><span class="line">		<span class="comment">// classpath下 META-INF/spring.factories文件中的所有可用的 ApplicationListener</span></span><br><span class="line">		setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">		<span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>判断应用的类型    <strong>REACTIVE/NONE/SERVLET</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> WebApplicationType <span class="title">deduceFromClasspath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="keyword">null</span>)</span><br><span class="line">				&amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="keyword">null</span>)</span><br><span class="line">				&amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="keyword">null</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> WebApplicationType.REACTIVE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="keyword">null</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> WebApplicationType.NONE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> WebApplicationType.SERVLET;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>WebApplicationType其实就是一个保存应用类型的枚举</p>
</blockquote>
</li>
<li><p>获取<code>ApplicationContextInitializer</code></p>
<p><code>ApplicationContextInitializer</code>用于在<code>ConfigurableApplicationContext</code>进行refresh之前的初始化工作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextInitializer</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">ConfigurableApplicationContext</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Initialize the given application context.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> applicationContext the application to configure</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(C applicationContext)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>获取<code>ApplicationListener</code></p>
<blockquote>
<p>这部分需要展开</p>
</blockquote>
<p>Spring的<strong>事件监听器</strong>模式，简单概括为：在Spring上下文对象启动前，添加事件监听器，然后Spring上下文正式启动后，就可以监听属于自己监听范围的事件</p>
<ol>
<li><p>Java中的事件对象是EventObject，而Spring中的事件对象是ApplicationEvent，是继承自EventObject的抽象类</p>
<p><img src="http://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture1.png" alt=""></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationEvent</span> <span class="keyword">extends</span> <span class="title">EventObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** use serialVersionUID from Spring 1.2 for interoperability */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7099057708183571937L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** System time when the event happened */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestamp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new ApplicationEvent.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> source the object on which the event initially occurred (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ApplicationEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(source);</span><br><span class="line">		<span class="keyword">this</span>.timestamp = System.currentTimeMillis();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the system time in milliseconds when the event happened.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.timestamp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以自定义一个Spring的事件对象，继承自抽象类ApplicationEvent，并自定义事件对象的周期</p>
</blockquote>
<ol start="2">
<li>AnnotationConfigApplicationContext上下文对象</li>
</ol>
</li>
</ol>
<p>   <img src="http://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture2.png" alt=""></p>
<ol start="3">
<li><p>ApplicationListener是默认的监听器对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Handle an application event.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> event the event to respond to</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E event)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样地，我们不但可以自定义事件对象，也可以自定义监听器对象</p>
</blockquote>
<p>完整的事件/监听器模式的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringEventListenerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 1.增加监听器</span></span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> MyApplicationListener());</span><br><span class="line">        <span class="comment">// context.register(MyApplicationListener.class);</span></span><br><span class="line">        <span class="comment">// 2.上下文的启动</span></span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="comment">// 3.发布事件（上下文启动后才可以发布事件）</span></span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> MyApplicationEvent(<span class="string">"Hello,World"</span>));</span><br><span class="line">        <span class="comment">// 发布事件后，监听器会自动监听到事件</span></span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> MyApplicationEvent(<span class="string">"Hello,World"</span>));</span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> MyApplicationEvent(<span class="string">"Hello,World"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义一个事件监听器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Handle an application event.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> event the event to respond to</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyApplicationEvent event)</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"MyApplicationListener receieves event: %s\n"</span>, event.getSource());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义一个事件对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyApplicationEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(source);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>事件 ，事件的监听器，上下文对象，这三者需要区分清楚</p>
</blockquote>
<h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p>创建了SpringApplication后，我们来看run方法。</p>
<p><code>run</code>方法是SpringApplication类的核心。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">		StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">		stopWatch.start();</span><br><span class="line">		ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">		Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		configureHeadlessProperty();</span><br><span class="line">         <span class="comment">// 1.获取并创建SpringApplicationRunListeners</span></span><br><span class="line">		SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">         <span class="comment">// 2.启动SpringApplicationRunListeners中所有的监听器</span></span><br><span class="line">		listeners.starting();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">					args);</span><br><span class="line">            <span class="comment">// 3.创建参数，并配置Environment</span></span><br><span class="line">			ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">					applicationArguments);</span><br><span class="line">			configureIgnoreBeanInfo(environment);</span><br><span class="line">            <span class="comment">// 4.设置banner，也就是我们启动的时候，控制台打印的图片</span></span><br><span class="line">			Banner printedBanner = printBanner(environment);</span><br><span class="line">            <span class="comment">// 5.创建上下文对象，一般是两种，web和非web</span></span><br><span class="line">			context = createApplicationContext();</span><br><span class="line">			exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">					SpringBootExceptionReporter.class,</span><br><span class="line">					<span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">            <span class="comment">//  6.初始化context，设置environment给它，以及加载其他配置信息</span></span><br><span class="line">			prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">					printedBanner);</span><br><span class="line">            <span class="comment">// 7.启动上下文</span></span><br><span class="line">			refreshContext(context);</span><br><span class="line">            <span class="comment">// 8.启动完成后，可以做一些事情（这是个模板方法）</span></span><br><span class="line">			afterRefresh(context, applicationArguments);</span><br><span class="line">			stopWatch.stop();</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">				<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">						.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">			&#125;</span><br><span class="line">			listeners.started(context);</span><br><span class="line">			callRunners(context, applicationArguments);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			listeners.running(context);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> context;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>主要流程如下所示：</p>
<ol>
<li>通过 <code>SpringFactoriesLoader</code> 加载 <code>META-INF/spring.factories</code> 文件，获取并创建 <code>SpringApplicationRunListener</code> 对象</li>
<li>然后由 <code>SpringApplicationRunListener</code> 来发出 starting 消息</li>
<li>创建参数，并配置当前 SpringBoot 应用将要使用的 Environment</li>
<li>完成之后，依然由 <code>SpringApplicationRunListener</code> 来发出 environmentPrepared 消息</li>
<li>创建 <code>ApplicationContext</code></li>
<li>初始化 <code>ApplicationContext</code>，并设置 Environment，加载相关配置等</li>
<li>由 <code>SpringApplicationRunListener</code> 来发出 <code>contextPrepared</code> 消息，告知SpringBoot 应用使用的 <code>ApplicationContext</code> 已准备OK</li>
<li>将各种 beans 装载入 <code>ApplicationContext</code>，继续由 <code>SpringApplicationRunListener</code> 来发出 contextLoaded 消息，告知 SpringBoot 应用使用的 <code>ApplicationContext</code> 已装填OK</li>
<li>refresh ApplicationContext，完成IoC容器可用的最后一步</li>
<li>由 <code>SpringApplicationRunListener</code> 来发出 started 消息</li>
<li>完成最终的程序的启动</li>
<li>由 <code>SpringApplicationRunListener</code> 来发出 running 消息，告知程序已运行起来了</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>这里需要区分两个启动，上下文的启动和程序的启动，核心是上下文的启动，上下文启动后，还需要进行程序的启动。</p>
<p>程序启动代码如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callRunners</span><span class="params">(ApplicationContext context, ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">		List&lt;Object&gt; runners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</span><br><span class="line">		runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</span><br><span class="line">		AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line">		<span class="keyword">for</span> (Object runner : <span class="keyword">new</span> LinkedHashSet&lt;&gt;(runners)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (runner <span class="keyword">instanceof</span> ApplicationRunner) &#123;</span><br><span class="line">				callRunner((ApplicationRunner) runner, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (runner <span class="keyword">instanceof</span> CommandLineRunner) &#123;</span><br><span class="line">				callRunner((CommandLineRunner) runner, args);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主要有ApplicationRunner和CommmandLineRunner这两个</p>
</blockquote>
<p>根据类型判断，采取哪一个来调用callRunner方法完成启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Callback used to run the bean.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args incoming application arguments</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception on error</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Callback used to run the bean.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args incoming main method arguments</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception on error</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：这里的<code>SpringApplicationRunListener</code>对象主要是对<code>Environment</code>和<code>ApplicationContext</code>进行监听，并发布消息。</p>
<hr>
<p>参考文章：<a href="https://mp.weixin.qq.com/s/qbMMZdMsbIpG77diGVwWtg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qbMMZdMsbIpG77diGVwWtg</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/13/MySQL主从同步原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/13/MySQL主从同步原理/" itemprop="url">MySQL主从同步原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-13T13:27:54+08:00">
                2019-04-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当系统应用访问量大大增加的时候，单台服务器的性能出现瓶颈，数据库的读写效率就会大大降低，这时候就需要主从同步，也就是一个主库带着多个从库，主库主要负责写，并将数据同步到从库，而从库负责读，这样就缓解了数据库的读写压力。并且，当主库宕机的时候，会自动切换一个旧的从库，将其升级成新的主库。</p>
<p>那么我们就来看看数据库主从同步的原理</p>
<h1 id="主从同步简介"><a href="#主从同步简介" class="headerlink" title="主从同步简介"></a>主从同步简介</h1><p>主从同步，对于主库与从库的配置，可以我们在服务器上进行配置。配置主要就是建立主库与从库的关系，核心就是主库赋予从库一个用户账号来从主库那里同步数据。</p>
<blockquote>
<p>我在设置同步账号的时候，由于从库的密码级别调得很高，导致同步出错。之前觉得MySQL的密码没必要设置得这么简单，但是后来发现，在企业级开发中，为了保证安全性，必须设置复杂的密码，并且最好不要使用root用户来连接数据库。并且3306端是人人皆知，我们可以修改成别的端口，以防止数据库被攻击。</p>
</blockquote>
<p>关于配置层面，就是应用程序层面动态选择主库还是从库，主库是写操作，从库是读操作。比如如果使用了MyBatis，就可以采用其自定义的插件来实现对SQL语句的拦截，实现读操作走从库，写操作访问主库。</p>
<blockquote>
<p>关于MyBatis的插件实现动态访问主库和从库，会在之后的学习中有涉及，并尽可能地输出到我的个人博客。</p>
</blockquote>
<h1 id="binlog简介"><a href="#binlog简介" class="headerlink" title="binlog简介"></a>binlog简介</h1><p>MySQL实现<strong>主从同步</strong>，离不开<code>binlog</code>。我们需要首先了解下<code>binlog</code>。</p>
<p>binlog日志用于记录所有更新了数据或者已经潜在更新了数据（例如，没有匹配任何行的一个DELETE）的所有语句。语句以“事件”的形式保存，它描述数据更改，它是以二进制的形式保存在磁盘中。我们可以通过mysql提供的查看工具<code>mysqlbinlog</code>文件中的内容，例如 mysqlbinlog mysql-bin.00001 | more，这里注意一下binlog文件的后缀名00001，binlog文件大小和个数会不断的增加，当MySQL停止或重启时，会产生一个新的binlog文件，后缀名会按序号递增，例如mysql-bin.00002、mysql-bin.00003，并且当binlog文件大小超过 max_binlog_size系统变量配置时也会产生新的binlog文件。</p>
<p>主库的<code>binlog</code>可以将主库的数据同步到从库，然后从库将这些数据写入到数据库当中，这样就实现了主从同步。</p>
<h2 id="binlog日志格式"><a href="#binlog日志格式" class="headerlink" title="binlog日志格式"></a>binlog日志格式</h2><p>（1） <code>statement</code> ： 记录每一条更改数据的sql;</p>
<ul>
<li>优点：binlog文件较小，节约I/O，性能较高。</li>
<li>缺点：不是所有的数据更改都会写入binlog文件中，尤其是使用MySQL中的一些特殊函数（如LOAD_FILE()、UUID()等）和一些不确定的语句操作，从而导致主从数据无法复制的问题。</li>
</ul>
<p>（2） <code>row</code>： 不记录sql，只记录<strong>每行数据的更改细节</strong></p>
<ul>
<li>优点：详细的记录了每一行数据的更改细节，这也意味着不会由于使用一些特殊函数或其他情况导致不能复制的问题。</li>
<li>缺点：由于row格式记录了每一行数据的更改细节，会产生大量的binlog日志内容，性能不佳，并且会增大主从同步延迟出现的几率。</li>
</ul>
<p>（3） <code>mixed</code>：一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。</p>
<blockquote>
<p>从库的数据库版本要不低于主库的版本，是为了让从库接收到主库的binlog后，能够正确执行。</p>
</blockquote>
<h1 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h1><p>mysql主从复制需要三个线程，master（binlog dump thread）、slave（I/O thread 、SQL thread）。</p>
<p><strong>master</strong></p>
<p>（1）<code>binlog dump</code>线程：当主库中有数据更新时，那么主库就会根据按照设置的binlog格式，将此次更新的事件类型写入到主库的binlog文件中，此时主库会创建log dump线程通知slave有数据更新，当I/O线程请求日志内容时，会将此时的binlog名称和当前更新的位置同时传给slave的I/O线程。</p>
<p><strong>slave</strong></p>
<p>（2）<code>I/O</code>线程：该线程会连接到master，向log dump线程请求一份指定binlog文件位置的副本，并将请求回来的binlog存到本地的relay log中，relay log和binlog日志一样也是记录了数据更新的事件，它也是按照递增后缀名的方式，产生多个relay log（ host_name-relay-bin.000001）文件，slave会使用一个index文件（ host_name-relay-bin.index）来追踪当前正在使用的relay log文件。</p>
<p>（3）<code>SQL</code>线程：该线程检测到relay log有更新后，会读取并在本地做redo操作，将发生在主库的事件在本地重新执行一遍，来保证主从数据同步。此外，如果一个relay log文件中的全部事件都执行完毕，那么SQL线程会自动将该relay log 文件删除掉。</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/linkedkeeper0_b3fa3bae-e0f3-4a9b-b16f-4e4da63362b9.jpg" alt=""></p>
<p>这里面需要注意是从库开启了一个IO线程，将主库的binlog内容写入到Relay log中，然后SQL线程检测到Relay log的更新，就将数据同步到数据库中。</p>
<blockquote>
<p>为了性能考虑，不会直接将主库的binlog写给从库，而是通过Relay log先接受主库数据，然后再同步到从库中。</p>
</blockquote>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol>
<li><p>主从同步有延迟吗？</p>
<blockquote>
<p>有的，因为从库的同步比较消耗时间</p>
</blockquote>
</li>
<li><p>主从同步能完全缓解数据库的压力吗？</p>
<blockquote>
<p>不能，因为数据库还会承受一定的压力，高并发下性能还会下降，这时候可以通过消息队列进行削峰处理，限制PQS；也可以说采用Redis等缓存中间件来缓解从库的读请求压力；另外还可以进行分库分表，将数据库的大表拆分成小表，然后分摊到每个小表的请求就会很少，这样，数据库的压力也就减小了</p>
</blockquote>
</li>
<li><p>你们的数据库服务器有没有采用主从同步？</p>
<blockquote>
<p>我们的系统，是一主一从，主库主要负责写入数据，从库负责同步主库写入的数据并且接收后台管理系统（运营）和用户的读请求；另外，我们采用了缓存ehcache，缓解了数据库从库的压力；特别地，对于一些冷数据，我们提前从从库中读取出来，作为一个js静态文件写入到云服务器的磁盘中，然后用户访问前台页面的时候，就直接从js文件中获取。这样做的话，缓解了缓存服务器的压力，并且可以更迅速的获取数据，加快了前台页面的响应速度。</p>
</blockquote>
</li>
</ol>
<p><strong>一点思考</strong></p>
<p>主从同步的架构下，主库与从库的延迟是客观存在的；这一点对于关系数据库是这样的，对Redis也同样适用，因为不是自己本机的数据，同步到另一台机器，这个同步就会产生延迟，我们能做的就是缩小延迟。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/12/数据结构基本总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/数据结构基本总结/" itemprop="url">数据结构基本总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-12T19:25:41+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>数据结构是计算机存储、组织数据的方式。数据结构是指相互直接存在一种或多种特殊关系的数据元素的集合。</p>
<blockquote>
<p>简单来说，就是组织数据的集合。</p>
</blockquote>
<h2 id="线性结构VS非线性结构"><a href="#线性结构VS非线性结构" class="headerlink" title="线性结构VS非线性结构"></a>线性结构VS非线性结构</h2><p><strong>线性结构是一个有序数据元素的集合</strong>。它应该满足下面的特征：</p>
<ul>
<li>集合中必存在唯一的一个“第一个元素”</li>
<li>集合中必存在唯一的一个“最后的元素”</li>
<li>除最后一元素之外，其它数据元素均有唯一的“后继”</li>
<li>除第一个元素之外，其它数据元素均有唯一的“前驱”</li>
</ul>
<p>常见的线性结构由栈，队列等</p>
<p><strong>非线性结构：其逻辑特征是一个节点元素可以有多个直接前驱或多个直接后继。</strong></p>
<p>符合条件的数据结构有图、树和其它</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一种线性结构</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种<strong>后进先出</strong>(LIFO)的线性表，是一种基于数组的存储结构。</p>
<ul>
<li>LIFO(Last In First Out)表示后进先出，后进来的元素第一个弹出栈空间。类似于自动餐托盘，最后放上去的托盘，往往先被拿出来使用。</li>
<li>仅允许在表的一端进行插入和移除元素。这一端被称为栈顶，相对地，把另一端称为栈底</li>
<li>向一个栈插入新元素称作进栈、入栈或压栈，这是将新元素放在栈顶元素上面，使之成为新的栈顶元素。</li>
<li>从一个栈删除元素又称为出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素</li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种先进先出（FIFO）受限的线性表。受限体现在于其允许在表的前端（front）进行删除操作，在表的末尾（rear）进行插入【优先队列这些排除在外】操作。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote>
<p>首先需要对数组的优缺点做一个介绍</p>
</blockquote>
<p><strong>优点</strong>：</p>
<ul>
<li>存储多个元素</li>
<li>访问比较便捷，数组元素[index]即可访问</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><p>数组的创建通常需要申请一段连续的内存空间，并且大小是固定的（大多数的编程语言数组都是固定的），所以在进行扩容的时候难以掌控。</p>
</li>
<li><p>一般情况下，申请一个更大的数组，会是之前数组的倍数，比如两倍。然后，再将原数组中的元素复制过去</p>
</li>
<li><p>插入数据越是靠前，其成本很高，因为需要进行大量元素的位移。</p>
</li>
</ul>
<blockquote>
<p>相对数组，链表亦可以存储多个元素，而且存储的元素在内容中不必是连续的空间；<br>在插入和删除数据时，时间复杂度可以达到O(1)。</p>
</blockquote>
<p><strong>但是链表查找元素还是需要从头开始遍历的</strong></p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture316.png" alt=""></p>
<p>链表是由一组节点组成的集合。每个节点都使用一个对象的引用指向它的后继</p>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p> 树的定义：</p>
<ul>
<li><p>树（Tree）：n(n &gt;= 0)个节点构成的有限集合。</p>
<ul>
<li><p>当<code>n = 0</code>时，称为空树；</p>
</li>
<li><p>对任意一棵空树<code>(n &gt; 0)</code>，它具备以下性质：</p>
<pre><code>树中有一个称为根(Root)的特殊节点，用`r(root)`表示；
</code></pre><p>  其余节点可分为<code>m(m &gt; 0)</code>个互不相交的有限集<code>T1,T2,…Tm</code>，其中每个集合本省又是一棵树，称为原来树的子树（SubTree）</p>
</li>
</ul>
</li>
</ul>
<p>注意：</p>
<p>​    子树之间<code>不可以相交</code>；</p>
<p>​    除了根节点外，每个节点有且仅有一个父节点；</p>
<p>​    一个<code>N</code>个节点的树有<code>N-1</code>条边。</p>
<p>树的术语：</p>
<ul>
<li><p>节点的度（Degree）：节点的子树个数。</p>
</li>
<li><p>树的度：树的所有节点中最大的度数（树的度通常为节点个数的N-1）。</p>
</li>
<li><p>叶节点（Leaf）：度为0的节点（也称叶子节点）。</p>
</li>
<li><p>父节点（Parent）：有子树的节点是其子树的父节点。</p>
</li>
<li><p>子节点（Child）：若A节点是B节点的父节点，则称B节点是A节点的子节点。</p>
</li>
<li><p>兄弟节点（Sibling）：具有同一个父节点的各节点彼此是兄弟节点。</p>
</li>
<li><p>路径和路径长度：从节点n1到nk的路径为一个节点序列n1,n2,n3,…,nk，ni是ni+1的父节点。路径所包含边的个数为路径长度。</p>
</li>
<li><p>节点的层次（Level）：规定根节点在第0层，它的子节点是第1层，子节点的子节点是第2层，以此类推。</p>
</li>
<li><p>树的深度（Depth）：树中所有节点中的最大层次是这棵树的深度（因为上面是从第0层开始，深度 = 第最大层数 + 1）</p>
</li>
</ul>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture317.png" alt=""></p>
<p>二叉树的定义：</p>
<ul>
<li><p>二叉树可以为空，也就是没有节点</p>
</li>
<li><p>二叉树若不为空，则它是由根节点和称为其左子树<code>TL</code>和右子树<code>RT</code>的两个不相交的二叉树组成</p>
</li>
<li><p>二叉树每个节点的子节点不允许超过<code>两个</code></p>
</li>
<li><p>二叉树的五种形态：</p>
<ul>
<li>空</li>
</ul>
<ul>
<li>只有根节点</li>
<li>只有左子树</li>
<li>只有右子树</li>
<li>左右子树均有</li>
</ul>
</li>
</ul>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture318.png" alt=""></p>
<p><strong>二叉查找树</strong></p>
<p><strong>二叉查找树</strong>，也称二叉搜索树或二叉排序树，是一种特殊的二叉树，相对值较<code>小</code>的值保存在<code>左</code>节点中，较<code>大</code>的值保存在<code>右</code>节点中。</p>
<p>二叉查找树特殊的结构使它能够快速的进行查找、插入和删除数据。</p>
<blockquote>
<p>留意下二叉查找树的三种遍历方式</p>
</blockquote>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture319.png" alt=""></p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p><strong>图</strong>由边的集合及顶点的集合组成。</p>
<p>我们来了解下图的相关术语：</p>
<ul>
<li><p>顶点：图中的一个节点。</p>
</li>
<li><p>边：表示顶点和顶点之间的连线。</p>
</li>
<li><p>相邻顶点：由一条边连接在一起的顶点称为相邻顶点。</p>
</li>
<li><p>度：一个顶点的度是相邻顶点的数量。比如<code>0</code>顶点和其它两个顶点相连，<code>0</code>顶点的度就是<code>2</code></p>
</li>
<li><p>路径：路径是顶点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1,v2...,vn</span><br></pre></td></tr></table></figure>
<p>的一个连续序列。</p>
</li>
<li><p>简单路径：简单路径要求不包含重复的顶点。</p>
</li>
<li><p>回路：第一个顶点和最后一个顶点相同的路径称为回路。</p>
</li>
<li><p>有向图和无向图</p>
</li>
<li><p>有向图表示图中的<code>边</code>是<code>有</code>方向的。</p>
</li>
<li><p>无向图表示图中的<code>边</code>是<code>无</code>方向的。</p>
</li>
<li><p>带权图和无权图</p>
</li>
<li><p>带权图表示图中的边<code>有权重</code>。</p>
</li>
<li><p>无权图表示图中的边<code>无权重</code>。</p>
</li>
</ul>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture320.png" alt=""></p>
<p>图可以用于现实中的很多系统建模，比如：</p>
<ul>
<li>对交通流量建模</li>
<li>顶点可以表示街道的十字路口, 边可以表示街道.</li>
<li>加权的边可以表示限速或者车道的数量或者街道的距离.</li>
<li>建模人员可以用这个系统来判定最佳路线以及最可能堵车的街道.</li>
</ul>
<hr>
<p>原文地址：<a href="https://github.com/reng99/blogs" target="_blank" rel="noopener">https://github.com/reng99/blogs</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/12/Spring事务处理机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/Spring事务处理机制/" itemprop="url">Spring事务处理机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-12T17:07:25+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="事务的介绍"><a href="#事务的介绍" class="headerlink" title="事务的介绍"></a>事务的介绍</h1><p>Spring默认的声明式事务，在遇到checked异常的情况下，还是会提交的，当遇到uncheckedException也就是<code>RuntimeException</code>体系中的异常，就会自动回滚事务，保证事务的原子性，完整性等特性。</p>
<p><strong>事务的四个特性</strong>：</p>
<ul>
<li>原子性             要么全部成功，要么全部回滚</li>
<li>一致性            转账用户之间金额总数在事务过程中不发生变化</li>
<li>隔离性         各个并发事务之间是独立的</li>
<li>持久性           事务提交后对数据库的改变要持久化到磁盘</li>
</ul>
<h1 id="Spring事务的属性和使用入口"><a href="#Spring事务的属性和使用入口" class="headerlink" title="Spring事务的属性和使用入口"></a>Spring事务的属性和使用入口</h1><h2 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h2><p>传播行为，隔离级别，事务超时，只读事务，回滚规则</p>
<blockquote>
<p>通常在使用Spring事务处理机制的时候，我们不会采用编程式事务，通常采用<strong>声明式事务</strong></p>
</blockquote>
<p><strong>传播行为</strong>：</p>
<p><code>Propagation propagation() default Propagation.REQUIRED;</code><br>事务默认的传播行为是<code>REQUIRED</code>，也就是方法中只存在一个事务，会有事务合并的一个过程<br>（支持当前事务，如果不存在则创建新事务。 类似于同名的EJB事务属性。 这是声明式事务的默认设置）</p>
<p><strong>隔离级别</strong>：</p>
<p><code>Isolation isolation() default Isolation.DEFAULT;</code><br>默认情况下，Spring采用的是连接的数据库的隔离级别</p>
<p><strong>事务超时</strong></p>
<p><code>int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;</code><br>默认情况下，事务超时的时间和连接的数据库保持一致</p>
<p><strong>只读事务</strong></p>
<p><code>boolean readOnly() default false;</code><br>默认情况下，事务不是只读的。<br>但是如果是一些查询，我们可以定义该事务为只读事务，这样数据库会对只读事务做一些优化</p>
<p><strong>回滚规则</strong></p>
<p><code>Class&lt;? extends Throwable&gt;[] rollbackFor() default {};</code><br> 抛出指定异常的时候，事务会回滚</p>
<p><code>String[] rollbackForClassName() default {};</code> <strong>不推荐使用</strong></p>
<blockquote>
<p>设置需要回滚的异常类（数组) </p>
</blockquote>
<p><code>Class&lt;? extends Throwable&gt;[] noRollbackFor() default {};</code><br><code>String[] noRollbackForClassName() default {};</code> <strong>不推荐使用</strong><br>设置不需要进行回滚的异常类</p>
<h2 id="使用入口"><a href="#使用入口" class="headerlink" title="使用入口"></a>使用入口</h2><p><strong><code>@Transactional</code></strong></p>
<ul>
<li>该注解只有应用到<code>public</code>方法才有效，</li>
<li>在Spring的默认事务处理机制中，只会将抛出<code>RuntimeException</code>的事务进行回滚</li>
</ul>
<h1 id="Spring事务管理接口"><a href="#Spring事务管理接口" class="headerlink" title="Spring事务管理接口"></a>Spring事务管理接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>; <span class="comment">// 获取事务的状态信息</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br></pre></td></tr></table></figure>
<p>Spring只是提供了事务管理的接口，具体的实现，交给持久化框架来实现</p>
<h1 id="Spring事务机制的验证"><a href="#Spring事务机制的验证" class="headerlink" title="Spring事务机制的验证"></a>Spring事务机制的验证</h1><p><strong>总结</strong></p>
<ul>
<li>Spring的声明式事务中，如果<strong>主动捕获异常</strong>，默认不会回滚事务，所以捕获异常的操作，我们最好放在controller层进行捕获异常</li>
<li>如果抛出的不是<code>RuntimeException</code>，事务也不会回滚</li>
</ul>
<p><strong>Spring事务对指定异常和rollBackOnly异常的处理</strong></p>
<ul>
<li><p>抛出<code>RuntimeException</code>,事务可以回滚</p>
</li>
<li><p>指定异常，事务可以回滚<br><code>@Transactional(rollbackFor={AExcetion.class})</code></p>
</li>
<li><p><code>RollbackOnly</code> 事务可以回滚</p>
</li>
</ul>
<blockquote>
<p><strong>当一个没有开启事务的方法去调用一个开启事务的方法，事务是否能够回滚？</strong></p>
</blockquote>
<p>  <strong>同一个类中</strong>，一个不标注事务的方法去调用标注了事务的方法，事务会失效，不会发生回滚</p>
<p>  <strong>在不同的类中</strong>，一个不标注事务的方法去调用标注了事务的方法，事务会发生回滚</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    实际使用事务的时候，一定要记得抛出<code>RuntimeException</code>，这样事务才可以回滚。我觉得，这是最稳健的做法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/12/JVM——垃圾回收/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/JVM——垃圾回收/" itemprop="url">JVM——垃圾回收</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-12T09:41:58+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h2><blockquote>
<p>垃圾回收主要回收的是堆内存空间中的对象。</p>
</blockquote>
<p>对象被判定为垃圾的标准：</p>
<ul>
<li>没有被其他对象和引用变量引用</li>
</ul>
<h3 id="判断对象为垃圾的算法："><a href="#判断对象为垃圾的算法：" class="headerlink" title="判断对象为垃圾的算法："></a>判断对象为垃圾的算法：</h3><ul>
<li>引用计数算法</li>
<li>可达性分析算法</li>
</ul>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><blockquote>
<p>判断对象的引用数量</p>
</blockquote>
<ul>
<li><p>通过判断对象的 引用数量来决定对象是否可以被回收</p>
</li>
<li><p>堆中的每一个对象实例都有一个计数器，被引用则+1，完成引用则-1</p>
<blockquote>
<p>比如某方法中声明了一个引用变量指向某对象实例，在方法执行结束后，该引用变量就会自动被回收，所以就完成了引用，则该对象实例的计数器-1</p>
</blockquote>
</li>
<li><p>任何引用计数为0的对象实例可以被当作垃圾收集</p>
</li>
</ul>
<p>优点：执行效率高，程序执行受影响比较小（简单粗暴）</p>
<p>缺点： 无法检测出循环引用的情况，导致内存泄漏</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><blockquote>
<p>通过判断对象的引用链是否可传达来决定对象是否可以被回收</p>
</blockquote>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture207.png" alt=""></p>
<p>可以作为GC Root的对象：</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture208.png" alt=""></p>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记-清除算法（Mark-and-Sweep）"><a href="#标记-清除算法（Mark-and-Sweep）" class="headerlink" title="标记-清除算法（Mark and Sweep）"></a>标记-清除算法（Mark and Sweep）</h4><p>标记：从根集合进行扫描，对存活的对象进行标记</p>
<p>清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture209.png" alt=""></p>
<p>缺点：碎片化</p>
<h4 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h4><blockquote>
<p>多用于新生代垃圾收集器</p>
</blockquote>
<ul>
<li>分为对象面和空闲面</li>
<li>对象在对象面上创建</li>
<li>存活的对象被从对象面复制到空闲面</li>
<li>将对象面所有对象内存清除</li>
</ul>
<blockquote>
<p>适用于对象存活率比较低的场景，不用考虑内存碎片等复杂情况；对象存活率比较高的情况下，复制操作很耗时</p>
</blockquote>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture210.png" alt=""></p>
<h4 id="标记-整理算法（Compacting"><a href="#标记-整理算法（Compacting" class="headerlink" title="标记-整理算法（Compacting)"></a>标记-整理算法（Compacting)</h4><blockquote>
<p>老年代，解决了内存碎片的问题，但是还是有一个按照内存地址排序的过程。</p>
</blockquote>
<ul>
<li>标记：从根集合去扫描，对存活的对象进行标记</li>
<li>清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收</li>
</ul>
<p> <img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture211.png" alt=""></p>
<p>优点：避免了内存的不连续性；</p>
<p>​        不用设置两块内存互换；（和复制算法相比）</p>
<p>​        适用于对象存活率较高的场景</p>
<h4 id="分代收集算法（Generational-Collector"><a href="#分代收集算法（Generational-Collector" class="headerlink" title="分代收集算法（Generational Collector)"></a>分代收集算法（Generational Collector)</h4><blockquote>
<p>对前几种垃圾回收算法的综合运用</p>
</blockquote>
<ul>
<li>垃圾回收算法的组合拳</li>
<li>按照对象生命周期的不同划分区域以采用不同的垃圾回收算法</li>
<li>目的：提高JVM的回收效率</li>
</ul>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture212.png" alt=""></p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture213.png" alt=""></p>
<p>年轻代对象存活率低，使用复制算法；</p>
<p>老年代对象存活率高，使用标记-整理算法</p>
<blockquote>
<p>分代收集算法GC的分类：</p>
</blockquote>
<ul>
<li><p>Minor GC </p>
<blockquote>
<p>年轻代：尽可能快速收集掉哪些生命周期短的对象</p>
</blockquote>
<ul>
<li><p>Eden 区 </p>
<p>对象刚被创建出来的时候，会被优先分配到Eden区；当然如果内存不够了，也会被分配到Surivor区，甚至被分配到老年代中 </p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>两个Survivor区</p>
<p>From区，To区</p>
<blockquote>
<p>这两个Survivor区，具体哪个区被分配为From区，哪个区被分配为To区也不是固定的，随着垃圾回收的进行而相互转换</p>
</blockquote>
<p>年轻代的目标是快速收集掉那些生命周期短的对象</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture214.png" alt=""></p>
</li>
</ul>
<ul>
<li>Full GC</li>
</ul>
<blockquote>
<p>对象如何晋升到老年代？</p>
</blockquote>
<ul>
<li>经历一定Minor次数还能存活的对象（对象每经历一次Minor GC，则对象年龄自动加一，达到一定的年龄，默认15岁，则被晋升为老年代</li>
</ul>
<ul>
<li><p>Survivor区中放不下的对象</p>
<p>我们从年轻代开始讲起，对象刚创建出来在Eden Space中分配，当Eden空间满了(没有足够的空间)，则进行一次Minor GC，每一次Minor GC结束后，Eden区就会被清空，Eden区中依然存活的对象，会被放到两个Survivor中的一个中，当Survivor中放不下了，就会将对象放到老年代中。</p>
</li>
</ul>
<ul>
<li><p>新生成的大对象（-XX:+PretenuerSizeThreshold可控制大对象的大小，达到了一定的Size后，对象自动被放入老</p>
<p>年代中）</p>
</li>
</ul>
<blockquote>
<p>以上三种情况都是可以用参数进行配置的</p>
</blockquote>
<p>常用的调优参数：</p>
<ul>
<li><p>-XX:SurvivorRatio：Eden和Survivor的比值，默认8：1</p>
</li>
<li><p>-XX:NewRatio：老年代与年轻代的内存大小比例 </p>
<p>新生代与老年代内存的总大小是由-Xms - Xmx来控制的</p>
</li>
<li><p>-XX:MaxTenuringThreshold：对象从年轻代晋升到老年代经历GC的最大次数</p>
</li>
</ul>
<p>老年代：存放生命周期较长的对象</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture215.png" alt=""></p>
<p>老年代采用标记-清理算法或者标记-整理算法来回收垃圾</p>
<ul>
<li><p>Full GC和Major GC</p>
<p>Full GC比Minor GC慢很多，但执行效率低</p>
<p>Full GC发生的频率要比Minor GC发生的频率要低很多（因为老年代保存的是生命周期比较长的对象）</p>
</li>
</ul>
<blockquote>
<p>触发Full GC的条件：</p>
</blockquote>
<ul>
<li><p>老年代空间不足（不要创建太大的对象）</p>
</li>
<li><p>永久代空间不足（针对JDK7以前的版本）</p>
<blockquote>
<p>JDK 8采用元空间来代替永久代空间，减少了Full GC的频率</p>
</blockquote>
</li>
<li><p>CMS GC 时出现的<code>promotion fail ，concurrent mode failure</code></p>
<blockquote>
<p><code>promotion fail</code>是指在Minor GC时，Survivor中放不下对象，就把对象放老年代了，老年代也放不下了，就会触发<code>Full GC</code></p>
<p><code>，concurrent mode failure</code>：老年代空间不足</p>
</blockquote>
</li>
<li><p>Minor GC晋升到老年代的平均大小大于老年代的剩余空间</p>
<blockquote>
<p>Minro GC晋升到老年代，会检查老年代的剩余空间，如果不足，就会触发Full GC</p>
</blockquote>
</li>
<li><p>程序调用System.gc()提示虚拟机去回收对象，但是具体由虚拟机判断回不回收</p>
</li>
<li><p>使用RMI来进行RPC或者管理你的JDK应用时，每小时执行一次Full GC</p>
</li>
</ul>
<h3 id="常见的垃圾收集器"><a href="#常见的垃圾收集器" class="headerlink" title="常见的垃圾收集器"></a>常见的垃圾收集器</h3><p>理论知识：</p>
<ol>
<li>Stop-the-World（除了GC线程外，其他线程都处于等待状态）</li>
</ol>
<ul>
<li>JVM由于要执行GC而停止了应用程序的执行</li>
<li>任何一种GC算法中都会发生</li>
<li>多数GC优化通过减少Stop-the-world发生的时间来提高程序性能</li>
</ul>
<ol start="2">
<li><p>Safepoint 安全点</p>
<ul>
<li>分析过程中对象引用关系不会发生变化的点</li>
<li>产生Safepoint的地方：方法调用；循环跳转；异常跳转</li>
<li>安全点数量得适中</li>
</ul>
<p>我理解为静态点，这样GC才可以找到一个稳定得点来执行</p>
</li>
</ol>
<h4 id="JVM的运行模式"><a href="#JVM的运行模式" class="headerlink" title="JVM的运行模式"></a>JVM的运行模式</h4><ul>
<li>Server 启动的JVM，是轻量级的JVM，进行了很多优化</li>
<li>Client  启动较快  </li>
</ul>
<h4 id="垃圾收集器之间的联系"><a href="#垃圾收集器之间的联系" class="headerlink" title="垃圾收集器之间的联系"></a>垃圾收集器之间的联系</h4><p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture216.png" alt=""></p>
<p>年轻代常见的垃圾回收器</p>
<ul>
<li><p>Serial 收集器（-XX:+UseSerialGC，复制算法） </p>
<ul>
<li><p>单线程收集，进行垃圾收集时，必须暂停所有工作线程</p>
</li>
<li><p>简单高效，Client模式下默认的年轻代收集器</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture217.png" alt=""></p>
</li>
</ul>
</li>
<li><p>ParNew收集器（-XX:+UseParNewGC，复制算法）</p>
<ul>
<li>多线程收集，其余的行为，特点和Serial收集器一样</li>
<li>单核执行效率不如Serial，在多核下执行具有优势</li>
</ul>
</li>
<li><p>Parallel Scavenge收集器（-XX:+UseParallelGC)  复制算法</p>
<p>系统吞吐量=CPU运行用户代码时间/（运行用户代码时间+垃圾收集时间）</p>
<ul>
<li>多线程。多核下执行具有优势，Server模式默认的年轻代收集器</li>
<li>比起关注用户线程停顿时间，更关注系统的吞吐量</li>
</ul>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture218.png" alt=""></p>
</li>
</ul>
<p>老年代常见的垃圾收集器</p>
<ul>
<li>Serial Old收集器（-XX:+UseSerialOldGC,标记整理算法）<ul>
<li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li>
<li>简单高效，Client模式下默认的老年代收集器</li>
</ul>
</li>
<li>Parallel Old收集器（-XX:+UserParallelOldGC,标记整理算法）<ul>
<li>多线程，吞吐量优先</li>
</ul>
</li>
</ul>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture219.png" alt=""></p>
<ul>
<li><p>CMS收集器（-XX:+UseConcMarkSweepGC，标记清除算法）</p>
<p>几乎做到垃圾收集线程与用户线程同时工作，缩短了stop the world的时间</p>
<ul>
<li>初始标记阶段：stop the world :smiley:</li>
<li>并发标记：并发追溯标记，程序不会停顿</li>
<li>并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象</li>
<li>重新标记：暂停虚拟机，扫描CMS堆中剩余的对象​ :smile:</li>
<li>并发清理：清理垃圾对象，程序不会卡顿</li>
<li>并发重置：重置CMS收集器的数据结构</li>
</ul>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture220.png" alt=""></p>
<blockquote>
<p>会产生内存碎片</p>
</blockquote>
</li>
<li><p>G1收集器（-XX:+UseG1GC，复制+标记-整理算法）<strong>同时用于老年代与新生代的垃圾收集器</strong></p>
<p>Garbage First的特点：</p>
<ul>
<li>并行与并发   减少 stop the world 的时间</li>
<li>分代收集     独立管理整个堆空间</li>
<li>空间整合 标记整理算法，不会产生碎片，因为由内存空间整合的过程</li>
<li>可预测的停顿          </li>
</ul>
</li>
</ul>
<ul>
<li><p>将整个Java堆内存划分成多个大小相等的Region</p>
</li>
<li><p>年轻代与老年代不再物理隔离 </p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture221.png" alt=""></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/12/JVM——Java内存模型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/JVM——Java内存模型/" itemprop="url">JVM——Java内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-12T09:06:42+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JVM内存结构-VS-Java内存模型-VSJava对象模型"><a href="#JVM内存结构-VS-Java内存模型-VSJava对象模型" class="headerlink" title="JVM内存结构 VS Java内存模型 VSJava对象模型"></a>JVM内存结构 VS Java内存模型 VSJava对象模型</h1><h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><p> 虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。</p>
<blockquote>
<p>白话来讲，就是JVM运行Java程序的时候产生的内存（该内存是由JVM进行管理的，比如垃圾回收就是对堆内存中的垃圾对象进行回收）</p>
</blockquote>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。JSR-133: Java Memory Model and Thread Specification中描述了，JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。</p>
<p>引用下H大的话：<br>简单总结下，Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。</p>
<p>详细内容，学习多线程与并发的时候再去深入</p>
<h2 id="Java对象模型"><a href="#Java对象模型" class="headerlink" title="Java对象模型"></a>Java对象模型</h2><p>Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。<br>Java对象模型其实就是Java对象在JVM中的表现形式。</p>
<p>具体内容，以后再深入</p>
<blockquote>
<p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了两部分信息，对象头以及元数据。对象头中有一些运行时数据，其中就包括和多线程相关的锁的信息。元数据其实维护的是指针，指向的是对象所属的类的<code>instanceKlass</code>。</p>
</blockquote>
<h1 id="Java内存模型的理解（JMM"><a href="#Java内存模型的理解（JMM" class="headerlink" title="Java内存模型的理解（JMM)"></a>Java内存模型的理解（JMM)</h1><p>并发编程，为了保证数据的安全，需要满足以下三个特性：</p>
<p><strong>原子性</strong>是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</p>
<p><strong>可见性</strong>是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p><strong>有序性</strong>即程序执行的顺序按照代码的先后顺序执行。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性：一个线程对<strong>共享变量</strong>值的修改，能够及时地被其他线程看到</p>
<p>共享变量：如果一个变量在多个线程的工作内存都存在副本，那么这个变量就是这几个线程的共享变量</p>
<p>Java内存模型：（JMM)<br>Java Memory Model，描述了Java程序中各种变量（<strong>线程共享变量</strong>）的访问规则，以及JVM中将变量存储到内存和从内存中读取出变量这样的底层细节</p>
<ul>
<li>所有的变量都存储在主内存中</li>
<li>每个线程都有自己独立的工作空间，里面保存该线程使用到的变量的副本（也就是说主内存中该变量的一份拷贝）</li>
</ul>
<p>我们跟着图再理解一下<br><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture315.png" alt="JMM"></p>
<p>​            其中主内存中有共享变量X</p>
<p><strong>两条规定</strong></p>
<ul>
<li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写</li>
<li>不同线程之间无法直接访问其他线程工作内存中的变量值，线程之间变量的传递需要通过主内存来完成</li>
</ul>
<blockquote>
<p>所以共享变量值的传递，就需要借助于主内存来完成。</p>
</blockquote>
<h3 id="共享变量可见性实现的原理"><a href="#共享变量可见性实现的原理" class="headerlink" title="共享变量可见性实现的原理"></a>共享变量可见性实现的原理</h3><p>线程1对共享变量的修改要想被线程2及时看到，需要经过如下的两个步骤：</p>
<ol>
<li>把工作内存1（线程1的工作空间）中更新过的共享变量刷新到主内存中</li>
<li>线程2把主内存中最新的共享变量值更新到工作内存2（线程2的工作空间）中</li>
</ol>
<p>这两个步骤任何一个步骤出现了差错，就无法实现共享变量的可见性</p>
<h2 id="synchronized实现可见性原理"><a href="#synchronized实现可见性原理" class="headerlink" title="synchronized实现可见性原理"></a>synchronized实现可见性原理</h2><p>Java语言层次方面支持的可见性实现方式：（不包含j.u.c包里面的一些实现方式）</p>
<ol>
<li>synchronized</li>
<li>volatile</li>
</ol>
<p>synchronized能够实现：</p>
<ul>
<li>原子性（同步）</li>
<li>可见性</li>
</ul>
<p><strong>JMM关于synchronized的两条规定</strong></p>
<ol>
<li>线程解锁前，必须将共享变量的最新值刷新到主内存中</li>
<li>线程加锁时，将清空工作空间中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（<strong>注意：加锁和解锁指的是同一把锁</strong>）</li>
</ol>
<blockquote>
<p>线程解锁前对共享变量的修改在下次加锁时对其他线程可见</p>
</blockquote>
<p>线程执行互斥代码的过程：</p>
<ol>
<li>获得互斥锁</li>
<li>清空自己的工作内存</li>
<li>从主内存拷贝变量的最新副本到工作内存</li>
<li>执行代码</li>
<li>将更改后的共享变量的值刷新到主内存</li>
<li>释放互斥锁</li>
</ol>
<blockquote>
<p>补充知识点</p>
</blockquote>
<p><strong>重排序</strong>：代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能所做的优化</p>
<ol>
<li>编译器优化的重排序（编译器优化）</li>
<li>指令级并行重排序（处理器优化）</li>
<li>内存系统的重排序（处理器优化）</li>
</ol>
<p>一个直观的认识：<br>代码顺序：                 执行顺序:<br>int number=1;               int result=0;<br>int result=0;                int number=1;</p>
<blockquote>
<p>执行顺序和代码书写顺序不一定一致</p>
</blockquote>
<p><strong>as-if-serial</strong></p>
<p>as-if-serial：无论如何重排序，程序执行的结果应该与代码书写顺序执行的结果一致<br>（Java编译器，运行时和处理器都会保证Java在<strong>单线程</strong>下遵循as-if-serial语义）</p>
<p>重排序不会给单线程带来内存可见性的问题</p>
<p>多线程中程序交错执行，重排序可能会造成内存可见性问题</p>
<p>导致共享变量在线程间不可见的原因：                    <strong>synchronized解决方案</strong></p>
<ol>
<li>线程的交叉执行                      —&gt; 原子性</li>
<li>重排序结合线程的交叉执行             —&gt; 原子性</li>
<li>共享变量更新后的值没有在工作空间与主内存之间及时更新   —&gt; 可见性</li>
</ol>
<p>总结：</p>
<ol>
<li>当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。</li>
<li>当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。</li>
<li>当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。</li>
</ol>
<h2 id="volatile实现可见性"><a href="#volatile实现可见性" class="headerlink" title="volatile实现可见性"></a>volatile实现可见性</h2><p><strong>volatile</strong>关键字:</p>
<ul>
<li>能够保证volatile变量的可见性</li>
<li>并不能保证volatile变量复合操作的原子性</li>
</ul>
<p><strong>volatile如何实现内存可见性</strong>：</p>
<p>深入来说，通过加入内存屏障和禁止重排序优化来实现的</p>
<ul>
<li>对volatile变量执行写操作的时候，会在写操作后面加入一条store屏障指令</li>
<li>对volatile变量执行读操作的时候，会在读操作之前加入一条load屏障指令</li>
</ul>
<blockquote>
<p>前面这两条可以保证缓冲区的内存失效，使得对volatile变量的修改能够获取到最新值；读的时候获取的是最新值</p>
</blockquote>
<p>通俗理解：<br>volatile变量在每次被线程访问的时候，都强迫从主内存<strong>重读</strong>该变量的值，而当该变量改变时，又会强迫线程将最新的值强制刷新到主内存中。这样任何时刻，不同的线程都能看到该变量的最新值</p>
<p><strong>线程写volatile变量的过程</strong></p>
<ol>
<li>改变线程工作内存中volatile变量<strong>副本</strong>的值</li>
<li>将改变后的副本的值从工作内存刷新到主内存中</li>
</ol>
<p><strong>线程读volatile变量的过程</strong></p>
<ol>
<li>从主内存中读取volatile变量的最新值到线程的工作空间</li>
<li>从工作内存中读取volatile变量的副本</li>
</ol>
<h3 id="volatile变量不能实现原子性"><a href="#volatile变量不能实现原子性" class="headerlink" title="volatile变量不能实现原子性"></a>volatile变量不能实现原子性</h3><blockquote>
<p>volatile不能保证volatile变量复合操作的原子性</p>
</blockquote>
<p><strong>原子性：一个或某几个操作只能在一个线程执行完之后，另一个线程才能开始执行该操作，也就是说这些操作是不可分割的，线程不能在这些操作上交替执行</strong></p>
<p>文中的 i++ 包括 3 个操作</p>
<p>读取 i 的值</p>
<p>i 的值 +1 </p>
<p>将 i 赋值给 i</p>
<p>在这 3 个操作中可能会有其他线程开始执行,因此不是原子性的</p>
<p>精辟深刻!!!</p>
<p><strong><code>i++</code>操作的原子性：</strong></p>
<ul>
<li>使用<code>synchronized</code>关键字</li>
<li>使用<code>ReentrantLock</code>(j.u.c.locks包下)</li>
<li>使用<code>AtomicInteger</code></li>
</ul>
<p><strong>volatile使用场合</strong></p>
<p>要在多线程中安全的使用volatile变量，必须同时满足：</p>
<ol>
<li>对变量的写入操作不依赖于当前值</li>
</ol>
<ul>
<li>不满足 i++ count=count*5</li>
<li>满足 boolean</li>
</ul>
<ol start="2">
<li>该变量没有包含在具有其他变量的不变式中</li>
</ol>
<h2 id="synchronized-VS-volatile"><a href="#synchronized-VS-volatile" class="headerlink" title="synchronized VS volatile"></a>synchronized VS volatile</h2><ul>
<li>volatile不需要加锁，比synchronized更轻量级，不会阻塞线程</li>
<li>从内存可见性角度，volatile读相当于加锁，volatile写相当于解锁</li>
<li>synchronized既能保证原子性也能保证可见性，而volatile只能保证可见性，不能保证原子性</li>
</ul>
<blockquote>
<p>共享数据的访问权限都必须定义为private</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/11/JVM——JVM内存结构/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/11/JVM——JVM内存结构/" itemprop="url">JVM——JVM内存结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-11T18:59:27+08:00">
                2019-04-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JVM相关简介"><a href="#JVM相关简介" class="headerlink" title="JVM相关简介"></a>JVM相关简介</h1><ul>
<li><p>JDK: Java Development ToolKit</p>
<p>Java开发工具包，是Java的核心，包括Java运行时环境(JRE)，一堆Java工具（java/javac..)和Java基础的</p>
<p>​    一些类库（Java API 包括rt.jar）</p>
<blockquote>
<p>Java API就是前辈设计好的一些类，比如说我们的IO操作等等</p>
</blockquote>
</li>
<li><p>JRE</p>
<p><code>Java Runtime Enviromental</code>(java运行时环境)，所有的Java程序都要在JRE下才能运行。包括JVM和JAVA核心类库和支持文件。<strong>与JDK相比，它不包含开发工具——编译器、调试器和其它工具。</strong></p>
</li>
<li><p>JVM</p>
<p><code>Java Virtual Mechinal</code>(JAVA虚拟机)。JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ）。类文件的组成包括 JVM 指令集，符号表以及一些补助信息。</p>
</li>
</ul>
<h1 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h1><h2 id="JVM内存组成"><a href="#JVM内存组成" class="headerlink" title="JVM内存组成"></a>JVM内存组成</h2><p><code>堆(Heap)</code>和<code>非堆(Non-heap)</code>内存</p>
<p>按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。可以看出<strong>JVM主要管理两种类型的内存：堆和非堆</strong>。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给 自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法 的代码都在非堆内存中。</p>
<h2 id="JVM内存区域模型"><a href="#JVM内存区域模型" class="headerlink" title="JVM内存区域模型"></a>JVM内存区域模型</h2><p>我们接下来的内容，尽可能地统一为Java 8</p>
<blockquote>
<p>首先要注意Java 8是没有永久代的，是被官方移除了</p>
</blockquote>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture191.png" alt=""></p>
<p>看了上图瞬间一目了然</p>
<h3 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h3><h4 id="程序计数器（Program-Center-Register"><a href="#程序计数器（Program-Center-Register" class="headerlink" title="程序计数器（Program Center Register)"></a>程序计数器（Program Center Register)</h4><ul>
<li><p>当前线程所执行的字节码行号指示器（逻辑）</p>
<blockquote>
<p>程序计数器，是逻辑计数器，不是物理计数器</p>
</blockquote>
</li>
</ul>
<ul>
<li>改变计数器的值来选取下一条需要执行的字节码指令</li>
</ul>
<ul>
<li>和线程是一对一的关系，即线程私有</li>
</ul>
<blockquote>
<p>每一个线程拥有一个独立的程序计数器；每个线程的程序计数器都是独立的，即互不影响</p>
</blockquote>
<ul>
<li>只对Java方法计数，如果是Native方法则计数值则为Undefined</li>
<li>不会发生内存泄漏</li>
</ul>
<h4 id="Java虚拟机栈-Stack"><a href="#Java虚拟机栈-Stack" class="headerlink" title="Java虚拟机栈(Stack)"></a>Java虚拟机栈(Stack)</h4><ul>
<li><p>Java方法执行的内存模型</p>
</li>
<li><p>包含多个帧栈</p>
<blockquote>
<p>每个方法执行时，都会创建一个栈帧</p>
</blockquote>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture192.png" alt=""></p>
</li>
</ul>
<blockquote>
<p>局部变量表和操作数栈</p>
</blockquote>
<ul>
<li>局部变量表：包含方法执行过程中的所有变量</li>
<li>操作数栈：入栈，出栈，复制，交换，产生消费变量</li>
</ul>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture193.png" alt=""></p>
<blockquote>
<p>递归为什么会引发Java.lang.StackOverflowError错误</p>
</blockquote>
<p>递归过深，栈帧数超出虚拟机深度</p>
<blockquote>
<p>虚拟机栈过多会引发Java.lang.OutOfMemeroyError错误</p>
</blockquote>
<blockquote>
<p>Java方法执行的时候，会生成一个栈帧，方法执行完了会回收这个栈帧，这个回收过程是自动的，无需GC来操作</p>
</blockquote>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><ul>
<li>与虚拟机栈类似，主要作用于标注了native的方法</li>
</ul>
<h3 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h3><h4 id="MetaSpace元空间"><a href="#MetaSpace元空间" class="headerlink" title="MetaSpace元空间"></a>MetaSpace元空间</h4><ol>
<li><p>元空间(MetaSpace)与永久代(PermGen)的区别</p>
<blockquote>
<p>元空间使用本地内存，而永久代使用的是JVM的内存</p>
</blockquote>
</li>
<li><p>MetaSpace相对于PermGen的优势</p>
<ul>
<li>字符串常量池存在永久代中，容易出现性能问题和内存溢出</li>
<li>类和方法的信息大小难以确定，给永久代的大小指定带来困难</li>
<li>永久代会为GC带来不必要的复杂性</li>
<li>方便HotSpot与其他JVM如Jrockit的集成</li>
</ul>
</li>
</ol>
<h4 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h4><ul>
<li><p>对象实例的分配区域</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture194.png" alt=""></p>
</li>
<li><p>GC管理的主要区域</p>
</li>
</ul>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture195.png" alt=""></p>
<blockquote>
<p>这里我们再补充一张图来加深理解</p>
</blockquote>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/v2-622b2ed9e429e2d65a9def2ef5a23f1e_hd.jpg" alt=""></p>
<ul>
<li><p>方法区：存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。(线程共享)</p>
</li>
<li><p>栈区：</p>
<ol>
<li><p><strong>每个线程包含一个栈区</strong>，栈中只保存方法中（不包括对象的成员变量）的<strong>基础数据类型和自定义对象的引用(不是对象)</strong>，对象都存放在堆区中</p>
</li>
<li><p>每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。</p>
</li>
<li><p>栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)</p>
</li>
</ol>
</li>
<li><p>堆区:</p>
<ol>
<li>存储的全部是对象实例，每个对象都包含一个与之对应的class的信息(class信息存放在方法区)。</li>
<li><strong>jvm只有一个堆区(heap)被所有线程共享</strong>，堆中不存放基本类型和对象引用，只存放对象本身，几乎所有的<strong>对象实例和数组</strong>都在堆中分配。</li>
</ol>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/11/Spring-MVC源码初探（十一）-MultipartResolver/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/11/Spring-MVC源码初探（十一）-MultipartResolver/" itemprop="url">Spring MVC源码初探（十一） MultipartResolver</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-11T16:13:49+08:00">
                2019-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-MVC/" itemprop="url" rel="index">
                    <span itemprop="name">Spring MVC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>MultipartResolver</code>是用来处理上传请求的一个接口，我们看下接口中的方法：</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture306.png" alt=""></p>
<p>它有两个子类：<code>StandardServletMultipartResolver</code>和<code>CommonsMultipartResolver</code>，前者采用Servlet的</p>
<p>标准上传方式，后者采用的是Apache的commons-fileupload，我们接着就看一下这两个子类</p>
<h1 id="StandardServletMultipartResolver"><a href="#StandardServletMultipartResolver" class="headerlink" title="StandardServletMultipartResolver"></a>StandardServletMultipartResolver</h1><h2 id="isMultipart"><a href="#isMultipart" class="headerlink" title="isMultipart()"></a>isMultipart()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMultipart</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> StringUtils.startsWithIgnoreCase(request.getContentType(), <span class="string">"multipart/"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里判断是否是上传请求的方式，很简单，判断<code>contentType</code>是不是以<code>multipart/</code>开头</p>
</blockquote>
<h2 id="resolveMultipart"><a href="#resolveMultipart" class="headerlink" title="resolveMultipart()"></a>resolveMultipart()</h2><p>该方法是将<code>HttpServletRequest</code>转化成<code>MultipartHttpServletRequest</code>这样的一个上传请求，这个类</p>
<p>就是直接new了一个<code>StandardMultipartHttpServletRequest</code>对象，实现的比较简单。</p>
<h2 id="cleanupMultipart"><a href="#cleanupMultipart" class="headerlink" title="cleanupMultipart()"></a>cleanupMultipart()</h2><p>该方法是在处理完上传请求后将<strong>缓存</strong>进行清除，相对来说逻辑也比较简单容易理解。</p>
<blockquote>
<p>我们需要留意一下StandardMultipartHttpServletRequest#parseRequest方法，它主要是根据请求获取不同的<code>Part</code>（也就是上传部分的集合），然后使用它们来创建File并设置属性。</p>
</blockquote>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture307.png" alt=""></p>
<p>​    根据我对上述三个方法的理解，真正去处理上传请求，是在解析出的上传请求对象中的方法中来完成的，比如<code>parseRequest()</code>方法进行了文件的创建。</p>
<h1 id="CommonsMultipartResolver"><a href="#CommonsMultipartResolver" class="headerlink" title="CommonsMultipartResolver"></a>CommonsMultipartResolver</h1><p><code>CommonsMultipartResolver</code>是采用的Apache的<code>commons-fileupload</code>来进行文件上传的，这个类主要是依赖</p>
<p>于<code>commons-fileupload</code>来完成一些具体的操作。</p>
<h2 id="isMultipart-1"><a href="#isMultipart-1" class="headerlink" title="isMultipart()"></a>isMultipart()</h2><p>它是通过<code>commons-fileupload</code>中的<code>ServletFileUpload#isMultipartContent()</code>来判断是否是上传请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMultipart</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> ServletFileUpload.isMultipartContent(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture308.png" alt=""></p>
<p>首先它会判断是不是POST请求，不是直接返回false；如果是POST请求，则去调用下一个方法来判断是否是上传请求。</p>
<h2 id="resolveMultipart-1"><a href="#resolveMultipart-1" class="headerlink" title="resolveMultipart()"></a>resolveMultipart()</h2><p>它是根据<code>resolveLazily</code>来分类来返回一个上传请求对象， 默认<code>resolveLazily</code>是false</p>
<p>两种逻辑不变的是都采用 <code>parseRequest(request)</code>方法来返回<code>MultipartParsingResult</code>对象，</p>
<blockquote>
<p>不同的是resolveLazily==true，是不将MultipartParsingResult中的属性封装给MultipartHttpServletRequest返回</p>
<p>的；而另一种情况是需要将MultipartParsingResult的属性封装给MultipartHttpServletRequest并且返回。</p>
</blockquote>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture309.png" alt=""></p>
<h2 id="cleanupMultipart-1"><a href="#cleanupMultipart-1" class="headerlink" title="cleanupMultipart()"></a>cleanupMultipart()</h2><p>这个是清理处理请求过程中产生的<code>MultiValueMap&lt;String, MultipartFile&gt;</code>对象</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture310.png" alt=""></p>
<blockquote>
<p><code>#cleanupFileIterms()</code></p>
</blockquote>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture310.png" alt=""></p>
<blockquote>
<p>这个就很容易理解，类似于ffmpeg处理音视频的时候，处理完了，就会将一些内存碎片给清除了，一样的道理。</p>
</blockquote>
<h2 id="parseRequest"><a href="#parseRequest" class="headerlink" title="parseRequest()"></a>parseRequest()</h2><p>这个是具体进行文件上传逻辑的代码，主要是通过<code>commons-uploadfile</code>中的<code>FileUpload</code>组件解析出</p>
<p><code>fileItems</code>，然后再调用<code>parseFileItems</code>方法将<code>fileItems</code>分为文件和参数两类，并设置到对应的三个</p>
<p>Map中。</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture312.png" alt=""></p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture313.png" alt=""></p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture314.png" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    其实MultipartResolver的话，本身的设计就是为了将上传请求封装成可以直接获取File的request，然后再进行文件的上传处理。</p>
<p>​    我们到这里对于Spring MVC的大部分源码进行了基本的分析和总结，所以有了Spring MVC源码初探系列的11篇博客，这个过程有收获，也有不足的地方，没有进行更深入的探讨；但是到这里，我觉得整个系列的目的已经达到了，那就是先入门一个优秀框架的源码，适当做一些理解，并根据参考书去领悟源码设计的精妙。希望以后可以更深入得对其他更多优秀框架的源码做一些更深入的理解。</p>
<p>​    总之，Time Walker始终在路上前进，继续看美丽的代码风景。很喜欢比较酷的一个结尾，是吴承恩《西游记》的第100回，“至此，西游记完”。此时，我也想说，至此，该系列完结，继续加油！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/10/Spring-MVC源码初探（十）-HandlerExceptionResolver/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/10/Spring-MVC源码初探（十）-HandlerExceptionResolver/" itemprop="url">Spring MVC源码初探（十） HandlerExceptionResolver</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-10T20:05:26+08:00">
                2019-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-MVC/" itemprop="url" rel="index">
                    <span itemprop="name">Spring MVC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​    </p>
<p>​    之前一直拖延了很久，终于下决心把Spring MVC的这个系列更新完，这是倒数第二篇，主要看下 <code>HandlerExceptionResolver</code>这部分的主要原理。</p>
<p>​     <code>HandlerExceptionResolver</code>用于解析请求处理过程中产生的异常，简而言之，就是去解析异常</p>
<p>​    </p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture297.png" alt=""></p>
<p># </p>
<p>我们看到整个HandlerExceptionResolver体系依然是从HandlerExceptionResolver接口开始不断拓展的，该接口提供了</p>
<p>一个<code>#resolverException</code>()方法，去解析异常信息，并返回<code>ModelAndView</code>对象。</p>
<p>实现HandlerExceptionResolver接口的抽象类是<code>AbstractHandlerExceptionResolver</code>，这是对接口的第一步扩</p>
<p>展，有了AbstractHandlerExceptionResolver抽象类后，我们可以进一步去扩展。</p>
<p><code>AbstractHandlerExceptionResolver</code>有四个子类，分别如下：</p>
<ul>
<li><p><code>AbstractHandlerMethodExceptionResolver</code>      </p>
<blockquote>
<p> 和它的子类<code>ExceptionHandlerExceptionResolver</code>一起完成使用<code>@ExceptionHandler</code>注解的方法进行异常解析的功能</p>
</blockquote>
</li>
<li><p><code>DefaultHandlerExceptionResolver</code>        </p>
<blockquote>
<p>按照不同类型对异常进行解析</p>
</blockquote>
</li>
<li><p><code>ResponseStatusExceptionResolver</code></p>
<blockquote>
<p>解析有<code>@ResponseStatus</code>注解类型的异常</p>
</blockquote>
</li>
<li><p><code>SimpleMappingExceptionResolver</code></p>
<blockquote>
<p>通过配置的异常类和<code>view</code>的关系来解析异常</p>
</blockquote>
</li>
</ul>
<p>其实异常解析的过程，主要是两件事：</p>
<ol>
<li>给<code>ModelAndView</code>设置相应的内容</li>
<li>设置<code>response</code>的相关属性</li>
</ol>
<p>当然，也会有一些记录日志的辅助功能等等。</p>
<h1 id="AbstractHandlerExceptionResolver"><a href="#AbstractHandlerExceptionResolver" class="headerlink" title="AbstractHandlerExceptionResolver"></a>AbstractHandlerExceptionResolver</h1><p><code>AbstractHandlerExceptionResolver</code>是该体系中最核心的一个类，它重写了父接口的</p>
<p><code>resolverException</code>()方法，定义了其中的通用代码和一些空的模块方法，子类只要去重写这些模板方法就OK了。</p>
<p> 我们需要留意下<code>resolverException</code>()方法</p>
<p>​    <img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture298.png" alt=""></p>
<p>基本流程很容易就看懂，主要是有一个<code>doResolveException(…)</code>方法交给子类去实现，它是模板方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ModelAndView <span class="title">doResolveException</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable Object handler, Exception ex)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="AbstractHandlerMethodExceptionResolver"><a href="#AbstractHandlerMethodExceptionResolver" class="headerlink" title="AbstractHandlerMethodExceptionResolver"></a>AbstractHandlerMethodExceptionResolver</h1><p><code>AbstractHandlerMethodExceptionResolver</code>是继承自<code>AbstractHandlerExceptionResolver</code>的抽象类，</p>
<p>它主要重写了父类的<code>shouldApply(）</code>方法，并且象征性的重写了<code>doResolveException()</code>，其中就是又保证</p>
<p>了一个模板方法，交给<code>AbstractHandlerMethodExceptionResolver</code>的子类来完成。</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture299.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ModelAndView <span class="title">doResolveHandlerMethodException</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">		HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">           @Nullable HandlerMethod handlerMethod, Exception ex)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="ExceptionHandlerExceptionResolver"><a href="#ExceptionHandlerExceptionResolver" class="headerlink" title="ExceptionHandlerExceptionResolver"></a>ExceptionHandlerExceptionResolver</h2><p>接下来就看一下<code>ExceptionHandlerExceptionResolver</code>这个子类是如何重写</p>
<p><code>doResolveHandlerMethodException</code>方法的。</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture300.png" alt=""></p>
<p>……</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行ExceptionHandler方法解析异常</span></span><br><span class="line">exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, cause, handlerMethod);</span><br></pre></td></tr></table></figure>
<p>…</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture301.png" alt=""></p>
<h1 id="DefaultHandlerExceptionResolver"><a href="#DefaultHandlerExceptionResolver" class="headerlink" title="DefaultHandlerExceptionResolver"></a>DefaultHandlerExceptionResolver</h1><p><code>DefaultHandlerExceptionResolver</code>是根据异常类型的不同，使用不同的方法进行处理，有这句话，就不用看</p>
<p><code>doResolveException</code>方法的具体逻辑了，其中也包含对<code>response</code>的属性进行了设置，这里也就补贴代码了。</p>
<h1 id="ResponseStatusExceptionResolver"><a href="#ResponseStatusExceptionResolver" class="headerlink" title="ResponseStatusExceptionResolver"></a>ResponseStatusExceptionResolver</h1><p><code>ResponseStatusExceptionResolver</code>解析注解了<code>@ResponseStatus</code>的异常，例如自定义的注解了</p>
<p><code>@ReponseStatus</code>的异常。</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture302.png" alt=""></p>
<blockquote>
<p>该方法主要就是获取<code>@ResponseStatus</code>注解，然后再调用<code>resolveResponseStatus()</code>来解析异常。</p>
</blockquote>
<h1 id="SimpleMappingExceptionResolver"><a href="#SimpleMappingExceptionResolver" class="headerlink" title="SimpleMappingExceptionResolver"></a>SimpleMappingExceptionResolver</h1><p><code>SimpleMappingExceptionResolver</code>是最后一个异常解析类了，我们继续看一下。</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture303.png" alt=""></p>
<p>这个里面看一下<code>determineStatusCode()</code>方法：</p>
<p><code>private Map&lt;String, Integer&gt; statusCodes = new HashMap&lt;&gt;();</code></p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture304.png" alt=""></p>
<blockquote>
<p>这个就是拿HashMap来判断viewName和statusCode之间有没有映射关系</p>
</blockquote>
<p>如果<code>statusCode</code>不为空，则设置response的属性</p>
<p>接着便调用<code>getModelAndView()</code>方法，返回ModelAndView对象</p>
<p>至此，<code>doResolveException</code>的使命已经完成</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture305.png" alt=""></p>
<p>根据上图，我们的全局异常处理，一般采用的应该是<code>ExceptionHandlerExceptionResolver</code>中的异常解析机</p>
<p>制，因为全局异常处理，一般都采用<code>@ControllerAdvice</code>注解</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘天霸</p>
              <p class="site-description motion-element" itemprop="description">Java学习记录博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘天霸</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
