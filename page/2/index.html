<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="时间旅行者" type="application/atom+xml">






<meta name="description" content="Java学习记录博客">
<meta property="og:type" content="website">
<meta property="og:title" content="时间旅行者">
<meta property="og:url" content="https://www.liutianruo.com/page/2/index.html">
<meta property="og:site_name" content="时间旅行者">
<meta property="og:description" content="Java学习记录博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="时间旅行者">
<meta name="twitter:description" content="Java学习记录博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.liutianruo.com/page/2/">





  <title>时间旅行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">时间旅行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-categories"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/25/1.入门Kafka/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/25/1.入门Kafka/" itemprop="url">1.入门Kafka</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-25T12:20:56+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Kafka的基本知识"><a href="#Kafka的基本知识" class="headerlink" title="Kafka的基本知识"></a>Kafka的基本知识</h1><blockquote>
<p>Kafka是一个多分区，多副本且基于Zookeeper协调的分布式消息系统。</p>
</blockquote>
<h2 id="消息系统"><a href="#消息系统" class="headerlink" title="消息系统"></a>消息系统</h2><p>一个消息系统负责将消息从一个应用传递到另一个应用，应用只需要关注数据，而不需要关注数据在两个应用之间如何传递。</p>
<ul>
<li><p>点对点消息系统</p>
<blockquote>
<p>消息发布者往消息队列中写入消息，消息接收者不停从消息队列中取消息</p>
</blockquote>
</li>
<li><p>发布订阅消息系统</p>
<blockquote>
<p>消息被持久化到一个<code>Topic</code>当中，消费者可以订阅一个或多个<code>Topic</code>;</p>
<p>消息被消费后不会立马被删除</p>
</blockquote>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture325.png" alt=""></p>
</li>
</ul>
<blockquote>
<p>消息系统具有系统解耦，冗余存储，流量削峰，缓冲，异步通信，扩展性，可恢复性等功能。</p>
</blockquote>
<h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><p>Kafka把消息持久化到磁盘，相较于基于内存存储的系统，降低了数据丢失的风险。</p>
<h2 id="Kafka基本概念"><a href="#Kafka基本概念" class="headerlink" title="Kafka基本概念"></a>Kafka基本概念</h2><p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture326.png" alt=""></p>
<p>producer往Topics中写入消息，consumer从Brokers中拿取producer写的消息副本数据。</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture328.png" alt=""></p>
<p>​                                                        <strong>[ Kafka体系结构 ]</strong></p>
<p>​    一个典型的Kafka架构包括若干个<code>Producer</code>,若干个<code>Broker</code>,若干<code>Consumer</code>和一个<code>ZooKeeper</code>集群。</p>
<ul>
<li><code>Producer</code>将消息发送给<code>Broker</code></li>
<li><code>Broker</code>负责将收到的消息保存到磁盘</li>
<li><code>Consumer</code>负责从<code>Broker</code>订阅并消费信息</li>
</ul>
<p><strong>详细解释</strong></p>
<h3 id="Broker：服务代理节点。"><a href="#Broker：服务代理节点。" class="headerlink" title="Broker：服务代理节点。"></a><code>Broker</code>：服务代理节点。</h3><blockquote>
<p>Broker 可以简单地看作一个独立的 Kafka服务节点或 Kafka 服务实例。</p>
<p>大多数情况下也可以将 Broker 看作一台 Kafka 服务器，前提是这台服务器上只部署了一个 Kafka 实例。</p>
<p>一个或多个 Broker 组成了 一个 Kafka 集群。</p>
<p>一般而言，我们更习惯使用首字母小写的 broker 来表示服务代理节点 。 </p>
</blockquote>
<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p><code>Topic</code></p>
<p>Kafka中的消息以主题为单位进行归类，生产者负责将消息发送到特定的主题，而消费者负责订阅主题并消费消息。</p>
<blockquote>
<p>发送到Kafka集群中的每一条消息都要指定主题</p>
</blockquote>
<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p><code>Partition</code></p>
<p>主题是一个逻辑上的概念，它可以细分为多个分区。这样来说，一个分区只属于一个主题。</p>
<p>同一个主题下面的不同分区包含的消息是不同的。</p>
<blockquote>
<p>分区在存储层面可以看作一个可追加的日志（ Log ）文件，消息在被追加到分区日志、文件的时<br>候都会分配一个特定的偏移量（ offset ）。offset 是消息在分区中的唯一标识， Kafka 通过它来保证消息在分区内的顺序性，不过 offset 并不跨越分区，也就是说， Kafka 保证的是分区有序而不 是主题有序。 </p>
</blockquote>
<p>我们跟着图理一下：</p>
<blockquote>
<p>主题中有 4 个分区，消息被顺序追加到每个分区日志文件的尾部。</p>
<p> Kafka中的分区可以分布在不同的服务器 （ broker）上，也就是说，一个主题可以横跨多个 broker，以<br>此来提供比单个 broker 更强大的性能 。 </p>
</blockquote>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture329.png" alt=""></p>
<p>每一条消息被发送到 <code>broker</code>之前，会根据<strong>分区规则</strong>选择存储到哪个具体的分区 。 如果分区规则设定得合理，所有的消息都可以均匀地分配到不同的分区中 。 如果一个主题只对应一个文<br>件，那么这个文件所在的机器 I/O 将会成为这个主题的性能瓶颈，而分区解决了这个问题 。 在创建主题的时候可以通过指定的参数来设置分区的个数，当然也可以在主题创建完成之后去修改分区的数量，通过增加分区的数量可以实现水平扩展。</p>
<h4 id="多副本机制"><a href="#多副本机制" class="headerlink" title="多副本机制"></a>多副本机制</h4><p>Kafka为了分区引入了多副本机制 ,通过增加副本数量来提升容灾能力。同一分区的不同副本中保存的是相同的消息（在同一时刻，副本之间并非完全一样），副本之间是“ 一主多从”的关系，其中 leader 副本负 责处理读写请求 ， follower 副本只负 责与 lead er 副本的消息同步。副本处于不同的 broker 中 ，当 leader 副本出现故障时，从 follower 副本中重新选举新的 leader 副本对外提供服务。 Kafka 通过多副本机制实现了故障的自动转移，当 Kafka 集群中某个 broker 失效时仍然能保证服务可用 。 </p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture330.png" alt=""></p>
<blockquote>
<p>就是保存副本，使得有一个Broker宕机，也不会影响整个Kafka集群丢失消息。</p>
</blockquote>
<p>该Kafka 集群中有 4 个 broker，某个主题中有 3 个分区，且副本因子（即副本个数〉也为 3 ，如此每个分区便有 l 个 leader 副本和 2 个 follower 副本。生产者和消费者只与 leader副本进行交互，而 follow 副本只负责消息的同步，很多时候 follower 副本中的消息相对 leader副本而言会有一定的滞后。 </p>
<h3 id="Kafka消费端的容灾"><a href="#Kafka消费端的容灾" class="headerlink" title="Kafka消费端的容灾"></a>Kafka消费端的容灾</h3><p>Consumer采用<code>pull</code>的方式从服务端拉取消息，并且保存消费的具体位置。当消费者宕机后恢复上线了，可以根据之前保存的消费的具体位置重新拉取需要的消息进行消费，这样就不会造出消息的丢失。</p>
<blockquote>
<p>消费端宕机重启后，仍能从上一次消费位置开始继续消费。</p>
</blockquote>
<h3 id="AR-ISR"><a href="#AR-ISR" class="headerlink" title="AR ISR"></a>AR ISR</h3><p>分区中 的所有副本统称为 AR ( Assigned Replicas ） 。 所有与 leader 副本保持一定程度同步<br>的副本（包括 leader 副本在内〕组成 ISR On-Sync Replicas ) , ISR 集合是 AR 集合中 的一个子集 。<br>消息会先发送到 <code>leader</code> 副本，然后<code>follower</code> 副本才能从 leader 副本中拉取消息进行同步，同步期间内 <code>follower</code>副本相对于<code>leader</code> 副本而言会有一定程度的滞后 。 前面所说的“一定程度的同步”是指可忍受的滞后范围，这个范围可以通过参数进行配置 。 与 leader 副本同步滞后过多的副本（不包括 leader 副本）组成 OSR ( Out-of-Sync Replicas ），由此可见， AR=ISR+OSR 。在正常情况下， 所有的 follower 副本都应该与 leader 副本保持一定程度 的同步，即 AR=ISR,OSR 集合为空。 </p>
<p><code>leader</code> 副本负责维护和跟踪 <code>ISR</code>集合中所有<code>followe</code> 副 本 的滞后状态， 当 <code>follower</code> 副本落后太多或失效时， leader 副本会把它从 ISR 集合中剔除 。 如果 OSR 集合中有 <code>follower</code>副本 “追上“了 leader 副本，那么 leader 副本会把它从 OSR 集合转移至 ISR 集合 。默认情况下， 当 <code>leader</code> 副本发生故障时，只 有在 ISR 集合中的副本才有资格被选举为新的<code>leader</code>， 而在 OSR 集合中的副本则没有任何机会（不过这个原则也可以通过修改相应的参数配置来改变） 。 </p>
<h1 id="Kafka的安装与配置"><a href="#Kafka的安装与配置" class="headerlink" title="Kafka的安装与配置"></a>Kafka的安装与配置</h1><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>首先需要安装JDK，配置环境变量。我们选择的是JDK8。安装过程略去。</p>
<h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><p><code>ZooKeeper</code>集群中有三个角色，<code>leader</code>,<code>follower</code>和<code>observer</code>。一个<code>leader</code>，其他的都是 <code>follower</code> 和 <code>obsever</code>。</p>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#broker的编号，如果集群中有多个broker，则每个broker的编号需要设置的不同</span><br><span class="line">broker.id=0</span><br><span class="line">#broker对外提供的服务入口地址</span><br><span class="line">listeners=PLAINTEXT://localhost：9092 </span><br><span class="line">#存放消息日志文件的地址</span><br><span class="line">log.dirs=/tmp/kafka-logs</span><br><span class="line">#Kafka所需的ZooKeeper集群地址，为了方便演示，我们假设Kafka和ZooKeeper都安装在本机	</span><br><span class="line">zookeeper.connect=localhost：2181/kafka</span><br></pre></td></tr></table></figure>
<h1 id="Kafka的运行"><a href="#Kafka的运行" class="headerlink" title="Kafka的运行"></a>Kafka的运行</h1><p>这里主要介绍Windows平台的命令行启动和创建Topic等指令。</p>
<p>1、启动zookeeper</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bin</span>\<span class="selector-tag">windows</span>\<span class="selector-tag">zookeeper-server-start</span><span class="selector-class">.bat</span> <span class="selector-tag">config</span>\<span class="selector-tag">zookeeper</span><span class="selector-class">.properties</span></span><br></pre></td></tr></table></figure>
<p>​      2、启动kafka</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bin</span>\<span class="selector-tag">windows</span>\<span class="selector-tag">kafka-server-start</span><span class="selector-class">.bat</span> <span class="selector-tag">config</span>\<span class="selector-tag">server</span><span class="selector-class">.properties</span></span><br></pre></td></tr></table></figure>
<p>​      3、创建主题topic，topic = test</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bin</span>\<span class="selector-tag">windows</span>\<span class="selector-tag">kafka-topics</span><span class="selector-class">.bat</span> <span class="selector-tag">--create</span> <span class="selector-tag">--zookeeper</span> <span class="selector-tag">localhost</span><span class="selector-pseudo">:2181</span> <span class="selector-tag">--replication-factor</span> 1 <span class="selector-tag">--partitions</span> 1 <span class="selector-tag">--topic</span> <span class="selector-tag">test</span></span><br></pre></td></tr></table></figure>
<p>– 查看创建的topic</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bin</span>\<span class="selector-tag">windows</span>\<span class="selector-tag">kafka-topics</span><span class="selector-class">.bat</span> <span class="selector-tag">--list</span> <span class="selector-tag">--zookeeper</span> <span class="selector-tag">localhost</span><span class="selector-pseudo">:2181</span></span><br></pre></td></tr></table></figure>
<p>​      4、启动生产者 producer</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bin</span>\<span class="selector-tag">windows</span>\<span class="selector-tag">kafka-console-producer</span><span class="selector-class">.bat</span> <span class="selector-tag">--broker-list</span> <span class="selector-tag">localhost</span><span class="selector-pseudo">:9092</span> <span class="selector-tag">--topic</span> <span class="selector-tag">test</span></span><br></pre></td></tr></table></figure>
<p>启动生产者之后进入编辑页面，发送了 “nihao”，</p>
<p>​       5、启动消费者 customer</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bin</span>\<span class="selector-tag">windows</span>\<span class="selector-tag">kafka-console-consumer</span><span class="selector-class">.bat</span> <span class="selector-tag">--bootstrap-server</span> <span class="selector-tag">localhost</span><span class="selector-pseudo">:9092</span> <span class="selector-tag">--topic</span> <span class="selector-tag">test</span> <span class="selector-tag">--from-beginning</span></span><br></pre></td></tr></table></figure>
<p>当消费者启动之后，收到了之前生产者发送的 “nihao”。</p>
<p>PS: 这里附上Kafka的一些常用命令。（Linux)</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture327.png" alt=""></p>
<p>​    </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/17/MySQL-Binlog/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/17/MySQL-Binlog/" itemprop="url">MySQL Binlog</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-17T09:55:56+08:00">
                2019-04-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是Binlog"><a href="#什么是Binlog" class="headerlink" title="什么是Binlog"></a>什么是Binlog</h1><p>二进制日志，记录对数据发生或潜在发生更改的SQL语句，并以二进制形式保存到磁盘中</p>
<blockquote>
<p>日常开发是必须打开Binlog的，没有Binlog无法实现主从同步。</p>
</blockquote>
<h1 id="Binlog的作用"><a href="#Binlog的作用" class="headerlink" title="Binlog的作用"></a>Binlog的作用</h1><ul>
<li><p>复制</p>
<blockquote>
<p>master同步到slave，就是借助了Binlog</p>
</blockquote>
</li>
<li><p>恢复</p>
<blockquote>
<p>通过mysqlbinlog工具去恢复数据</p>
</blockquote>
</li>
<li><p>增量备份</p>
</li>
</ul>
<h1 id="Binlog相关的变量"><a href="#Binlog相关的变量" class="headerlink" title="Binlog相关的变量"></a>Binlog相关的变量</h1><table>
<thead>
<tr>
<th style="text-align:center">变量名称</th>
<th style="text-align:center">变量含义</th>
<th style="text-align:center">相关语句</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">log_bin</td>
<td style="text-align:center">Binlog开关</td>
<td style="text-align:center">查看变量：show variables like ‘log_bin’</td>
</tr>
<tr>
<td style="text-align:center">binglog_format</td>
<td style="text-align:center">Binlog日志格式</td>
<td style="text-align:center">查看变量 : show variables like ‘binlog_format’</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'log_bin';</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| log_bin       | OFF   |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'binlog_format'</span>;</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| binlog_format | ROW   |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span></span><br></pre></td></tr></table></figure>
<h1 id="Binlog日志的三种格式"><a href="#Binlog日志的三种格式" class="headerlink" title="Binlog日志的三种格式"></a>Binlog日志的三种格式</h1><table>
<thead>
<tr>
<th style="text-align:center">格式类型</th>
<th style="text-align:center">格式特性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ROW</td>
<td style="text-align:center">仅保存记录被修改细节，不记录SQL语句上下文相关信息</td>
</tr>
<tr>
<td style="text-align:center">STATEMENT</td>
<td style="text-align:center">每一条会修改的SQL都会记录在Binlog中</td>
</tr>
<tr>
<td style="text-align:center">MIXED</td>
<td style="text-align:center">ROW/STATEMENT混合使用</td>
</tr>
</tbody>
</table>
<ul>
<li><p>ROW：使得Binlog文件变得很大</p>
<blockquote>
<p>非常清晰的记录下每行数据的修改细节，不需要记录SQL语句上下文信息，因此不会发生特定情况下的procedure,function及trigger的调用触发无法被正确复制的问题，任何情况都可以被复制，且能加快从库重放日志的效率，保证从库数据的一致性</p>
</blockquote>
</li>
<li><p>STATEMENT : 会记录SQL语句的上下文信息，但是不支持函数等数据</p>
<blockquote>
<p>我之前的商铺项目，就是采用的STAMEMENT来进行主从同步的，这样不用记录每一行数据的变化，只需要记录执行语句的细节和上下文环境；</p>
<p>在一些修改记录比较多的情况下比ROW类型大大减少日志量，节约IO，提升性能；还可以用于实时的还原，同时主从版本不一样，从服务器版本可以比主服务器版本高，这样主库的SQL,从库执行起来不会出错。</p>
</blockquote>
</li>
<li><p>MIXED</p>
<p>以上两种类型各有优势</p>
</li>
</ul>
<h1 id="管理Binlog相关的语句"><a href="#管理Binlog相关的语句" class="headerlink" title="管理Binlog相关的语句"></a>管理Binlog相关的语句</h1><table>
<thead>
<tr>
<th style="text-align:center">SQL语句</th>
<th style="text-align:center">语句含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">show master logs;</td>
<td style="text-align:center">查看所有的Binlog日志列表</td>
</tr>
<tr>
<td style="text-align:center">show master status;</td>
<td style="text-align:center">查看最后一个Binlog日志的编号名称，及最后一个文件结束的位置（POS)</td>
</tr>
<tr>
<td style="text-align:center">flush logs;</td>
<td style="text-align:center">刷新Binlog，此刻开始产生一个新编号的Binlog日志文件</td>
</tr>
<tr>
<td style="text-align:center">reset master;</td>
<td style="text-align:center">清空所有的Binlog日志</td>
</tr>
</tbody>
</table>
<h1 id="查看Binlog相关的SQL语句"><a href="#查看Binlog相关的SQL语句" class="headerlink" title="查看Binlog相关的SQL语句"></a>查看Binlog相关的SQL语句</h1><table>
<thead>
<tr>
<th style="text-align:left">SQL语句</th>
<th style="text-align:left">语句含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">show binlog events;</td>
<td style="text-align:left">查看第一个Binlog日志</td>
</tr>
<tr>
<td style="text-align:left">show binlog events in ‘binlog.000030’;</td>
<td style="text-align:left">查看指定的Binlog日志</td>
</tr>
<tr>
<td style="text-align:left">show binlog events in ‘binlog.000030’ from 931;</td>
<td style="text-align:left">从指定的位置开始，查看指定的Binlog日志</td>
</tr>
<tr>
<td style="text-align:left">show binlog events in ‘binlog.0000030’ from 931 limit 2;</td>
<td style="text-align:left">从指定的位置开始，查看指定的Binlog日志，限制查询的条数</td>
</tr>
<tr>
<td style="text-align:left">show binlog events in ‘binlog.0000030’ from 931 limit 1,2;</td>
<td style="text-align:left">从指定的位置开始，带有偏移，查看指定的Binlog日志，限制查询的条数</td>
</tr>
</tbody>
</table>
<p>show binlog events in ‘binlog_file_name’  from position  limit offset,rowcount;</p>
<h1 id="Binlog中的Event-type"><a href="#Binlog中的Event-type" class="headerlink" title="Binlog中的Event_type"></a>Binlog中的Event_type</h1><ol>
<li>QUERY_EVENT ：与数据无关的操作，begin,drop table,truncate table</li>
<li><strong><code>TABLE_MAP_EVENT</code></strong>：记录下一个操作所对应的表信息，存储了数据库名和表名</li>
<li>XID_EVENT ：标记事务提交</li>
</ol>
<p><strong><code>WRITE_ROWS_EVENT</code></strong>     插入数据，insert操作</p>
<p><strong><code>UPDATE_ROWS_EVENT</code></strong>   更新数据，update操作</p>
<p><strong><code>DELETE_ROWS_EVENT</code></strong>   删除数据，delete操作</p>
<blockquote>
<p>Event_type的介绍基于MySQL 8.0</p>
</blockquote>
<p>注意：我们在实际应用中要搞明白binlog的Event</p>
<blockquote>
<p>每个Event包含header和data部分；header提供了Event的创建时间，哪个服务器等信息，data部分提供的针对该Event的具体信息，如具体数据的修改。</p>
</blockquote>
<p><strong>我们对Binlog的解析，就是对Event的解析</strong></p>
<blockquote>
<p>Binlog中不会打印数据表的列名。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/15/设计模式概述/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/15/设计模式概述/" itemprop="url">设计模式概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-15T16:36:15+08:00">
                2019-04-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文系转载自hollis，作为设计模式学习的一篇文章。<br><a href="https://www.hollischuang.com/archives/1368" target="_blank" rel="noopener">原文地址</a></p>
<hr>
<p>在软件工程中，设计模式（design pattern）是对软件设计中普遍存在的各种问题，所提出的解决方案。设计模式并不是固定的一套代码，而是针对某一特定问题的具体解决思路与方案。可以认为是一种最佳实践，因为他是无数软件开发人员经过长时间的实践总结出来的。</p>
<h1 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h1><h3 id="1、开闭原则（Open-Close-Principle）"><a href="#1、开闭原则（Open-Close-Principle）" class="headerlink" title="1、开闭原则（Open Close Principle）"></a>1、开闭原则（Open Close Principle）</h3><p>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<h3 id="2、里氏代换原则（Liskov-Substitution-Principle）"><a href="#2、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏代换原则（Liskov Substitution Principle）"></a>2、里氏代换原则（Liskov Substitution Principle）</h3><p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<h3 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a>3、依赖倒转原则（Dependence Inversion Principle）</h3><p>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p>
<h3 id="4、接口隔离原则（Interface-Segregation-Principle）"><a href="#4、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4、接口隔离原则（Interface Segregation Principle）"></a>4、接口隔离原则（Interface Segregation Principle）</h3><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p>
<h3 id="5、迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#5、迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="5、迪米特法则（最少知道原则）（Demeter Principle）"></a>5、迪米特法则（最少知道原则）（Demeter Principle）</h3><p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<h3 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h3><p>合成复用原则是尽量使用合成/聚合的方式，而不是使用继承。</p>
<h1 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h1><p>设计模式分为三种类型，共23种。</p>
<p>创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。</p>
<p>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</p>
<p>行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。</p>
<h1 id="23种设计模式简单介绍"><a href="#23种设计模式简单介绍" class="headerlink" title="23种设计模式简单介绍"></a>23种设计模式简单介绍</h1><p>Abstract Factory（抽象工厂模式）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<p>Adapter（适配器模式）：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p>Bridge（桥接模式）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
<p>Builder（建造者模式）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>Chain of Responsibility（责任链模式）：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</p>
<p>Command（命令模式）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。</p>
<p>Composite（组合模式）：将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。</p>
<p>Decorator（装饰模式）：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。</p>
<p>Facade（外观模式）：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p>Factory Method（工厂模式）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。</p>
<p>Flyweight（享元模式）：运用共享技术有效地支持大量细粒度的对象。</p>
<p>Interpreter（解析器模式）：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。</p>
<p>Iterator（迭代器模式）：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。</p>
<p>Mediator（中介模式）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<p>Memento（备忘录模式）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</p>
<p>Observer（观察者模式）：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。</p>
<p>Prototype（原型模式）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</p>
<p>Proxy（代理模式）：为其他对象提供一个代理以控制对这个对象的访问。</p>
<p>Singleton（单例模式）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。在九月的专栏中，David Geary探讨了单例模式以及在面对多线程（multi-threading）、类装载器（class loaders）和序列化（serialization）时如何处理这些缺陷。 State（状态模式）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。</p>
<p>Strategy（策略模式）：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。</p>
<p>Template Method（模板方法模式）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>Visitor（访问者模式）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<h1 id="23种设计模式之间的关系"><a href="#23种设计模式之间的关系" class="headerlink" title="23种设计模式之间的关系"></a>23种设计模式之间的关系</h1><p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/57a92d42-4d84-3aa9-a8b9-63a0b02c2c36.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/15/工厂模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/15/工厂模式/" itemprop="url">工厂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-15T16:34:47+08:00">
                2019-04-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>工厂模式包含简单工厂模式、工厂方法模式和抽象工厂模式。</p>
</blockquote>
<p>我们就分别来看一下这三种模式</p>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式。</p>
<p>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。</p>
<blockquote>
<p>必须注意的是，简单工厂模式不属于23种设计模式之一，但是它是另外两种工厂模式的基础。</p>
</blockquote>
<p>简单工厂模式的优点：</p>
<ol>
<li><p>一个调用者想创建一个对象，只要知道其名称就可以了。</p>
</li>
<li><p>屏蔽产品的具体实现，调用者只关心产品的接口。</p>
</li>
</ol>
<blockquote>
<p>根据指定的类型，创建不同的对象，比较简单，但是不够灵活，不能满足实际应用需求。</p>
</blockquote>
<p>简单工厂模式的缺点：</p>
<ol>
<li><p>增加产品，需要修改工厂类，不符合开放-封闭原则</p>
</li>
<li><p>工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则</p>
</li>
</ol>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于<strong>类创建型模式</strong>。</p>
<p>工厂方法模式是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在<strong>不指定对象具体类型</strong>的情况下创建对象的问题。</p>
<blockquote>
<p>工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”</p>
</blockquote>
<p>工厂方法模式和简单工厂模式虽然都是通过工厂来创建对象，他们之间最大的不同是——<strong>工厂方法模式在设计上完全完全符合“开闭原则”。</strong></p>
<p>在以下情况下可以使用工厂方法模式：</p>
<blockquote>
<p>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</p>
</blockquote>
<blockquote>
<p>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</p>
</blockquote>
<blockquote>
<p>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Operation <span class="title">CreateOption</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法类工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationAdd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除法类工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationDiv();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘法类工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationMul();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减法类工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationSub();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IFactory factory = <span class="keyword">new</span> AddFactory();</span><br><span class="line">        Operation operationAdd =  factory.CreateOption();</span><br><span class="line">        operationAdd.setValue1(<span class="number">10</span>);</span><br><span class="line">        operationAdd.setValue2(<span class="number">5</span>);</span><br><span class="line">        System.out.println(operationAdd.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong>：</p>
<p>工厂方法模式是简单工厂模式的进一步抽象和推广。</p>
<p>由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p>
<p>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p>
<p><strong>优缺点</strong></p>
<p>工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；</p>
<p>其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</p>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p>
<p>抽象工厂模式提供了一种方式，可以将同一产品族的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。</p>
<p>抽象工厂模式包含如下角色：</p>
<blockquote>
<p>AbstractFactory(抽象工厂)：用于声明生成抽象产品的方法</p>
<p>ConcreteFactory(具体工厂)：实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；</p>
<p>AbstractProduct(抽象产品)：为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；</p>
<p>Product(具体产品)：定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。</p>
</blockquote>
<p>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p>
<p>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。</p>
<p>抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/factory.png" alt=""></p>
<p>简单工厂 ： 用来生产同一等级结构中的任意产品。（对于增加新的产品，主要是新增产品，就要修改工厂类。符合单一职责原则。不符合开放-封闭原则）</p>
<p>工厂方法 ：用来生产同一等级结构中的固定产品。（支持增加任意产品，新增产品时不需要更改已有的工厂，需要增加该产品对应的工厂。符合单一职责原则、符合开放-封闭原则。但是引入了复杂性）</p>
<p>抽象工厂 ：用来生产不同产品族的全部产品。（增加新产品时，需要修改工厂，增加产品族时，需要增加工厂。符合单一职责原则，部分符合开放-封闭原则，降低了复杂性）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/15/扒皮Java注解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/15/扒皮Java注解/" itemprop="url">扒皮Java注解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-15T11:50:26+08:00">
                2019-04-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在日常开发中常常会用到注解，比如Spring MVC的一些注解或者是Spring原生的一些注解。但是无论是什么注解，它的原生功能支持，都来自于Java。所以这篇博客，我们来看看Java中注解的基本原理，然后再引申到Spring中去。</p>
<h1 id="注解定义"><a href="#注解定义" class="headerlink" title="注解定义"></a>注解定义</h1><p>小马哥说过基于注解的编程是一种元编程，注解就是元数据，是一种让程序员简化开发的东西。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxsq.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新建一个测试的注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)  <span class="comment">// 注解在JVM运行时还能起作用</span></span><br><span class="line"><span class="meta">@Documented</span>  <span class="comment">// 将注解加入到JavaDoc</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)  <span class="comment">// 注解可以在类上使用</span></span><br><span class="line"><span class="meta">@Inherited</span> <span class="comment">// 一个类上的注解可以被它的子类继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NewAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 1</span>;</span><br><span class="line">    <span class="function">String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "OK"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Target(ElementType.METHOD)<br>@Retention(RetentionPolicy.SOURCE)<br>public @interface Override {<br>}<br>这里面的<br>@Target、@Retention<br>就是元注解。<br>元注解有四个:</p>
<ul>
<li><p>@Target（表示该注解可以用于什么地方）、</p>
</li>
<li><p>@Retention（表示再什么级别保存该注解信息）、</p>
</li>
<li><p>@Documented（将此注解包含再javadoc中）、</p>
</li>
<li><p>@Inherited（允许子类继承父类中的注解）。</p>
</li>
</ul>
<h1 id="JDK注解"><a href="#JDK注解" class="headerlink" title="JDK注解"></a>JDK注解</h1><ol>
<li><code>@Override</code>表示当前方法覆盖了父类的方法</li>
<li><code>@Deprecation</code> 表示方法已经过时,方法上有横线，使用时会有警告。</li>
<li><code>@SuppressWarnings</code> 表示关闭一些警告信息(通知java编译器忽略特定的编译警告)</li>
<li><code>SafeVarargs</code> (jdk1.7更新) 表示：专门为抑制“堆污染”警告提供的。</li>
<li><code>@FunctionalInterface</code> (jdk1.8更新) 表示：用来指定某个接口必须是函数式接口，否则就会编译出错。</li>
</ol>
<h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><p>在Java中，类使用class定义，接口使用interface定义，注解和接口的定义差不多，增加了一个@符号，即@interface，代码如下：<br>public @interface EnableAuth {<br>}</p>
<p>注解中可以定义成员变量，用于信息的描述，跟接口中方法的定义类似，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAuth &#123;</span><br><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以添加默认值：<br>public @interface EnableAuth {<br>String name() default “Javaer”;<br>}<br>上面的介绍只是完成了自定义注解的第一步，开发中日常使用注解大部分是用在类上，方法上，字段上，示列代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAuth &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Target</code><br>用于指定被修饰的注解修饰哪些程序单元，也就是上面说的类，方法，字段</p>
<p><code>Retention</code></p>
<p>用于指定被修饰的注解被保留多长时间，</p>
<p>分别<code>SOURCE</code>（注解仅存在于源码中，在class字节码文件中不包含）,</p>
<p><code>CLASS</code>（默认的保留策略，注解会在class字节码文件中存在，但运行时无法获取）,</p>
<p><code>RUNTIME</code>（注解会在class字节码文件中存在，在运行时可以通过反射获取到）三种类型，</p>
<p>如果想要在程序运行过程中通过反射来获取注解的信息需要将Retention设置为RUNTIME</p>
<p><code>Documented</code><br>用于指定被修饰的注解类将被javadoc工具提取成文档</p>
<p><code>Inherited</code><br>用于指定被修饰的注解类将具有继承性</p>
<p><strong>如何获取注解中的值</strong></p>
<p>可以通过反射来判断类，方法，字段上是否有某个注解以及获取注解中的值, 获取某个类中方法上的注解代码示例如下：</p>
<blockquote>
<p>注解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxsq.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新建一个测试的注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)  <span class="comment">// 注解在JVM运行时还能起作用</span></span><br><span class="line"><span class="meta">@Documented</span>  <span class="comment">// 将注解加入到JavaDoc</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)  <span class="comment">// 注解可以在类上使用</span></span><br><span class="line"><span class="meta">@Inherited</span> <span class="comment">// 一个类上的注解可以被它的子类继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NewAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 1</span>;</span><br><span class="line">    <span class="function">String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "yes"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxsq.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: ajin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/4/15 11:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewAnnotationTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NewAnnotation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz=Class.forName(<span class="string">"com.zxsq.annotation.NewAnnotationTest"</span>);</span><br><span class="line"></span><br><span class="line">                Method method =clazz.getMethod(<span class="string">"test"</span>);</span><br><span class="line">                <span class="keyword">if</span> (method.isAnnotationPresent(NewAnnotation.class))&#123;</span><br><span class="line">                    <span class="keyword">int</span> id=method.getAnnotation(NewAnnotation.class).id();</span><br><span class="line">                    String msg=method.getAnnotation(NewAnnotation.class).msg();</span><br><span class="line">                    System.out.println(id);</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NoSuchMethodException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过isAnnotationPresent判断是否存在某个注解，通过getAnnotation获取注解对象，然后获取值</p>
<p>控制台打印：</p>
<p>1<br>yes</p>
<h1 id="Spring中的注解"><a href="#Spring中的注解" class="headerlink" title="Spring中的注解"></a>Spring中的注解</h1><ol>
<li>Spring常用注解</li>
</ol>
<p><code>@Configuration</code>把一个类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。<br><code>@Scope</code>注解 作用域<br><code>@Lazy(true)</code> 表示延迟初始化<br><code>@Service</code>用于标注业务层组件、<br><code>@Controller</code>用于标注控制层组件@Repository用于标注数据访问组件，即DAO组件。<br><code>@Component</code>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。<br><code>@Scope</code>用于指定scope作用域的（用在类上）<br><code>@PostConstruct</code>用于指定初始化方法（用在方法上）<br><code>@PreDestory</code>用于指定销毁方法（用在方法上）<br><code>@DependsOn</code>：定义Bean初始化及销毁时的顺序<br><code>@Primary</code>：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常<br><code>@Autowired</code> 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下：<br><code>@Autowired @Qualifier(&quot;personDaoBean&quot;)</code> 存在多个实例配合使用<br><code>@Resource</code>默认按名称装配，当找不到与名称匹配的bean才会按类型装配。<br><code>@PostConstruct</code>初始化注解<br><code>@PreDestroy</code> 摧毁注解 默认 单例  启动就加载</p>
<ol start="2">
<li>几个注解的区别</li>
</ol>
<p><code>@Component</code>指的是组件，</p>
<p><code>@Controller</code>，<code>@Repository</code>和<code>@Service</code> 注解都被<code>@Component</code>修饰，用于代码中区分<strong>表现层，持久层和业务层</strong>的组件，代码中组件不好归类时可以使用<code>@Component</code>来标注</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/15/反射深入理解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/15/反射深入理解/" itemprop="url">反射深入理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-15T09:48:43+08:00">
                2019-04-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前对Java反射已经有了最基本的了解，也写过简单的代码去验证过，今天希望可以全面理解下反射的原理，包括动态代理等知识。因为动态代理这个原理在优秀的开源框架中也是应用得蛮多的，必须死磕！</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol>
<li><p>什么是Java的反射</p>
<p>反射机制指的是在程序运行时能够获取自身的信息。在Java中，只要给定类的名字，就可以通过反射机制来获取类的所有属性和方法。</p>
</li>
</ol>
<ol start="2">
<li><p>反射有什么作用？</p>
<ul>
<li>在运行时判断任意一个对象所属的类。</li>
<li>在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>在运行时任意调用一个对象的方法</li>
<li>在运行时构造任意一个类的对象</li>
</ul>
<blockquote>
<p>很显然，在运行时获取类的所有属性和方法之后，反射就可以做一些相关的事情。</p>
</blockquote>
<p>其他人的一些理解：</p>
<ol>
<li><p>运行时动态操纵一个类</p>
</li>
<li><p>反射的作用是动态的加载一些在编译时无法获得的类</p>
</li>
<li><p>获取某些类的一些变量，调用某些类的私有方法。<strong>增加代码的灵活性</strong></p>
</li>
</ol>
</li>
</ol>
<ol start="3">
<li><p>那么反射有没有缺点？或者谈谈它的优缺点？</p>
<p>优点：提高了程序的灵活性</p>
<p>缺点：代码可读性低，反射代码执行的性能低，破坏了面向对象的封装性</p>
<blockquote>
<p>对于反射，在业务代码中需要避免使用，但是也要理解框架中使用到反射的原理</p>
</blockquote>
</li>
</ol>
<ol start="4">
<li><p>反射的用途？</p>
<ul>
<li>动态代理</li>
<li>JDBC的class.forName()</li>
<li>BeanUtils.copyProperties()</li>
<li>RPC框架</li>
<li>ORM框架</li>
<li>Spring IoC/DI</li>
</ul>
</li>
</ol>
<h1 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h1><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>Java的Class类是java反射机制的基础,通过Class类我们可以获得关于一个类的相关信息<br>Java.lang.Class是一个比较特殊的类，它用于封装被装入到JVM中的类（包括类和接口）的信息。当一个类或接口被装入的JVM时便会产生一个与之关联的java.lang.Class对象，可以通过这个Class对象对被装入类的详细信息进行访问。<br>虚拟机为每种类型管理一个独一无二的Class对象。也就是说，每个类（型）都有一个Class对象。运行程序时，Java虚拟机(JVM)首先检查是否所要加载的类对应的Class对象是否已经加载。如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。</p>
<blockquote>
<p>我的理解是，类对象是一个类独一无二的对象，并发中同步静态方法锁的就是当前的类对象，锁的粒度还是比较大的。</p>
</blockquote>
<p><strong>如何去获取Class对象</strong></p>
<p>1.根据对象的引用.getClass()方法获取：MyObject object=new MyObject();  Class c=object.getClass();<br>2.根据类名.class获取：Class c=MyObject.class;</p>
<p><code>private static final Logger log=LoggerFactory.getLogger(X.class)</code></p>
<p>3.根据Class中的静态方法Class.forName();</p>
<blockquote>
<p>Class c=Class.forName(“MyObject”);</p>
</blockquote>
<p><strong>Java中如何创建一个对象</strong></p>
<p>一、new </p>
<p>二、反射</p>
<ol>
<li><p>使用<code>Class</code>类的<code>newInstance</code>方法<br>可以使用Class类的newInstance方法创建对象。这个newInstance方法调用无参的构造函数创建对象。</p>
<p>//创建方法1<br><code>User user = (User)Class.forName(&quot;根路径.User&quot;).newInstance();</code>　<br>//创建方法2（用这个最好）<br><code>User user = User.class.newInstance();</code></p>
</li>
</ol>
<ol start="2">
<li><p>使用<code>Constructor</code>类的<code>newInstance</code>方法<br>和Class类的newInstance方法很像，</p>
<p> java.lang.reflect.Constructor类里也有一个newInstance方法可以创建对象。</p>
<p>我们可以通过这个newInstance方法调用有参数的和私有的构造函数。</p>
<blockquote>
<p>Constructor&lt;User&gt; constructor = User.class.getConstructor();<br>User user = constructor.newInstance();<br>这两种newInstance方法就是大家所说的反射。事实上Class的newInstance方法内部调用Constructor的newInstance方法。</p>
</blockquote>
<p>三、使用clone方法</p>
</li>
</ol>
<p>​    无论何时我们调用一个对象的clone方法，jvm就会创建一个新的对象，将前面对象的内容全部拷贝进去。用clone方法创建对象并不会调用任何构造函数。<br>​    要使用clone方法，我们需要先实现Cloneable接口并实现其定义的clone方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age; </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CloneTest</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">CloneTest cloneTest = <span class="keyword">new</span> CloneTest(<span class="string">"wangql"</span>,<span class="number">18</span>);</span><br><span class="line">CloneTest copyClone = (CloneTest) cloneTest.clone();</span><br><span class="line">System.out.println(<span class="string">"newclone:"</span>+cloneTest.getName());</span><br><span class="line">System.out.println(<span class="string">"copyClone:"</span>+copyClone.getName());</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四、使用反序列化<br>当我们序列化和反序列化一个对象，jvm会给我们创建一个单独的对象。在反序列化时，jvm创建对象并不会调用任何构造函数。<br>为了反序列化一个对象，我们需要让我们的类实现Serializable接口。 </p>
<blockquote>
<p>下面看一个例子：在泛型为Integer的ArrayList中存放一个String类型的对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxsq.reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: ajin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/4/15 10:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           Method method = list.getClass().getMethod(<span class="string">"add"</span>,Object.class);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                method.invoke(list,<span class="string">"hahaha"</span>);</span><br><span class="line">                System.out.println(list.get(<span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>首先我们需要知道Java中代理的相关概念。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>所谓静态代理，就是代理类是由程序员自己编写的，在编译期就确定好了的。来看下下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StaticService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticServiceImpl</span> <span class="keyword">implements</span> <span class="title">StaticService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"哈哈哈"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticServcieProxy</span> <span class="keyword">implements</span> <span class="title">StaticService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StaticService target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticServcieProxy</span><span class="params">(StaticService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以写一些其他的逻辑，给目标对象新增一些功能</span></span><br><span class="line">        target.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticService target=<span class="keyword">new</span> StaticServiceImpl();</span><br><span class="line">        StaticServcieProxy proxy=<span class="keyword">new</span> StaticServcieProxy(target);</span><br><span class="line">        proxy.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出 <strong>哈哈哈</strong></p>
<p>这就是一个简单的静态的代理模式的实现。</p>
<blockquote>
<p>代理模式中的所有角色（代理对象、目标对象、目标对象的接口）等都是在编译期就确定好的。</p>
</blockquote>
<p><strong>静态代理的用途</strong></p>
<ul>
<li>控制真实对象的访问权限 通过代理对象控制对真实对象的使用权限。</li>
<li>避免创建大对象 通过使用一个代理小对象来代表一个真实的大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</li>
<li>增强真实对象的功能 这个比较简单，通过代理可以在调用真实对象的方法的前后增加额外功能。</li>
</ul>
<blockquote>
<p> 静态代理就是在编译期，就已经实现的代理对象。代理对象会实现目标对象的接口，在不改变目标对象本身逻辑的情况下，在实现方法的前后添加逻辑。</p>
</blockquote>
<h3 id="动态代理详解"><a href="#动态代理详解" class="headerlink" title="动态代理详解"></a>动态代理详解</h3><p>静态代理虽然很方便，但是需要我们程序员手写很多代理，而动态代理是不需要的。</p>
<p>动态代理中的代理类并不要求在编译期就确定，而是可以在运行期动态生成，从而实现对目标对象的代理功能。</p>
<blockquote>
<p>反射是动态代理的一种实现方式。</p>
</blockquote>
<p><strong>动态代理的实现方式</strong></p>
<ol>
<li><p>JDK动态代理</p>
<p>java.lang.reflect 包中的<code>Proxy</code>类和<code>InvocationHandler</code>接口提供了生成动态代理类的能力。</p>
<blockquote>
<p>使用JDK动态代理的对象必须实现一个或多个接口</p>
</blockquote>
</li>
</ol>
<ol start="2">
<li><p>Cglib动态代理</p>
<p>Cglib (Code Generation Library )是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。</p>
<p>使用cglib代理的对象则无需实现接口，达到代理类无侵入。</p>
</li>
</ol>
<p><strong>动态代理的用途</strong></p>
<p>Java的动态代理，在日常开发中可能并不经常使用，但是并不代表他不重要。</p>
<p>Java的动态代理的最主要的用途就是应用在各种框架中。因为使用动态代理可以很方便的运行期生成代理类，通过代理类可以做很多事情，比如AOP，比如过滤器、拦截器等。</p>
<p>在我们平时使用的框架中，像servlet的filter、包括spring提供的aop以及struts2的拦截器都使用了动态代理功能。我们日常看到的mybatis分页插件，以及日志拦截、事务拦截、权限拦截这些几乎全部由动态代理的身影。</p>
<p><strong>动态代理实现的基本步骤</strong></p>
<p><strong>JDK动态代理</strong>：</p>
<p><code>java.lang.reflect.Proxy</code>: 这是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类，即 DynamicProxyClass extends Proxy。</p>
<p><code>java.lang.reflect.InvocationHandler</code>: 这里称他为”调用处理器”，他是一个接口，我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 InvocationHandler 接口。</p>
<ol>
<li><p>编写一个处理器 Handler，继承 InvocationHandler，传入 目标对象，注意是实现类，并不是接口类</p>
<ol start="2">
<li><p>用 Proxy.newProxyInstance 静态方法动态生成代理对象，传入 类加载器、接口类数组、处理器</p>
</li>
<li><p>调用对象目标方法</p>
</li>
</ol>
<blockquote>
<p>用一个实例来说明：不改变Test类的情况下，在方法target 之前打印一句话，之后打印一句话。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"——————————add————————————"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"begin"</span>);</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticService target=<span class="keyword">new</span> StaticServiceImpl();</span><br><span class="line">        StaticServcieProxy proxy=<span class="keyword">new</span> StaticServcieProxy(target);</span><br><span class="line">        proxy.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<p>begin<br>——————————add————————————<br>end</p>
</li>
</ol>
<p><strong>使用 CGLib 的步骤</strong></p>
<ol>
<li>继承 MethodInteceptor，写一个拦截器</li>
<li>生成一个 Enhancer，将拦截器与目标类传入去</li>
<li>用 Enhancer 生成一个代理对象</li>
</ol>
<blockquote>
<p>不改变Test类的情况下，在方法target 之前打印一句话，之后打印一句话。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.zxsq.reflection;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Cglib实现动态代理</span><br><span class="line"> */</span><br><span class="line">public class CglibProxt implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    private Enhancer enhancer=new Enhancer();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取代理对象</span><br><span class="line">     * */</span><br><span class="line">    public Object getProxy(Class clazz)&#123;</span><br><span class="line">        // 设置需要创建的子类</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        enhancer.setCallback(this);</span><br><span class="line">        //通过字节码技术动态创建子类实例</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object intercept(Object o, Method method,</span><br><span class="line">                            Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;前置代理&quot;);</span><br><span class="line">        Object result=methodProxy.invokeSuper(o,objects);</span><br><span class="line">        System.out.println(&quot;后置代理&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxsq.reflection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: ajin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/4/15 11:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CglibProxt cglibProxt=<span class="keyword">new</span> CglibProxt();</span><br><span class="line">        UserServiceImpl userService=</span><br><span class="line">                (UserServiceImpl) cglibProxt.getProxy(UserServiceImpl.class);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<p>前置代理<br>——————————add————————————<br>后置代理</p>
<h2 id="Spring-AOP实现原理"><a href="#Spring-AOP实现原理" class="headerlink" title="Spring AOP实现原理"></a>Spring AOP实现原理</h2><p>Spring <code>AOP</code>中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。</p>
<p>JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。</p>
<blockquote>
<p>如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。</p>
</blockquote>
<p>CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，&gt; </p>
<blockquote>
<p>CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/15/Java泛型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/15/Java泛型/" itemprop="url">Java泛型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-15T09:24:15+08:00">
                2019-04-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="泛型简介"><a href="#泛型简介" class="headerlink" title="泛型简介"></a>泛型简介</h1><p><strong>什么是Java中的泛型呢？</strong></p>
<p>Java泛型（generics） 是JDK 5中引入的一个新特性，允许在定义类和接口的时候使用类型参数（type parameter）。声明的类型参数在使用时用具体的类型来替换。泛型最主要的应用是在JDK 5中的新集合类框架中。<br>泛型最大的好处是可以提高代码的复用性。以List接口为例，我们可以将String、Integer等类型放入List中，如不用泛型，存放String类型要写一个List接口，存放Integer要写另外一个List接口，泛型可以很好的解决这个问题。</p>
<blockquote>
<p>类是对象的模板，泛型是类的模板。</p>
</blockquote>
<p><strong>什么是类型擦除？</strong></p>
<p>类型擦除指的是通过类型参数合并，将泛型类型实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。</p>
<p>类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。</p>
<p> 类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。 </p>
<p>类型擦除的主要过程如下：</p>
<ol>
<li><p>将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。</p>
</li>
<li><p>移除所有的类型参数。</p>
</li>
</ol>
<p><strong>Java泛型中K T V E ？ object等分别代表什么含义。</strong></p>
<ul>
<li>E – Element (在集合中使用，因为集合中存放的是元素)</li>
<li>T – Type（Java 类）</li>
<li>K – Key（键）</li>
<li>V – Value（值）</li>
<li>N – Number（数值类型）</li>
<li>？ – 表示不确定的java类型（无限制通配符类型）</li>
<li>S、U、V – 2nd、3rd、4th types</li>
<li>Object – 是所有类的根类，任何类的对象都可以设置给该Object引用变量，使用的时候可能需要类型强制转换，但是用使用了泛型T、E等这些标识符后，在实际用之前类型就已经确定了，不需要再进行类型强制转换。</li>
</ul>
<p><strong>谈谈你对Java泛型中上下界限定符extends 和 super的理解</strong></p>
<p><code>&lt;? extends T&gt;</code> 表示类型的上界，表示参数化类型的可能是T 或是 T的子类<br><code>&lt;? super T&gt;</code> 表示类型下界（Java Core中叫超类型限定），表示参数化类型是此类型的超类型（父类型），直至Object</p>
<p><strong>PECS原则</strong><br>如果要从集合中读取类型T的数据，并且不能写入，可以使用 ? extends 通配符；(Producer Extends)<br>如果要从集合中写入类型T的数据，并且不需要读取，可以使用 ? super 通配符；(Consumer Super)<br>如果既要存又要取，那么就不要使用任何通配符。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于泛型，理解得还不深刻，这次学习了解了类型擦除的原理，关于其他更深的问题，会比较模糊。</p>
<p>很惭愧地写了这篇整理泛型的博客，希望以后可以加强一下对泛型的理解。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/14/深入Java-IO/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/深入Java-IO/" itemprop="url">深入Java IO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T21:34:59+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>机智的我，又在知识星球找到了IO的干货，那就跟着干货深入整理一下IO的全面知识点。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol>
<li><p>什么是流，什么是比特，什么是字节，什么是字符 </p>
<ul>
<li>流：流是一串连续不断的数据集合，可以一段一段的写入长的数据流，读取数据流的时候是不知道流的分段 情况的，只能从前往后读取数据流</li>
<li>比特：是二进制的最小单位，0或者1</li>
<li>字节：是计算机操作数据的最小单位，8位bit，（-128~</li>
<li>字符：用户可读写的最小单位，16位bit，（0~65535） </li>
</ul>
</li>
<li><p>什么是IO，包含哪几种流 </p>
<blockquote>
<p>它是指计算机与外部世界或者一个程序与计算机的其余部分的之间的接口。它对于任何计算机系统都非常关键，因而所有 I/O 的主体实际上是内置在操作系统中的。单独的程序一般是让系统为它们完成大部分的工作。 在 Java 编程中，直到最近一直使用 流 的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象 </p>
</blockquote>
<p>字节流，字符流，输入流，输出流 </p>
</li>
<li><p>什么是字节流和字符流，区别，之间如何转换 </p>
<ul>
<li><p>字节流：操作的是byte类型的数据，直接对文件本身进行操作，主要操作类是<code>OutputStream</code>、<code>InputStream</code>的子类</p>
</li>
<li><p>字符流：操作的是字符类型的数据，使用<strong>缓冲区</strong>缓冲字符，不关闭流就不会输出任何内容，主要操作类是 Reader、Writer的子类</p>
</li>
</ul>
</li>
<li><p>什么是输入流和输出流</p>
<ul>
<li>输入流：把数据写入存储介质的操作</li>
<li>输出流：从存储介质中读取数据的操作</li>
</ul>
</li>
</ol>
<h1 id="NIO-BIO-AIO"><a href="#NIO-BIO-AIO" class="headerlink" title="NIO,BIO,AIO"></a>NIO,BIO,AIO</h1><ol>
<li><p>什么是<code>NIO</code></p>
<p>NIO与IO的作用和目的是相同的，都是计算机与外部世界或者一个程序与计算机的其余部分的之间的接口，只<br>不过，IO是以流的方式处理数据，而NIO是以块的方式处理数据<br>IO：流式数据创建过滤器很容易，面向流的IO慢<br>NIO：按照块处理比按照流处理的快，但是缺少优雅性和简单性 </p>
</li>
<li><p>什么是<code>AIO</code></p>
<p>Java AIO即Async非阻塞，是异步非阻塞的IO。 </p>
</li>
<li><p>什么是<code>BIO</code></p>
<p>Java BIO即Block I/O ， 同步并阻塞的IO。</p>
</li>
</ol>
<ol start="4">
<li><p>NIO,BIO,AIO之间的区别与联系 </p>
<p>BIO：同步阻塞IO模式，必须等待这件事情做完了才去做下一件事情<br>AIO：异步非阻塞IO模式，不用等待这件事情做完了才去做下一件事，这件事情做完了就会自动告诉我他做完<br>了<br>NIO：同时支持阻塞与非阻塞模式 </p>
</li>
</ol>
<ol start="5">
<li><p>Java中BIO、NIO、AIO分别适用哪些场景 </p>
<p><code>BIO</code>：适用于连接数较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前<br>的唯一选择，但程序直观简单易理解</p>
<p><code>NIO</code>方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较<br>复杂，JDK1.4开始支持。</p>
<p><code>AIO</code>方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，<br>编程比较复杂，JDK7开始支持 </p>
</li>
<li><p>IO流需不需要关闭,如果关闭的话应该如何关闭。需要注意什么 </p>
<ul>
<li>IO流一定要关闭，不然会内存泄漏，进而导致内存溢出</li>
<li>一般在finally块中关闭，并且关闭流的操作可能会抛出异常，要对其进行捕获 </li>
</ul>
</li>
<li><p>什么是同步，什么是异步</p>
<p>A调用B<br>同步：A调用B后，B马上去执行，执行完成会告诉A，A本次调用会得到结果<br>异步：A调用B后，B并不会马上执行，但是一定会执行，执行完成会告诉A，A本次调用不会得到结 果</p>
</li>
<li><p>什么是阻塞？什么是非阻塞？ </p>
<p>A调用B</p>
<p>阻塞：A调用B之后一直等待B的结果，等不到就不做别的事情<br>非阻塞：A调用B之后就去做自己事情了，不需要等待B完成 </p>
</li>
<li><p>同步，异步 和 阻塞，非阻塞之间的区别？ </p>
<p>同步，异步，是描述被调用方的。 阻塞，非阻塞，是描述调用方的。 同步不一定阻塞，异步也不一定非阻塞。没有必然关系。 </p>
</li>
</ol>
<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><ol>
<li>IO模型有哪5种？ </li>
</ol>
<ul>
<li>阻塞式IO模型</li>
<li>非阻塞IO模型</li>
<li>IO复用模型</li>
<li>信号驱动IO模型</li>
<li>异步IO模型 </li>
</ul>
<ol start="2">
<li><p>阻塞IO</p>
<p>当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就<br>会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户<br>线程，用户线程才解除block状态。 </p>
</li>
<li><p>非阻塞IO</p>
<p>当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它<br>就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了<br>用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。 </p>
</li>
<li><p>什么是多路复用IO模型 </p>
<blockquote>
<p>不断去轮询多个<code>socket</code>的状态，只有当<code>socket</code>真正有读写事件时，才真正调用实际的IO读写操作。<br>多路复用IO比较适合连接数比较多的情况。<br>多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。 </p>
</blockquote>
</li>
<li><p>什么是信号驱动IO模型 </p>
<p>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线<br>程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中<br>调用IO读写操作来进行实际的IO请求操作。</p>
</li>
<li><p>什么是异步IO模型 </p>
<p>当进程发起一个 IO 操作，进程返回（不阻塞），但也不能返回结果；内核 把整个 IO 处理完后，会通知进程<br>结果。如果 IO 操作成功则进程直接获取到数据。 </p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/14/单例模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/单例模式/" itemprop="url">单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T20:11:15+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近感觉设计模式这一块好久都没有看了，觉得有必要补补，正好碰见H大知识星球里面有专门的学习资料，就打算跟着学习一下，并用博客的方式来记录学习过程。</p>
<p>这篇博客主要看下单例模式。</p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li><p>什么是单例模式？</p>
<p>通俗来说，就是单个实例。单例模式是最简单的设计模式之一，属于创建型模式。</p>
<p>GOF书中说：保证每个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<blockquote>
<p>也就是说，一个实例，并且还要提供访问该实例的方式</p>
</blockquote>
<p>单例模式体现在类声明中，单例的类负责创建自己的对象，同时确保只有单个对象被创建；</p>
<p>并且这个类提供了一种访问其唯一对象的方式，可以直接访问，不需要实例化该类的对象</p>
</li>
<li><p>单例的优点？</p>
<ul>
<li><p>节省维护对象的开销：创建、内存占用、回收</p>
</li>
<li><p>实例状态易于维护，一般单例不维护状态，当多个线程就行更改状态时，会产生并发问题</p>
</li>
</ul>
</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在学习单例模式的实现之前，我们需要有一个认识，对象可以通过构造器创建出来，如果谁都能使用这个构造器，那就无法实现单例。因此我们需要将构造器方法设置为<code>private</code>,不给别人new的机会。</p>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxsq.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: ajin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">//   饿汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance=<span class="keyword">new</span> Singleton();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试是否是单例模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton1=Singleton.getInstance();</span><br><span class="line">        Singleton singleton2=Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton1==singleton2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出：<code>true</code></p>
<blockquote>
<p>对于饿汉式来说，就是想要拿到这个实例的时候就能立即拿到，而不需要等待时间。</p>
<p>所以，通过static的静态初始化方式，在该类第一次被加载的时候，就有一个Singleton1<br>的实例被创建出来了。这样就保证在第一次想要使用该对象时，它已经被初始化好了 </p>
</blockquote>
<p>饿汉式单例，在类被加载的时候对象就会实例化。这也许会造成不必要的消耗，因为<br>有可能这个实例根本就不会被用到。而且，如果这个类被多次加载的话也会造成多次实例<br>化 </p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类就是把创建单例对象放在了静态内部类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxsq.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类实现单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassSingeton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InnerClassSingeton instance=<span class="keyword">new</span> InnerClassSingeton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InnerClassSingeton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  InnerClassSingeton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInner.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxsq.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程不安全的懒汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUnSafeSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadUnSafeSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadUnSafeSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> ThreadUnSafeSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance=<span class="keyword">new</span> ThreadUnSafeSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种懒汉式线程不安全，如果多个线程同时访问<code>getInstance()</code>会导致创建多个不同的对象。</p>
<p>而饿汉式就不会有这种情况，因为单例对象早就创建好了，所以多线程情况下，不会创建多个对象。</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>为了能够线程安全，我们只需要<code>synchronized</code>加锁即可，实现原子性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxsq.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程安全的懒汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeSigleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ThreadSafeSigleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadSafeSigleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadUnSafeSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ThreadSafeSigleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> ThreadSafeSigleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/14/MyBatis插件介绍/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/MyBatis插件介绍/" itemprop="url">MyBatis插件介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T15:50:47+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>其实MyBatis插件开发，就是在SQL语句执行过程中的某一点进行拦截。</p>
<p>MyBatis允许使用插件来拦截的接口和方法如下所示：（这些可以被拦截)</p>
<ul>
<li>Executor ( update 、 query 、 flushStatements 、 commit 、 rollback 、<br>getTransaction 、 close 、 isClosed)</li>
<li>ParameterHandler ( getParameterObj ect 、 setParameters)</li>
<li>Resul tSetHandler ( handleResul tSets 、 handleCursorResultSe ts 、<br>handleOutputParameters)</li>
<li>StatementHandler (prepare 、 parameterize 、 batch 、 update 、 query) </li>
</ul>
<h1 id="拦截器接口介绍"><a href="#拦截器接口介绍" class="headerlink" title="拦截器接口介绍"></a>拦截器接口介绍</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 用来传递插件的参数，可以通过参数来改变插件的行为</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="setProperties"><a href="#setProperties" class="headerlink" title="setProperties()"></a>setProperties()</h2><p>我们在mybatis-config.xml文件中作如下的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--声明一个插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">”</span> <span class="attr">tk.mybatis.simple.plugin</span> <span class="attr">.</span> <span class="attr">XXXInterceptor</span> " &gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">property</span> <span class="attr">name</span> ＝ ” <span class="attr">propl</span> ” <span class="attr">value</span> ＝” <span class="attr">value</span> <span class="attr">l</span> ”/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> ＝ ” <span class="attr">prop2</span> ” <span class="attr">value</span> ＝” <span class="attr">value2</span>“/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里面的property标签定义了拦截器的参数，这两个参数可以通过<code>setProperties()</code>传递给我们的拦截器</p>
</blockquote>
<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin()"></a>plugin()</h2><p><code>Object plugin(Object target);</code></p>
<p><code>target</code>:拦截器要拦截的对象</p>
<blockquote>
<p>该方法会在创建被拦截的接口实现类时调用</p>
</blockquote>
<p>该方法的实现很简单 ，只需要调用 MyBatis 提供的<br><code>Plugin (org . apache. ibatis. plugin. Plugin ）</code>类的 <code>wrap</code> 静态方法就可以通过 Java 的<br>动态代理拦截目标对象。这个接口方法通常的实现代码如下 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Plugin.wrap(target , <span class="keyword">this</span>) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>wrap</code>方法会自动判断<strong>拦截器的签名和被拦截对象的接口</strong>是否匹配，只有匹配的<br>情况下才会使用动态代理拦截目标对象，因此在上面的实现方法中不必做额外的逻辑判断 。 </p>
<h2 id="intercept"><a href="#intercept" class="headerlink" title="intercept()"></a>intercept()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"> <span class="comment">// 获取当前被拦截的对象</span></span><br><span class="line">Object target ＝invocation.getTarget ();</span><br><span class="line"> <span class="comment">// 获取当前被拦截的方法</span></span><br><span class="line">Method method = invocation.getMethod() ;</span><br><span class="line"> <span class="comment">// 获取被拦截方法的参数</span></span><br><span class="line">Object[] args = invocation.getArgs() ;</span><br><span class="line"> <span class="comment">// 返回执行的结果</span></span><br><span class="line">Object result ＝invocation .proceed ();</span><br><span class="line"><span class="keyword">return</span> result </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="拦截器签名介绍"><a href="#拦截器签名介绍" class="headerlink" title="拦截器签名介绍"></a>拦截器签名介绍</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@Signature</span> (</span><br><span class="line">type = ResultSetHandler.class ,</span><br><span class="line">method = ” handleResultSets ”,</span><br><span class="line">args = &#123;Statement. <span class="class"><span class="keyword">class</span>&#125;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>type</code>    设置拦截的接口</p>
</li>
<li><p><code>method</code>  设置拦截接口的方法</p>
</li>
<li><p><code>args</code> 设置拦截方法的参数类型数组，通过方法名和参数类型可以确定唯一一个方法</p>
</li>
</ul>
<p>在我的项目当中是这样定义的拦截器签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123; <span class="meta">@Signature</span>(type = Executor.class, method = <span class="string">"update"</span>, args = &#123; MappedStatement.class, Object.class &#125;),</span><br><span class="line">		<span class="meta">@Signature</span>(type = Executor.class, method = <span class="string">"query"</span>, args = &#123; MappedStatement.class, Object.class,</span><br><span class="line">				RowBounds.class, ResultHandler.class &#125;) &#125;)</span><br></pre></td></tr></table></figure>
<p>我需要对<code>Executor</code>接口进行拦截，先拦截其update方法，再拦截器query方法，被拦截方法中的参数根据update和query方法来决定。</p>
<p>这是Executor接口中的两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line"> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure>
<p>我的理解是<code>MapppedStatement</code>对象对应的是我们XXXmapper.xml文件中<code>&lt;select&gt;&lt;/select&gt;</code>标签对象，Executor是一个执行器，负责通过动态代理来执行<code>MappedStatement</code>。</p>
<blockquote>
<p>我们就是要拦截这个执行器，让SQL语句在执行之前动态地选择数据源，也就是查询语句走从库，增删改语句走主库。</p>
</blockquote>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>我的项目需要对sql语句进行拦截，使得其动态地选择数据源；所以我就拦截了Executor接口，并编写了动态选择数据源的逻辑。这样就体现了主从同步的作用，从库用来读，主库负责写。</p>
<p>核心的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取BoundSql（Sql语句对象）</span></span><br><span class="line">BoundSql boundSql = ms.getSqlSource().getBoundSql(objects[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// 获取SQL语句</span></span><br><span class="line">String sql = boundSql.getSql().toLowerCase(Locale.CHINA).replaceAll(<span class="string">"[\\t\\n\\r]"</span>, <span class="string">" "</span>);</span><br><span class="line"><span class="keyword">if</span> (sql.matches(REGEX)) &#123;</span><br><span class="line">                   <span class="comment">// 设置访问主库</span></span><br><span class="line">	lookupKey = DynamicDataSourceHolder.DB_MASTER;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 设置访问从库</span></span><br><span class="line">	lookupKey = DynamicDataSourceHolder.DB_SLAVE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘天霸</p>
              <p class="site-description motion-element" itemprop="description">Java学习记录博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘天霸</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
