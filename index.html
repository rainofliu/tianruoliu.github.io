<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="时间旅行者" type="application/atom+xml">






<meta name="description" content="Java学习记录博客">
<meta property="og:type" content="website">
<meta property="og:title" content="时间旅行者">
<meta property="og:url" content="https://www.liutianruo.com/index.html">
<meta property="og:site_name" content="时间旅行者">
<meta property="og:description" content="Java学习记录博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="时间旅行者">
<meta name="twitter:description" content="Java学习记录博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.liutianruo.com/">





  <title>时间旅行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">时间旅行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-something">
          <a href="/something/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-something"></i> <br>
            
            有料
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/05/30/ArrayList和LinkedList理解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/30/ArrayList和LinkedList理解/" itemprop="url">《ArrayList和LinkedList理解》</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-30T17:06:14+08:00">
                2019-05-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ArrayList是基于数组实现的，LinkedList是基于链表实现的，这是我们都知道的。但是这只是表面，今天，我们从</p>
<p>ArrayList和LinkedList的源码实现来深入理解，并且阐述一些性能优化的问题。</p>
<p>如下，这是ArrayList和LinkedList的继承关系图。</p>
<p><img src="https://static001.geekbang.org/resource/image/ab/36/ab73021caa4545ae0ac917e0f36cde36.jpg" alt=""></p>
<h1 id="ArrayList是如何实现的？"><a href="#ArrayList是如何实现的？" class="headerlink" title="ArrayList是如何实现的？"></a>ArrayList是如何实现的？</h1><p>学习之前想想这些问题：</p>
<p>问题 1：我们在查看ArrayList的实现类源码时，你会发现对象数组 <code>elementData</code>使用了<code>transient</code>修饰，我们知道<code>transient</code>关键字修饰该属性，则表示该属性不会被序列化，然而我们并没有看到文档中说明<code>ArrayList</code>不能被序列化，这是为什么？</p>
<p>问题2：我们在使用<code>ArrayList</code> 进行新增、删除时，经常被提醒“使用<code>ArrayList</code>做新增删除操作会影响效率”。那是不是<code>ArrayList</code>在大量新增元素的场景下效率就一定会变慢呢？</p>
<h2 id="继承实现关系"><a href="#继承实现关系" class="headerlink" title="继承实现关系"></a>继承实现关系</h2><ul>
<li><p>ArrayList实现了List接口，继承了AbstractList抽象类</p>
</li>
<li><p>ArrayList实现了<code>RandomAccess</code>接口</p>
<p><code>RandomAccess</code>是一个空接口，空接口的意义就是一个标记。</p>
<p>看了jdk的注释，是允许随机访问的意思；只要实现该接口的 List 类，都能实现快速随机访问</p>
</li>
</ul>
<ul>
<li><p>还实现了<code>Cloneable</code>和<code>Serilizable</code>，可以实现克隆和序列化</p>
<p><code>private static final long serialVersionUID = 8683452581122892189L;</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<h2 id="ArrayList的属性"><a href="#ArrayList的属性" class="headerlink" title="ArrayList的属性"></a>ArrayList的属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 	</span><br><span class="line"><span class="comment">// 默认初始化容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// 非私有，以简化嵌套类访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组长度，数组现有几个元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
<p>我们现在想想问题1，就是<code>transient</code>修饰了elementData，不支持序列化，然后ArrayList还偏偏实现了<code>Serializable</code>接口，到底ArrayList能不能实现序列化呢？</p>
<p>如果能序列化，那序列化如何实现的呢？</p>
<p>我们来探索一番。</p>
<p>ArrayList是基于数组实现的，ArrayList的数组是基于动态增长的。</p>
<blockquote>
<p> 因此并不是所有被分配的内存空间都存储了数据</p>
</blockquote>
<p>所以我们的外部序列化会序列化整个数组。ArrayList 为了避免这些没有存储数据的内存空间被序列化，内部提供了两个私有方法<code>writeObject</code>以及<code>readObject</code> 来自我完成序列化与反序列化，从而在序列化与反序列化数组时节省了空间和时间。</p>
<blockquote>
<p>可以类比一下，HashMap的序列化和反序列化，也是内部自己实现的。</p>
</blockquote>
<blockquote>
<p>所以我们的<code>transient</code>只是为了不让这个对象数组被外部序列化所作的一种保护。</p>
</blockquote>
<h2 id="ArrayList构造方法"><a href="#ArrayList构造方法" class="headerlink" title="ArrayList构造方法"></a>ArrayList构造方法</h2><p>ArrayList有三个构造方法，我们分别看一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个空的对象数组</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是我们默认的写法，<code>List&lt;String&gt; list = new ArrayList&lt;String&gt;();
    }</code>,这个构造器会构造一个空的对象数组elementData</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 传入一个集合给ArrayList</span></span><br><span class="line">    	<span class="comment">// 将集合转成对象数组</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 按照初始容量创建数组大小</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 使用默认的空数组</span></span><br><span class="line">           <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 参数小于0，报异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们还要注意一个细节Arrays.asList()方法，产生的ArrayList是Arrays类中的一个静态私有内部类对象，而并非我们这里的java.util.ArrayList</p>
</blockquote>
<p>调优小攻略：</p>
<blockquote>
<p>当ArrayList新增元素时，如果所存储的元素已经超过其已有大小，它会计算元素大小后再进行动态扩容，数组的扩容会导致整个数组进行一次内存复制。</p>
<p>因此，我们在初始化ArrayList时，可以通过<code>ArrayList(int initialCapacity)</code> 构造函数合理指定数组初始大小，这样有助于减少数组的扩容次数，从而提高系统性能。</p>
</blockquote>
<h2 id="ArrayList新增元素"><a href="#ArrayList新增元素" class="headerlink" title="ArrayList新增元素"></a>ArrayList新增元素</h2><ol>
<li><p>直接将元素加到数组的末尾</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确认数组容量是否足够</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加元素到任意位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>两个方法的相同之处是在添加元素之前，都会先确认容量大小，如果容量够大，就不用进行扩容；如果容量不够大，就会按照原来数组的1.5倍大小进行扩容，在扩容之后需要将数组复制到新分配的内存地址。</p>
<p>​    <code>ensureCapacityInternal()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">     ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>ensureExplicitCapacity</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>grow</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>扩容就会生成一个新的对象数组，把之前数组的元素拷贝过来。</p>
<p>猜想一下，之前的对象数组是不是可能会被GC干掉呢？</p>
</blockquote>
<p>两个方法也有不同之处，添加元素到任意位置，会导致在该位置后的所有元素都需要重新排列，而将元素添加到数组的末尾，在没有发生扩容的前提下，是不会有元素复制排序过程的。</p>
<p>所以刚刚第二个问题，ArrayList添加元素，如果是添加到数组末尾，而没有发生扩容，它的性能也是足够好的。</p>
<p>要做到这一点，就需要我们新建ArrayList的时候，需要初始化数组的容量。</p>
<h2 id="ArrayList删除元素"><a href="#ArrayList删除元素" class="headerlink" title="ArrayList删除元素"></a>ArrayList删除元素</h2><p>ArrayList的删除方法和添加任意位置元素的方法是有些相同的。ArrayList 在每一次有效的删除元素操作之后，都要进行数组的重组，并且删除的元素位置越靠前，数组重组的开销就越大。</p>
<blockquote>
<p>其实这就是线性结构的缺陷了。</p>
</blockquote>
<h1 id="LinkedList的实现"><a href="#LinkedList的实现" class="headerlink" title="LinkedList的实现"></a>LinkedList的实现</h1><p>LinkedList是基于<strong>双向链表</strong>数据结构实现的，LinkedList定义了一个<code>Node</code>结构，<code>Node</code>结构中包含了3个部分：元素内容item、前指针prev以及后指针next。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    	<span class="comment">// 元素内容</span></span><br><span class="line">       E item;</span><br><span class="line">    	<span class="comment">// 前指针</span></span><br><span class="line">       Node&lt;E&gt; next;</span><br><span class="line">    	<span class="comment">// 后指针</span></span><br><span class="line">       Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">       Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.item = element;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">           <span class="keyword">this</span>.prev = prev;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>总结一下，LinkedList 就是由<code>Node</code>结构对象连接而成的一个双向链表。</p>
<h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><ul>
<li><p>LinkedList实现了List接口，继承了AbstractSequentialList类</p>
</li>
<li><p>它实现了Deque类</p>
<blockquote>
<p><code>Deque</code>: 线性集合，支持两端的元素插入和移除(队列)</p>
</blockquote>
</li>
<li><p>实现了Cloneable和java.io.Serializable接口，支持克隆和序列化</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<h2 id="LinkedList新增元素"><a href="#LinkedList新增元素" class="headerlink" title="LinkedList新增元素"></a>LinkedList新增元素</h2><p>LinkedList 添加元素的实现很简洁，但添加的方式却有很多种。</p>
<p>默认的add（E e）方法是将添加的元素加到队尾，首先是将last元素置换到临时变量中，生成一个新的Node节点对象，然后将last引用指向新节点对象，之前的last对象的前指针指向新节点对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 链接e作为最后一个元素。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="LinkedList-删除元素"><a href="#LinkedList-删除元素" class="headerlink" title="LinkedList 删除元素"></a>LinkedList 删除元素</h2><p>在LinkedList 删除元素的操作中，我们首先要通过循环找到要删除的元素，如果要删除的位置处于List的前半段，就从前往后找；若其位置处于后半段，就从后往前找。<br>这样做的话，无论要删除较为靠前或较为靠后的元素都是非常高效的，但如果List 拥有大量元素，移除的元素又在List的中间段，那效率相对来说会很低。</p>
<h2 id="LinkedList-遍历元素"><a href="#LinkedList-遍历元素" class="headerlink" title="LinkedList 遍历元素"></a>LinkedList 遍历元素</h2><p>LinkedList的获取元素操作实现跟LinkedList的删除元素操作基本类似，通过分前后半段来循环查找到对应的元素。但是通过这种方式来查询元素是非常低效的，特别是在for循环遍历的情况下，每一次循环都会去遍历半个List。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/05/30/《字符串性能优化的一点总结》/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/30/《字符串性能优化的一点总结》/" itemprop="url">《字符串性能优化的一点总结》</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-30T16:58:21+08:00">
                2019-05-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本篇会从基本概念和优化方案这两个方面来阐述字符串性能优化方面的原理。</p>
<p>String是内存中占用空间最大的对象。</p>
<p>我们首先看下面的代码，运行一下，查看下自己对String的基本原理是否掌握。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      String str1 = <span class="string">"abc"</span>;</span><br><span class="line">      String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">      String str3 = str2.intern();</span><br><span class="line"></span><br><span class="line">      System.out.println(str1==str2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">      System.out.println(str2==str3); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">      System.out.println(str1==str3); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>str1是在字符串常量池创建的</li>
<li>str2是在堆中创建</li>
<li>str3去字符串常量池找到了str1引用的对象，所以就不会新建字符串对象，而是返回str1指向的对象了</li>
</ol>
</blockquote>
<h2 id="String对象的不可变性"><a href="#String对象的不可变性" class="headerlink" title="String对象的不可变性"></a>String对象的不可变性</h2><p>在实现代码中<code>String</code>类被final关键字修饰了，而且变量char数组也被final修饰了。</p>
<p>我们知道类被<code>final</code> 修饰代表该类不可继承，而char被final+private修饰，代表了<code>String</code>对象不可被更改。Java实现的这个特性叫作<code>String</code>对象的不可变性，即<code>String</code> 对象一旦创建成功，就不能再对它进行改变。</p>
<p><strong>好处：</strong></p>
<blockquote>
<p>第一，保证 String对象的安全性。假设String 对象是可变的，那么String对象将可能被恶意修改。</p>
<p>第二，保证 hash 属性值不会频繁变更，确保了唯一性，使得类似HashMap容器才能实现相应的key-value缓存功能。</p>
<p>第三，可以实现字符串常量池。在Java中，通常有两种创建字符串对象的方式，一种是通过字符串常量的方式创建，如String str=“abc”；另一种是字符串变量通过new形式的创建，如String str=new String（”abc”）。</p>
<p>当代码中使用第一种方式创建字符串对象时，JVM首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。</p>
</blockquote>
<h2 id="String对象的优化"><a href="#String对象的优化" class="headerlink" title="String对象的优化"></a><strong>String对象的优化</strong></h2><ol>
<li><p>字符串的拼接建议使用<code>StringBuffer</code>和<code>StringBuilder</code></p>
<blockquote>
<p><code>StringBuffer</code>是线程安全的，但是性能比不上<code>StringBuilder</code></p>
</blockquote>
</li>
<li><p>在字符串常量中，默认会将对象放入常量池；在字符串变量中，对象是会创建在堆内存中。如果调用<code>intern</code>方法，会去查看字符串常量池中是否有等于该对象的字符串，如果没有则在常量池中新增该对象，并返回该对象引用；如果有，则返回常量池中的字符串。堆内存中原有的对象由于没有引用指向它，将会通过垃圾回收器回收。</p>
</li>
<li><p>字符串的分割，这种方法在编码中也很最常见。</p>
<p><code>Split()</code>方法使用了正则表达式实现了其强大的分割功能，而正则表达式的性能是非常不稳定的，使用不恰当会引起回溯问题，很可能导致CPU居高不下。</p>
<p>所以我们应该慎重使用<code>Split()</code>方法，我们可以用<code>String.indexOf()</code>方法代替<code>Split()</code>方法完成字符串的分割。如果实在无法满足需求，你就在使用<code>split()</code>方法时，对回溯问题加以重视就可以了。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/05/25/Spring-Cloud-Eureka服务注册与发现/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/25/Spring-Cloud-Eureka服务注册与发现/" itemprop="url">Spring Cloud Eureka服务注册与发现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-25T21:34:45+08:00">
                2019-05-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h2><p>服务注册与发现是微服务必须面对的问题，而Eureka Server是被广泛应用的高可用服务注册与发现的组件，本篇主要从实际操作和基本原理方面探讨Eureka的服务注册与发现原理。</p>
<h2 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h2><h3 id="搭建EurekaServer"><a href="#搭建EurekaServer" class="headerlink" title="搭建EurekaServer"></a>搭建EurekaServer</h3><ol>
<li><p>引入pom.xml文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>搭建注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@EnableEurekaServer</code>的作用其实就是激活Eureka Server的自动配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(EurekaServerMarkerConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableEurekaServer &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerMarkerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Marker <span class="title">eurekaServerMarkerBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Marker();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Marker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看<code>EurekaServerMarkerConfiguration</code>,它知识new了一个Marker对象，而Marker对象是为了实现Eureka Server的自动配置，看完下面的代码你就明白了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(EurekaServerInitializerConfiguration.class)</span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(EurekaServerMarkerConfiguration.Marker.class)<span class="comment">//Marker</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123; EurekaDashboardProperties.class,</span><br><span class="line">		InstanceRegistryProperties.class &#125;)</span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/eureka/server.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerAutoConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>这个就是<code>@ConditionalOnBean(EurekaServerMarkerConfiguration.Marker.class)</code>这个条件注解，配合<code>EurekaServerAutoConfiguration</code>这个Eureka Server的配置类来实现Eureka Server的自动化配置</p>
</li>
<li><p>配置Eureka Server（单节点）</p>
<p><code>applicaion.properties</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 单节点情况下，Eureka Server不用自己注册到自己</span><br><span class="line">eureka.client.register-with-eureka=false</span><br><span class="line">## 关闭Eureka Server的自我保护机制（该配置只有在开发环境中才可以打开）</span><br><span class="line">eureka.server.enable-self-preservation=false</span><br></pre></td></tr></table></figure>
<p>加上此配置项后，我们启动Eureka Server发现控制台如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> main] com.netflix.discovery.DiscoveryClient    : Disable delta property : false</span><br><span class="line">2019-05-25 16:13:13.660  INFO 15912 --- [           main] com.netflix.discovery.DiscoveryClient    : Single vip registry refresh property : null</span><br><span class="line">2019-05-25 16:13:13.661  INFO 15912 --- [           main] com.netflix.discovery.DiscoveryClient    : Force full registry fetch : false</span><br><span class="line">2019-05-25 16:13:13.661  INFO 15912 --- [           main] com.netflix.discovery.DiscoveryClient    : Application is null : false</span><br><span class="line">2019-05-25 16:13:13.661  INFO 15912 --- [           main] com.netflix.discovery.DiscoveryClient    : Registered Applications size is zero : true</span><br><span class="line">2019-05-25 16:13:13.661  INFO 15912 --- [           main] com.netflix.discovery.DiscoveryClient    : Application version is -1: true</span><br><span class="line">2019-05-25 16:13:13.661  INFO 15912 --- [           main] com.netflix.discovery.DiscoveryClient    : Getting all instance registry info from the eureka server</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该注册中心还没有服务实例注册进来，说明我们刚刚的配置是生效的</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>总结：Eureka Server本身就是一个注册中心，不涉及业务，所以本身的搭建还是比较简单的。</p>
</blockquote>
<h3 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h3><p>Eureka Client需要将自己注册到服务注册中心，这就是<strong>服务注册</strong>。</p>
<h3 id="搭建Eureka-Client"><a href="#搭建Eureka-Client" class="headerlink" title="搭建Eureka Client"></a>搭建Eureka Client</h3><ol>
<li><p>引入pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>添加注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看注解<code>EnableDiscoveryClient</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import</span>(EnableDiscoveryClientImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDiscoveryClient &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * If true, the ServiceRegistry will automatically register the local server.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">autoRegister</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>EnableDiscoveryClientImportSelector</code>点进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order</span>(Ordered.LOWEST_PRECEDENCE - <span class="number">100</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableDiscoveryClientImportSelector</span></span></span><br><span class="line"><span class="class">		<span class="keyword">extends</span> <span class="title">SpringFactoryImportSelector</span>&lt;<span class="title">EnableDiscoveryClient</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不用看下面了，我们直接就知道这个借助了工具类<code>SpringFactoriesLoader</code>去项目所有jar包下面去找<code>spring.factories</code>中如下的配置：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.cloud.client.discovery.EnableDiscoveryClient=\</span><br><span class="line">org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration</span><br></pre></td></tr></table></figure>
<p><code>EurekaDiscoveryClientConfiguration</code>就被我们找到了，我们留意一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(EurekaClientConfig.class)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"eureka.client.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaDiscoveryClientConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Marker</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Marker <span class="title">eurekaDiscoverClientMarker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Marker();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>又出现了Marker()，我们很习惯了，这是个标记，没有实际意义，一个辅助的Bean而已。</p>
</blockquote>
<p>我们按alt+F7</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(EurekaClientConfig.class)</span><br><span class="line"><span class="meta">@Import</span>(DiscoveryClientOptionalArgsConfiguration.class)</span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(EurekaDiscoveryClientConfiguration.Marker.class) <span class="comment">//</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"eureka.client.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@AutoConfigureBefore</span>(&#123; NoopDiscoveryClientAutoConfiguration.class,</span><br><span class="line">		CommonsClientAutoConfiguration.class, ServiceRegistryAutoConfiguration.class &#125;)</span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(name = <span class="string">"org.springframework.cloud.autoconfigure.RefreshAutoConfiguration"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p><code>@ConditionalOnBean(EurekaDiscoveryClientConfiguration.Marker.class)</code>,</p>
<p>原来千呼万唤使出来，这个<code>Marker</code>只为了召唤出<code>EurekaClientAutoConfiguration</code>自动配置类。</p>
</li>
</ol>
<p>   到这里整个<code>EnableDiscoveyClient</code>注解的意义就很清晰了。（这个注解是Spring Cloud的common包提供的，并不是netflix的）</p>
<ol start="3">
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 注册中心的地址（单节点）</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:8761/eureka/</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Eureka-Server的高可用"><a href="#Eureka-Server的高可用" class="headerlink" title="Eureka Server的高可用"></a>Eureka Server的高可用</h2><p>   单节点的Eureka Server太容易挂掉了，所以我们要部署多台Eureka Server，并且Eureka Server之间要互相注册，这样每个Eureka Server都能获取到注册表的信息。</p>
<p>假设在高可用场景下，其中一台Eureka Server宕机了，会出现怎样的情况？</p>
<blockquote>
<p>另一台eureka Server仍然会维护者注册表信息。</p>
</blockquote>
<h2 id="服务发现的两种方式"><a href="#服务发现的两种方式" class="headerlink" title="服务发现的两种方式"></a>服务发现的两种方式</h2><h3 id="客户端发现"><a href="#客户端发现" class="headerlink" title="客户端发现"></a>客户端发现</h3><ul>
<li>Eureka</li>
</ul>
<p>如果别人的服务不是采用Java语言开发，那还能注册到服务注册中心吗？</p>
<blockquote>
<p>微服务的特点：<strong>异构</strong></p>
<ul>
<li>不同语言</li>
<li>不同类型的数据库</li>
</ul>
</blockquote>
<p>其他语言的服务如何从服务注册中心获取其他服务，并进行调用呢？</p>
<blockquote>
<p>Spring Cloud可以实现其他语言纳入自己的服务治理体系。</p>
</blockquote>
<h3 id="服务端发现"><a href="#服务端发现" class="headerlink" title="服务端发现"></a>服务端发现</h3><p>代理介入</p>
<ul>
<li>Nginx</li>
<li>Zookeeper</li>
<li>Kubernates</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>Eureka Client会定期和Eureka Server维持一个心跳，如果超过某个时间，Eureka Server还是没收到Eureka Client发送的心跳，那么Eureka Server就会把该服务实例从注册表中剔除掉</p>
</li>
<li><p>Eureka Client也会定期去Eureka Server那拉取服务实例的注册表信息，这个时间可以设置</p>
<blockquote>
<p>Eureka Server中在内存中维护的注册表，有三层Map，可以很好的满足Eureka Client对注册表信息的拉取与修改（比如突然新增加了一台服务实例），三层Map很好的满足了多个Eureka Client的高并发访问场景</p>
</blockquote>
</li>
<li><p>我们服务注册中心高可用的场景，Eureka Client设置好多个注册中心的地址即可</p>
</li>
<li><p>我觉得Eureka Server是为了维护分布式系统中的高可用而牺牲了一致性，这个有点过度极端设计的嫌疑</p>
</li>
</ul>
<blockquote>
<p>Eureka 具有心跳检查，健康检查，负载均衡等功能。</p>
<p>Eureka的高可用，生产环境要部署多台Eureka Server。</p>
</blockquote>
<p><strong>在分布式系统中，服务注册中心是最重要的基础部分。</strong></p>
<p>why？</p>
<p>分布式系统中为什么需要服务发现？</p>
<blockquote>
<p>注册中心维护多个服务的实例，就像是一个字典，一个服务要想调用其他服务，就直接从注册中心获取服务就可以了，这个就是服务发现。因为分布式系统中，服务实例有无数多个，并且服务实例也是动态变化的，所以需要依赖注册中心来维护这些变化的无数个服务实例。</p>
</blockquote>
<p><strong>注册中心是服务之间产生各种各样关系的桥梁。</strong></p>
<blockquote>
<p>微服务的落地，不是有什么固定套路，要具体问题具体分析，重要的是微服务的原理，而不是采用何种语言，何种固定套路。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/05/10/Kafka的主题与分区/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/10/Kafka的主题与分区/" itemprop="url">Kafka的主题与分区</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-10T14:39:12+08:00">
                2019-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>主题在kafka中可看作是消息的分类，而分区是消息的进一步分类。</p>
<blockquote>
<p>需要注意的是，主题与分区是逻辑上的概念。</p>
</blockquote>
<h2 id="主题的管理"><a href="#主题的管理" class="headerlink" title="主题的管理"></a>主题的管理</h2><h3 id="创建主题"><a href="#创建主题" class="headerlink" title="创建主题"></a>创建主题</h3><p>我们采用<code>kafka-topics.sh</code> 脚本来创建主题</p>
<p>例如：<code>bin/kafka-topics .sh -- zookeeper localhost: 2181/kafka --create --topic topic-create --partitions 4 --replication- factor 2</code> </p>
<blockquote>
<p>创建一个分区数为4，副本因子为2的主题topic-create</p>
</blockquote>
<p>在执行完脚本之后， Kafka 会在 log.dir 或 log.dirs 参数所配置的目录下创建相应的主题分区，默认情况下这个目录为/tmp/kafka-logs/ 。</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/Kafka主题，分区，副本的关系.jpg" alt=""></p>
<p>​                                                                [<strong>Kafka主题，分区和副本之间的关系</strong>]</p>
<p>主题和分区是逻辑上的，而副本是物理上的一个存在，而每一个副本都对应一个日志文件。同时我们可以通过zookeeper获取该主题分区下。</p>
<p>我们回顾下创建主题的指令：</p>
<p><code>bin/kafka-topics .sh -- zookeeper localhost: 2181/kafka --create --topic topic-create --partitions 4 --replication-factor 2</code> </p>
<ul>
<li><p><code>zookeeper</code>：zookeeper的连接地址</p>
</li>
<li><p><code>partitions</code>：该主题的分区数</p>
</li>
<li><p><code>replication-factor</code>：副本因子</p>
</li>
<li><p><code>--topic topic-create</code>：主题名称</p>
</li>
<li><p><code>--create</code>：创建主题</p>
<blockquote>
<ul>
<li>list  </li>
<li>describe</li>
<li>alter</li>
<li>delete</li>
</ul>
</blockquote>
</li>
</ul>
<p>我们将create换成describe，顾名思义，就是描述我们之前创建好的主题信息</p>
<p><code>bin/kafka-topics.sh -- zookeeper localhost:2181/kafka --describe --topic topic-create</code> </p>
<p>该指令的输出为：</p>
<blockquote>
<p>Topic:   topic-create     PartitionCount:4     ReplicationFactor:2  Configs: </p>
<p>Topic:  topic-create    Partition:0    Leader:2    Replicas:2,0    Isr:2,0</p>
<p>Topic:  topic-create    Partition:1    Leader:0    Replicas:0,1   Isr:0,1</p>
<p>Topic:  topic-create    Partition:2    Leader:1    Replicas:1,2   Isr:1,2</p>
<p>Topic:  topic-create   Partition:3   Leader:2     Replicas:2,1   Isr:2,1</p>
</blockquote>
<ul>
<li><code>Topic</code>：主题名</li>
<li><code>Partition</code>：分区号</li>
<li><code>PartitionCount</code>：分区总数</li>
<li><code>ReplicationFactor</code>：副本因子</li>
<li><code>Leader</code>：表示该分区leader对应的brokerId</li>
<li><code>Configs</code>：表示创建和修改主题时的配置信息</li>
<li><code>Replicas</code>：分区所有的副本分配情况</li>
<li><code>Isr</code>：表示分区的 ISR 集合 </li>
</ul>
<p>现在归纳一下使用<code>kafka-topics.sh</code>创建主题的模板指令：</p>
<blockquote>
<p>kafka-topics.sh–zookeeper <a href="String:hosts" target="_blank" rel="noopener">String:hosts</a>-create–topic [String:topic]–<br>partitions&lt;Integer:# of partitions&gt;-replication-factor &lt;Integer:replication factor&gt;</p>
</blockquote>
<p><code>kafka-topics.sh</code>提供了一个<code>replica-assignment</code> 参数指定分区部分的方案用来创建一个主题。</p>
<blockquote>
<p>[root@ node1kafka 2.11-2.0.0]# bin/kafka-topics. sh–zookeeper 1ocalhost:2181/ kafka –create  –topic topic-create-same    –replica-assignment    2:0,0:1,1:2,2:1<br>Created topic “topic-create-same”.</p>
</blockquote>
<p>我们用<code>describle</code>指令查看分区副本的详细情况</p>
<blockquote>
<p>[ rootenodel kafka 2.11-2.0.0]# bin/kafka-topics. sh–zookeeper localhost:2181/kafka<br>–describe–topic   topic-create-same  Topic: topic-create-same   PartitionCount:4 ReplicationFactor:2 Configs: </p>
<p>Topic: topic-create-same  Partition:0   Leader:2     Replicas:2,0    Isr:2,0<br>Topic: topic-create-same  Partition:1   Leader:0     Replicas:0,1    Isr:0,1<br>Topic: topic-create-same  Partition:2   Leader:1     Replicas:1,2    Isr:1,2<br>Topic: topic-create-same  Partition:3   Leader:2      Replicas:2,1    Isr:2,1</p>
</blockquote>
<p>其实<code>kafka-topics.sh</code>就是通过<code>kafka.admin.TopicCommand</code>来创建主题</p>
<ol>
<li><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>创建主题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createTopic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String[] options = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">               <span class="string">"--zookeeper"</span>, <span class="string">"localhost:2181/kafka"</span>,</span><br><span class="line">               <span class="string">"--create"</span>,</span><br><span class="line">               <span class="string">"--replication-factor"</span>, <span class="string">"1"</span>,</span><br><span class="line">               <span class="string">"--partitions"</span>, <span class="string">"1"</span>,</span><br><span class="line">               <span class="string">"--topic"</span>, <span class="string">"topic-create-api"</span></span><br><span class="line">       &#125;;</span><br><span class="line">       TopicCommand.main(options);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>控制台输出结果：</p>
<blockquote>
<p>Created topic “topic-create-api”.</p>
</blockquote>
<h3 id="分区副本的分配"><a href="#分区副本的分配" class="headerlink" title="分区副本的分配"></a>分区副本的分配</h3><p>其实之前生产者与消费者，就有分区分配的概念：</p>
<ul>
<li><p>生产者的分区分配：为每条消息分配要发往的分区</p>
</li>
<li><p>消费者的分区分配：为消费者指定可以消费的分区</p>
</li>
</ul>
<blockquote>
<p>而创建主题的分区副本分配：为Kafka集群制定创建主题时的分区分配副本方案，就是在哪个broker中创建哪些分区的副本。</p>
</blockquote>
<h3 id="查看主题信息"><a href="#查看主题信息" class="headerlink" title="查看主题信息"></a>查看主题信息</h3><p><code>kafka-topics.sh</code>的<code>describe/list</code>指令可以用来查看主题信息。</p>
<ol>
<li><p>list</p>
<blockquote>
<p>bin /kafka-topics.sh  –zookeeper localhost : 2181/kafka   -list </p>
</blockquote>
<p>查看当前所有可用的主题</p>
</li>
<li><p>describe</p>
<blockquote>
<p>bin/kafka-topics.sh – zookeeper localhost:2181/kafka  –describe –topic  topic-create,topic-demo </p>
</blockquote>
<p>查看多个主题的信息</p>
</li>
</ol>
<h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>在主题被创建之后，我们仍然可以修改主题的信息，比如修改分区个数等等。</p>
<blockquote>
<p>bin/kafka-topics . sh – zookeeper localhost:2181/kafka –alter –topic topic-config  –partitions 3 </p>
</blockquote>
<p>修改topic-config主题的分区数为3</p>
<blockquote>
<p>修改分区数的时候，会影响生产者的发消息时，根据相同的key计算分区下标的结果，导致原来发往A分区的，随着分区数的变化，发给B分区。</p>
</blockquote>
<p>Kafka目前不支持减少分区，很明显的，如果减少了一个分区，那么这个分区中的消息是删除掉还是交给其他的主题，没有一个可靠的方案。</p>
<blockquote>
<p>bin/kafka-topics. sh – zookeeper localhost:2181/kafka – alter –topic topic- config –config max.message.bytes=20000 </p>
</blockquote>
<p> 修改主题的配置信息</p>
<h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>之前我们创建，查看和修改主题，都是用的<code>kafka-topics.sh</code>脚本来实现的，而配置管理主要是通过<code>kafka-configs.sh</code>来实现的。</p>
<p>我们之前也可以通过<code>kafka-topics.sh</code>来实现配置修改和查看，但是更推荐使用<code>kafka-configs.sh</code>。</p>
<blockquote>
<p>[ rootenodel kafka_2.11-2.0.0]# bin/kafka-topics. sh–zookeeper localhost:2181/<br>kafka–describe –topic topic-config–topics-with-overrides</p>
<p> Topic: topic-config    PartitionCount:3   ReplicationFactor:1</p>
<p>Configs:  max. message. bytes=10000,    cleanup. policy=compact</p>
</blockquote>
<h3 id="删除主题"><a href="#删除主题" class="headerlink" title="删除主题"></a>删除主题</h3><blockquote>
<p>[rootenodel kafka_2.11-2.0.0]#<code>bin/kafka-topics.sh  --zookeeper localhost:2181/kafka  --delete  --topic topic-delete</code> </p>
<p>Topic topic-delete is marked for deletion.</p>
<p>Note:This will have no impact if delete.topic.enable is not set to true.</p>
</blockquote>
<h2 id="KafkaAdminClient"><a href="#KafkaAdminClient" class="headerlink" title="KafkaAdminClient"></a>KafkaAdminClient</h2><p>我们可以使用<code>KakfaAdminClient</code>对主题进行管理</p>
<ul>
<li>创建主题：<code>CreateTopicsResult createTopics（Collection-NewTopic&gt;newTopics）</code></li>
<li>删除主题：<code>DeleteTopicsResult deleteTopics（Collection&lt;String&gt;topics）</code></li>
<li>列出所有可用的主题：<code>ListTopicsResult listTopics(）</code></li>
<li>查看主题的信息：<code>DescribeTopicsResult describe Topics（Collection&lt;String&gt;topicNames）</code></li>
<li>查询配置信息：<code>DescribeConfigsResult describeConfigs（Collection&lt;ConfigResource&gt; resources）</code></li>
<li>修改配置信息：<code>AlterConfigsResult alterConfigs（Map&lt;ConfigResource，Config&gt;configs）</code></li>
<li>增加分区：<code>CreatePartitionsResult createPartitions（Map&lt;String，NewPartitions&gt;newPartitions）</code></li>
</ul>
<p>创建一个分区数为4，副本因子为1的主题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建主题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTopic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String brokerList = <span class="string">"localhost:9092"</span>;</span><br><span class="line">    String topic = <span class="string">"topic-admin"</span>;</span><br><span class="line"></span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, brokerList);</span><br><span class="line">    props.put(AdminClientConfig.REQUEST_TIMEOUT_MS_CONFIG, <span class="number">30000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据配置项创建AdminClient</span></span><br><span class="line">    AdminClient client = AdminClient.create(props);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建主题信息： 主题名称，分区数，副本因子</span></span><br><span class="line">    NewTopic newTopic = <span class="keyword">new</span> NewTopic(topic, <span class="number">4</span>, (<span class="keyword">short</span>) <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建主题的核心：</span></span><br><span class="line"><span class="comment">     * 1. 客户端根据方法的调用创建相应的协议请求CreateTopicRequest</span></span><br><span class="line"><span class="comment">     * 2. 客户端将请求发送至服务端</span></span><br><span class="line"><span class="comment">     * 3. 服务端处理客户端的请求并返回响应CreateTopicResponse</span></span><br><span class="line"><span class="comment">     * 4. 客户端接收响应并解析处理</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主题</span></span><br><span class="line">    CreateTopicsResult result = client.createTopics(Collections.singleton(newTopic));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result.all().get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭AdminClient</span></span><br><span class="line">    client.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分区的管理"><a href="#分区的管理" class="headerlink" title="分区的管理"></a>分区的管理</h2><h3 id="优先副本的选举"><a href="#优先副本的选举" class="headerlink" title="优先副本的选举"></a>优先副本的选举</h3><p>分区使用多副本机制来提升可靠性，但是只有leader副本对外提供读写服务，而follower副本只负责在内部进行消息的同步。</p>
<p>如果一个分区的leader副本不可用，那么就意味着整个分区不可用，Kafka就会从剩余的follower副本中挑选出一个新的leader副本来继续对外提供副本。</p>
<blockquote>
<p>这个就是分布式消息的可靠性体现，这个leader选举，可以类比Redis的主从中的哨兵模式，主库挂了，哨兵就会对从库进行选举，原理不一定一样，但是思路可能相似（也就是怎么选leader/master的问题）</p>
</blockquote>
<p>当宕机恢复后的leader,只能作为follower副本存在。</p>
<h4 id="负载不均衡"><a href="#负载不均衡" class="headerlink" title="负载不均衡"></a>负载不均衡</h4><p>随着时间的更替，Kafka 集群的 broker 节点不可避免地会遇到岩机或崩溃的问题 ， 当分区的 leader 节点发生故障时 ，其中一个 follower 节点就会成为新的 leader 节点，这样就会导致集群的<strong>负载不均衡</strong> ， 从而影响整体的健壮性和稳定性 。  </p>
<h4 id="优先副本"><a href="#优先副本" class="headerlink" title="优先副本"></a>优先副本</h4><p>为了能够有效地治理负载失衡的情况 ， Kafka 引入了<strong>优先副本</strong>（ preferred replica ） 的概念 。所谓的优先副本是指在 AR 集合列表中的第一个副本 。 比如主题 topic-partitions 中分区0的 AR 集合列表（ Replicas ）为 ［ 1 ,2 ,0］ ， 那么分区 0 的优先副本即为 1 。 理想情况下，优先副本就是该分区的 leader 副本，所以也可以称之为 preferred leader。 Kafka 要确保所有主题的优先副本在 Kafka 集群中均匀分布，这样就保证 了所有分区 的 leader 均衡分布 。 如果 leader 分布过于集中， 就会造成集群负载不均衡 。</p>
<p>所谓的优先副本的选举是指通过一定的方式促使优先副本选举为 leader 副本，以此来促进集群的负载均衡 ， 这一行为也可以称为“分区平衡” 。</p>
<p>需要注意 的是 ， 分区平衡并不意味着 Kafka 集群的负载均衡，因为还要考虑集群中的分区分配是否均衡。更进一步，每个分区的 leader 副本的负载也是各不相同 的， 有些 leader 副本的负载很高，比如需要承载 TPS为 30000 的负荷， 而有些 leader 副本只需承载个位数的 负荷 。 也就是说 ， 就算集群中的分区分配均衡、 leader 分配均衡 ，也并不能确保整个集群的负载就是均衡的 ，还需要其他一些硬性的指标来做进一步的衡量。</p>
<blockquote>
<p>参考自朱忠华《深入理解Kafka：核心设计与实践原理》p133</p>
</blockquote>
<h3 id="修改副本因子"><a href="#修改副本因子" class="headerlink" title="修改副本因子"></a>修改副本因子</h3><p>创建主题之后我们还可以修改分区的个数，同样可以修改副本因子（副本数）。</p>
<p>修改副本因子的使用场景也很多，比如在创建主题时填写了错误的副本因子数而需要修改，再比如运行一段时间之后想要通过增加副本因子数来提高容错性和可靠性。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/29/3-消费者/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/29/3-消费者/" itemprop="url">3.消费者</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-29T20:21:21+08:00">
                2019-04-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="消费者与消费者组"><a href="#消费者与消费者组" class="headerlink" title="消费者与消费者组"></a>消费者与消费者组</h1><p>生产者发送消息到Kafka Broker节点，而我们的消费者就订阅了Kafka的主题，从订阅的主题中拉取消息。</p>
<p>而每一个消费者都对应一个消费者组。当消息被发布到主题后，只会被投递给订阅它的消费者组中的一个消费者。</p>
<p>每一个分区只能被一个消费者所消费。</p>
<p>对于消息中间件而言 ， 一般有两种消息投递模式：</p>
<p><strong>点对点 （ P2P, Point-to-Point）模式和发布／订阅（ Pub/Sub ）模式</strong> 。</p>
<p> 点对点模式是基于队列的，消息生产者发送消息到队列，消息消费者从队列中接收消息。</p>
<p>发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题（ Topic ），主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者从主题中订阅消息。</p>
<p>主题使得消息的订阅者和发布者互相保持独立，不需要进行接触即可保证消息的传递，发布／订阅模式在消息的一对多广播时采用 。</p>
<p> Kafka 同时支持两种消息投递模式，而这正是得益于消费者与消费组模型的契合：</p>
<p>如果所有的消费者都隶属于同一个消费组，那么所有的消息都会被均衡地投递给每一个消费者，即每条消息只会被一个消费者处理，这就相当于点对点模式的应用 。</p>
<p>如果所有的消费者都隶属于不同的消费组，那么所有的消息都会被广播给所有的消费者，即每条消息会被所有的消费者处理，这就相当于发布／订阅模式的应用 。 </p>
<blockquote>
<p>消费者组是一个逻辑概念，而消费者是一个实际存在的应用。</p>
</blockquote>
<h1 id="消费者客户端开发"><a href="#消费者客户端开发" class="headerlink" title="消费者客户端开发"></a>消费者客户端开发</h1><ol>
<li>配置消费者客户端参数及创建相应的消费者实例</li>
<li>订阅主题</li>
<li>拉取消息并消费</li>
<li>提交消费位移</li>
<li>关闭消费者实例</li>
</ol>
<h2 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h2><p><strong>一个注意点</strong></p>
<p>zk启动（下面这种方式是不正确的，要自己去安装zk，用kafka自带zk会出错）</p>
<p><code>bin\windows\zookeeper-server-start.bat config\zookeeper.properties</code></p>
<p>kafka启动</p>
<p><code>bin\windows\kafka-server-start.bat config\server.properties</code></p>
<blockquote>
<p>我发现一个问题，在windows平台使用kafka_2.12-2.1.0的时候，不能使用kafka自带的zookeeper，需要自行安装zk并启动。</p>
</blockquote>
<p>为什么突然间kafka就不能正常地进行消息的生产与消费？</p>
<p>我决定重装zookeeper和Kafka，创建了一个新的Topic “test”</p>
<p><code>bin\windows\kafka-topics.bat --create --zookeeper localhost:2181/kafka --replication-factor 1 --partitions 1 --topic test</code></p>
<blockquote>
<p>zookeeperh后面的地址是Kafka在bin/server.properties中配置的。这里多了 /kafka，一定要注意。</p>
</blockquote>
<p>接下来就使用了命令行测试是否能够正常的生产和消费消息。==It’s OK==</p>
<p>==<a href="https://blog.csdn.net/tianmanchn/article/details/78943147" target="_blank" rel="noopener">Kafka安装详细过程，无错误</a>==</p>
<h2 id="消费者客户端代码"><a href="#消费者客户端代码" class="headerlink" title="消费者客户端代码"></a>消费者客户端代码</h2><p>现在测试客户端，依然可以正常的收发消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">topic =test, partition = <span class="number">0</span>, offset =<span class="number">17</span></span><br><span class="line">key =<span class="keyword">null</span>,value =Hello,Kafka</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerFastStart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String brokerList = <span class="string">"127.0.0.1:9092"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String topic = <span class="string">"test"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String groupId = <span class="string">"group.demo"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">initConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Kafka的配置参数很多，根据业务需要灵活调整</span></span><br><span class="line">        properties.put(<span class="string">"key.deserializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        properties.put(<span class="string">"value.deserializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        <span class="comment">// 设置要连接到Kafka集群的broker清单，一般建议设置2个，防止其中一个broker宕机后，消费者仍然能够连接到Kafka集群</span></span><br><span class="line">        properties.put(<span class="string">"bootstrap.servers"</span>, brokerList);</span><br><span class="line">        <span class="comment">//设置消费组的名称 ,一般要表明业务</span></span><br><span class="line">        properties.put(<span class="string">"group.id"</span>, groupId);</span><br><span class="line">        properties.put(<span class="string">"client.id"</span>, <span class="string">"consumer.client.id.demo"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Properties props = initConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建消费者实例</span></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;String, String&gt;(props);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅一个主题</span></span><br><span class="line">        consumer.subscribe(Arrays.asList(topic));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环消费信息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"topic ="</span> + record.topic() +</span><br><span class="line">                        <span class="string">", partition = "</span> + record.partition() +</span><br><span class="line">                        <span class="string">", offset ="</span> + record.offset());</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"key ="</span> + record.key() +</span><br><span class="line">                        <span class="string">",value ="</span> + record.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="订阅某些主题的特定分区"><a href="#订阅某些主题的特定分区" class="headerlink" title="订阅某些主题的特定分区"></a>订阅某些主题的特定分区</h2><p>API : <code>KafkaConsumer#assign(Collection&lt;TopicPartition&gt; partitions)</code></p>
<h3 id="TopicPartition"><a href="#TopicPartition" class="headerlink" title="TopicPartition"></a>TopicPartition</h3><p>看下方法的成员变量中的<code>TopicPartition</code>,它在客户端表示分区。重点在于主题与分区之间的映射关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicPartition</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> partition;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TopicPartition</span><span class="params">(String topic, <span class="keyword">int</span> partition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partition = partition;</span><br><span class="line">        <span class="keyword">this</span>.topic = topic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> partition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">topic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> topic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略hashCode(),equals(),toString()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>TopicPartition</code>让我们看到了主题topic和分区partition之间的映射关系</p>
</blockquote>
<p><code>consumer.assign(Arrays.asList(new TopicPartition(&quot;test&quot;, 0)));</code></p>
<blockquote>
<p>订阅test主题下的0分区</p>
</blockquote>
<p><code>Arrays.asList()</code>就是将多个对象放进一个新的ArrayList中。相当于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TopicPartition&gt; list=<span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="keyword">new</span> TopicPartition(<span class="string">"test"</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<h3 id="PartitionInfo"><a href="#PartitionInfo" class="headerlink" title="PartitionInfo"></a>PartitionInfo</h3><p>但是实际场景，我们可能不清楚某个主题到底有多少个分区。那么我们可以通过如下方法来获取某个主题下的分区</p>
<p> <code>List&lt;PartitionInfo&gt; partitionInfoList =consumer.partitionsFor(&quot;test&quot;);</code></p>
<p><code>PartitionInfo</code>为主题的分区元数据信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic; <span class="comment">//主题名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> partition; <span class="comment">// 分区编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node leader; <span class="comment">// 分区的leader副本所在位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node[] replicas; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node[] inSyncReplicas;</span><br><span class="line">	<span class="comment">// 省略了方法   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Node</code>类主要参数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Node NO_NODE = <span class="keyword">new</span> Node(-<span class="number">1</span>, <span class="string">""</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String idString;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String rack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="订阅某主题下所有分区"><a href="#订阅某主题下所有分区" class="headerlink" title="订阅某主题下所有分区"></a>订阅某主题下所有分区</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">		       </span><br><span class="line">List&lt;TopicPartition&gt; topicPartitionList = <span class="keyword">new</span> ArrayList&lt;TopicPartition&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某主题下所有分区的信息</span></span><br><span class="line">      List&lt;PartitionInfo&gt; partitionInfoList = consumer.partitionsFor(topic);</span><br><span class="line"><span class="keyword">if</span> (partitionInfoList == <span class="keyword">null</span> || partitionInfoList.size()==<span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (PartitionInfo partitionInfo : partitionInfoList) &#123;</span><br><span class="line"></span><br><span class="line">          topicPartitionList.add(<span class="keyword">new</span> TopicPartition(partitionInfo.topic(), 			              partitionInfo.partition()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 订阅主题的全部分区</span></span><br><span class="line">      consumer.assign(topicPartitionList);</span><br></pre></td></tr></table></figure>
<h2 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h2><p>取消订阅，就是在之前订阅的基础上取消订阅关系。就是清空订阅关系。</p>
<p><code>consumer.unsubscribe()</code></p>
<p><code>consumer.unsubscribe()</code></p>
<p>其实取消订阅就相当于订阅了空的主题。</p>
<p><code>consumer.subscribe(new ArraList&lt;String&gt;())</code></p>
<h2 id="订阅总结"><a href="#订阅总结" class="headerlink" title="订阅总结"></a>订阅总结</h2><p>其实我们<code>subscribe()</code>订阅一个主题，而不是某个主题的特定分区时，Kafka集群会分配消费者与分区之间的关系。这是一个动态的过程。有点类似于负载均衡。</p>
<p>而<code>align()</code>方法时没有这个功能的，它本身也不需要这个功能。</p>
<h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><p>我们收到的消息，只有经过反序列化才能正确读取。</p>
<p>先实现之前的序列化器</p>
<ol>
<li><p>需要传递的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ajin.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者传递到消费者的消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ajin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4606513799375884096L</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String companyName;</span><br><span class="line">    <span class="keyword">private</span> String position;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Company</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Company</span><span class="params">(String companyName, String position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.companyName = companyName;</span><br><span class="line">        <span class="keyword">this</span>.position = position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCompanyName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> companyName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompanyName</span><span class="params">(String companyName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.companyName = companyName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPosition</span><span class="params">(String position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.position = position;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>序列化器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ajin.serilaizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ajin.domain.Company;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.serialization.Serializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义序列化器 &#123;<span class="doctag">@link</span> org.apache.kafka.common.serialization.Serializer&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ajin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompanySerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span>&lt;<span class="title">Company</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs, <span class="keyword">boolean</span> isKey)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(String topic, Company data) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] name, position;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.getCompanyName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                name = data.getCompanyName().getBytes();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                name = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data.getPosition() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                position = data.getPosition().getBytes();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                position = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">4</span> + <span class="number">4</span> +</span><br><span class="line">                    name.length + position.length);</span><br><span class="line"></span><br><span class="line">            buffer.putInt(name.length);</span><br><span class="line">            buffer.put(name);</span><br><span class="line"></span><br><span class="line">            buffer.putInt(position.length);</span><br><span class="line">            buffer.put(position);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> buffer.array();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ByteBuffer ：字节缓冲区</p>
</blockquote>
</li>
<li><p>反序列化器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ajin.deserilaizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ajin.domain.Company;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.serialization.Deserializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的反序列化器 &#123;<span class="doctag">@link</span> org.apache.kafka.common.serialization.Deserializer&#125;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 与序列化器 &#123;<span class="doctag">@link</span> com.ajin.serilaizer.CompanySerializer&#125;对应</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ajin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompanyDeSerializer</span> <span class="keyword">implements</span> <span class="title">Deserializer</span>&lt;<span class="title">Company</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENCODING = <span class="string">"UTF-8"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs, <span class="keyword">boolean</span> isKey)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Company <span class="title">deserialize</span><span class="params">(String topic, <span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data.length &lt; <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"data is not expected"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备好接收参数</span></span><br><span class="line">        <span class="keyword">int</span> nameLen, positionLen;</span><br><span class="line">        String name, position;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在此缓冲区的当前位置读取接下来的四个字节</span></span><br><span class="line">        nameLen = buffer.getInt();</span><br><span class="line">        <span class="keyword">byte</span>[] nameBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[nameLen];</span><br><span class="line">        <span class="comment">//字节从此缓冲区传输到给定的目标数组</span></span><br><span class="line">        buffer.get(nameBytes);</span><br><span class="line"></span><br><span class="line">        positionLen = buffer.getInt();</span><br><span class="line">        <span class="keyword">byte</span>[] positionBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[positionLen];</span><br><span class="line">        buffer.get(positionBytes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            name = <span class="keyword">new</span> String(nameBytes, ENCODING);</span><br><span class="line">            position = <span class="keyword">new</span> String(positionBytes, ENCODING);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Company(name, position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>厮大的建议：不要使用自定义的序列化或反序列化器。这样会增加生产者与消费者之间的耦合。</p>
<p>如果需要自定义，可以使用fastjson等工具来辅助编码。</p>
</blockquote>
<h1 id="消息消费模式"><a href="#消息消费模式" class="headerlink" title="消息消费模式"></a>消息消费模式</h1><p>Kafka中的消息消费，是消费者主动从服务端拉取消息，属于拉模式。</p>
<p>我们每次消费，需要根据上一次消费的位移来继续消费消息。就相当于看书一样，从上一次看过的地方往后继续看。这个消费位移不能直接存在内存中，需要做持久化处理。</p>
<blockquote>
<p>在旧消费者客户端中，消费位移是存储在 ZooKeeper 中的 。 而在新消费者客户端中，消费<br>位移存储在 Kafka 内部的主题 consumer offsets 中 。 这里把将消费位移存储起来（持久化）的<br>动作称为“提交“，消费者在消费完消息之后需要执行消费位移的提交。 </p>
</blockquote>
<p>消费者提交的位移是下一次需要消费的信息的位置。</p>
<h1 id="位移提交"><a href="#位移提交" class="headerlink" title="位移提交"></a>位移提交</h1><p>自动的位移提交是在poll方法拉取消息之后进行的，拉取完消息后，如果消费者挂了，那么它重启后会消费下面的消息，而不会继续消费上次宕机时没处理完的消息。这就是消息丢失的情形。</p>
<p>我们需要设置为手动提交位移，这样更能保证消息消费的完整性与准确性。</p>
<h1 id="再均衡"><a href="#再均衡" class="headerlink" title="再均衡"></a>再均衡</h1><blockquote>
<p>再均衡是指分区的所属权从一个消费者转移到另一消费者的行为，它为消费组具备高可用性和伸缩性提供保障，使我们可以既方便又安全地删除消费组内的消费者或往消费组内添加消费者。</p>
</blockquote>
<p>不过在再均衡发生期间，消费组内的消费者是无法读取消息的。 也就是说，在再均衡发生期间的这一小段时间 内，消费组会变得不可用 。</p>
<p>另外，当一个分区被重新分配给另一个消费者时， 消费者当前的状态也会丢失。比如消费者消费完某个分区中的一部分消息时还没有来得及提交消费位移就发生了再均衡操作 ，之后这个分区又被分配给了消费组内的另一个消费者，原来被消费完的那部分消息又被重新消费一遍，也就是发生了重复消费。一般情况下，应尽量避免不必要的再均衡的发生。</p>
<h2 id="ConsumerRebalanceListener"><a href="#ConsumerRebalanceListener" class="headerlink" title="ConsumerRebalanceListener"></a>ConsumerRebalanceListener</h2><p><strong>再均衡监听器</strong></p>
<p>我们<code>asign</code>方法直接订阅的某个Topic下的分区，那么它不适用于<code>ConsumerRebalanceListener</code> 。</p>
<p>在<code>subscribe()</code>方法中可以看到<code>ConsumerRebalanceListener</code> 的影子</p>
<blockquote>
<p>再均衡监昕器用来设定发生再均衡动作前后的一些准备或收尾的动作。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Collection&lt;String&gt; topics, ConsumerRebalanceListener listener)</span> </span>&#123;</span><br><span class="line">    acquire();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (topics.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// treat subscribing to empty topic list as the same as unsubscribing</span></span><br><span class="line">            <span class="keyword">this</span>.unsubscribe();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"Subscribed to topic(s): &#123;&#125;"</span>, Utils.join(topics, <span class="string">", "</span>));</span><br><span class="line">            <span class="keyword">this</span>.subscriptions.subscribe(topics, listener);</span><br><span class="line">            metadata.setTopics(subscriptions.groupSubscription());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">// 这个是正则表达式实现的模糊主题的匹配</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Pattern pattern, ConsumerRebalanceListener listener)</span> </span>&#123;</span><br><span class="line">        acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"Subscribed to pattern: &#123;&#125;"</span>, pattern);</span><br><span class="line">            <span class="keyword">this</span>.subscriptions.subscribe(pattern, listener);</span><br><span class="line">            <span class="keyword">this</span>.metadata.needMetadataForAllTopics(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们看一下<code>ConsumerRebalanceListener</code> 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerRebalanceListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 这个方法会在再均衡开始之前和消费者停止读取消息之后被调用。可以通过这个回调方法</span></span><br><span class="line"><span class="comment"> 来处理消费位移的提交，以此来避免一些不必要的重复消费现象的发生。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	参数 partitions 表示再均衡前所分配到的分区。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span></span>;</span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">这个方法会在重新分配分区之后和消费者开始读取消费之前被调用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	参数partitions表示再均衡后所分配到的分区 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 定义主题分区与该消费者应用程序对应的提交位移的映射关系</span></span><br><span class="line">      <span class="keyword">final</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; currentOffSets = <span class="keyword">new</span> HashMap&lt;TopicPartition, OffsetAndMetadata&gt;();</span><br><span class="line">      consumer.subscribe(Collections.singletonList(topic),</span><br><span class="line">              <span class="keyword">new</span> ConsumerRebalanceListener() &#123;</span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;			</span><br><span class="line">                      <span class="comment">// 发生再均衡的时候，提交当前消费者的位移</span></span><br><span class="line">                      consumer.commitSync(currentOffSets);</span><br><span class="line">                      <span class="comment">// 清空映射关系 ，因为已经取做再均衡了</span></span><br><span class="line">                      currentOffSets.clear();</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br><span class="line"></span><br><span class="line">     		 <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">          ConsumerRecords&lt;String, Company&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (ConsumerRecord&lt;String, Company&gt; record : records) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">              currentOffSets.put(</span><br><span class="line">                      <span class="keyword">new</span> TopicPartition(</span><br><span class="line">                              record.topic(), record.partition()</span><br><span class="line">                      ), <span class="keyword">new</span> OffsetAndMetadata(record.offset() + <span class="number">1</span>)</span><br><span class="line">              );</span><br><span class="line">              System.out.println(<span class="string">"topic ="</span> + record.topic() +</span><br><span class="line">                      <span class="string">", partition ="</span> + record.partition() +</span><br><span class="line">                      <span class="string">", offset ="</span> + record.offset());</span><br><span class="line"></span><br><span class="line">              System.out.println(<span class="string">"key ="</span> + record.key() +</span><br><span class="line">                      <span class="string">",value ="</span> + record.value());</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h1 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h1><p>消费者每次拉取消息的时候，会判断是否只有一个线程在操作。如果有多个线程就会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">    acquire();</span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kafka是非线程安全的。</p>
<p>我们可以开启多个线程增强一个消费者客户端的消费能力。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/29/Ribbon源码学习/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/29/Ribbon源码学习/" itemprop="url">Ribbon源码学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-29T09:23:01+08:00">
                2019-04-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    学习Ribbon和客户端负载均衡之后，对Ribbon基本会使用了，但是还是想深入了解下Ribbon是如何实现负载均衡，怎么去通过从注册中心Eureka Server拉取到的服务提供者信息去进行调用某一服务的某一个实例的。所以就决定学习下Ribbon的相关源码，以此达到更深入地理解Ribbon。</p>
<blockquote>
<p>注：本篇源码基于Spring Cloud Edgware.SR5版本</p>
</blockquote>
<h1 id="Spring-Cloud-Netflix-Ribbon-核⼼接⼝"><a href="#Spring-Cloud-Netflix-Ribbon-核⼼接⼝" class="headerlink" title="Spring Cloud Netflix Ribbon 核⼼接⼝"></a>Spring Cloud Netflix Ribbon 核⼼接⼝</h1><h2 id="负载均衡器客户端"><a href="#负载均衡器客户端" class="headerlink" title="负载均衡器客户端"></a>负载均衡器客户端</h2><p><strong><code>LoadBalanceClient</code></strong></p>
<p>主要职责：</p>
<ul>
<li>转化URI：将含应用名称URI转化成主机+端口号的形式</li>
<li>选择服务实例：通过负载算法。选择指定服务中的某一台实例</li>
<li>请求执行回调：针对选择后服务实例，执行具体的请求回调操作</li>
</ul>
<p>默认实现：<code>RibbonLoadBalancerClient</code></p>
<p>⾃动装配源： <code>RibbonAutoConfiguration#loadBalancerClient()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancerClient</span> <span class="keyword">extends</span> <span class="title">ServiceInstanceChooser</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用真实主机和端口创建适当的URI以供系统使用</span></span><br><span class="line">	<span class="function">URI <span class="title">reconstructURI</span><span class="params">(ServiceInstance instance, URI original)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="转化URI"><a href="#转化URI" class="headerlink" title="转化URI"></a>转化URI</h3><p>将含应用名称URI转化成ip+port的形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restTemplate.postForObject(<span class="string">"http://"</span> +</span><br><span class="line">                        serviceProviderName + <span class="string">"/greeting"</span>,</span><br><span class="line">                <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"wwww"</span>),</span><br><span class="line">                String.class);</span><br></pre></td></tr></table></figure>
<p>我们需要将<code>RestTemplate#postForObject()</code>第一个参数，转化成具体的URI，例如：<a href="http://localhost:9090/greeting的形式。" target="_blank" rel="noopener">http://localhost:9090/greeting的形式。</a></p>
<blockquote>
<p>为什么这个URI转化过程是通过<code>LoadBalanceClient</code>的实现类来完成的，debug过程中貌似没进<code>LoadBalanceClient</code>里面去。</p>
</blockquote>
<h3 id="选择服务实例"><a href="#选择服务实例" class="headerlink" title="选择服务实例"></a>选择服务实例</h3><blockquote>
<p>如果一个服务由多个实例，（事实上生产环境为了高可用，是不可能但实力运行的），我们怎么去选择其中一个服务实例去调用呢？由什么负载算法吗？就一定按照算法来做吗？有没有特殊情况？</p>
</blockquote>
<h3 id="请求执行回调"><a href="#请求执行回调" class="headerlink" title="请求执行回调"></a>请求执行回调</h3><p>​    选择完服务对应的实例后，就需要去执行请求回调工作。</p>
<h2 id="负载均衡器上下文"><a href="#负载均衡器上下文" class="headerlink" title="负载均衡器上下文"></a>负载均衡器上下文</h2><p><code>LoadBalancerContext</code></p>
<p><strong>默认实现</strong>： <code>RibbonLoadBalancerContext</code></p>
<p><code>RibbonLoadBalancerContext</code>是<code>LoadBalancerContext</code>的子类，它的全部方法都是来自于父类，这样设计我觉得没有什么意义。</p>
<p>主要职责</p>
<ul>
<li><p>转化 URI：将含应⽤名称URI 转化成具体主机+端⼝的形式</p>
</li>
<li><p>组件关联：关联 <code>RetryHandler</code>、 <code>ILoadBalancer</code> 等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerContext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RibbonLoadBalancerContext</span><span class="params">(ILoadBalancer lb, IClientConfig clientConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">		RetryHandler handler)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>(lb, clientConfig, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  这里顺着<code>RibbonLoadBalancerContext</code>的构造器，看到了<code>RetryHandler</code>接口。</p>
<blockquote>
<p>确定负载均衡器是否可以重试异常的处理程序，<em>以及是否应将异常或错误响应视为与电路相关的故障</em>，以便负载均衡器可以避免此类服务器。</p>
</blockquote>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// com.netflix.client.RetryHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetryHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RetryHandler DEFAULT = <span class="keyword">new</span> DefaultLoadBalancerRetryHandler();</span><br><span class="line">    </span><br><span class="line">   	<span class="comment">// 测试负载均衡器的异常是否可重试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRetriableException</span><span class="params">(Throwable e, <span class="keyword">boolean</span> sameServer)</span></span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 测试是否应将异常视为电路故障</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCircuitTrippingException</span><span class="params">(Throwable e)</span></span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 在一台服务器上完成的最大重试次数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxRetriesOnSameServer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 要重试的最大不同服务器数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxRetriesOnNextServer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这让我联想到Kafka中为了高可用，让消息生产者发消息给broker，然后如果消息发送产生异常，生产者需要重试，重新发送信息。也有可能这个异常，我重试也无法恢复，那就直接抛出异常了，因为重试也没用成功发送的可能。</p>
<p>然后我们设置发送成功的标准是一个分区leader和其他follower都接收到了数据，才算发送成功。这样就能维持一个高可用。</p>
</blockquote>
<ul>
<li><p>记录服务统计信息：记录请求相应时间、错误数量等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerContext</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteOpenConnection</span><span class="params">(ServerStats serverStats)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.noteOpenConnection(serverStats);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Timer <span class="title">getExecuteTracer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.getExecuteTracer();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteRequestCompletion</span><span class="params">(ServerStats stats, Object response, Throwable e,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">long</span> responseTime)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.noteRequestCompletion(stats, response, e, responseTime);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteRequestCompletion</span><span class="params">(ServerStats stats, Object response, Throwable e,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">long</span> responseTime, RetryHandler errorHandler)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.noteRequestCompletion(stats, response, e, responseTime, errorHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这些方法主要是对请求时间，异常错误信息等等进行统计。然后信息交给<code>ServerStats</code>来处理，比如下面的代码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.netflix.loadbalancer.ServerStats</span></span><br><span class="line"><span class="meta">@Monitor</span>(name = <span class="string">"OverallResponseTimeMillisAvg"</span>, type = DataSourceType.INFORMATIONAL,</span><br><span class="line">             description = <span class="string">"Average total time for a request, in milliseconds"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResponseTimeAvg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseTimeDist.getMean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>⾃动装配源： <code>RibbonClientConfiguration#ribbonLoadBalancerContext(…)</code> </p>
<h2 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h2><p><code>ILoadBalancer</code> </p>
<p><strong>主要职责</strong></p>
<ul>
<li>增加服务器</li>
<li>获取服务器：通过关联 Key 获取、获取所有服务列表、获取可⽤服务器列表</li>
<li>服务器状态：标记服务器宕机</li>
</ul>
<blockquote>
<p>默认实现： <code>ZoneAwareLoadBalancer</code></p>
</blockquote>
<p> ⾃动装配源： <code>RibbonClientConfiguration#ribbonLoadBalancer(…)</code> </p>
<p>我们看一下<code>ILoadBalancer</code> `接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILoadBalancer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化服务器列表；也可以在后续进行服务器的添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addServers</span><span class="params">(List&lt;Server&gt; newServers)</span></span>;</span><br><span class="line">    <span class="comment">// 从负载均衡器中选择服务器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">chooseServer</span><span class="params">(Object key)</span></span>;</span><br><span class="line">    <span class="comment">// 标记服务器Down</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markServerDown</span><span class="params">(Server server)</span></span>;</span><br><span class="line">    <span class="comment">// 获取启动并且可访问的服务器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getReachableServers</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="comment">// 获取所有的服务器，包含可访问和不可访问的  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getAllServers</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有一个废弃方法，直接忽略。</p>
</blockquote>
<h2 id="三者总结"><a href="#三者总结" class="headerlink" title="三者总结"></a>三者总结</h2><p>负载均衡器客户端主要是执行者，而负载均衡器上下文是贯彻整个执行过程的，负载均衡器主要是维护服务器状态的。</p>
<h2 id="规则接口"><a href="#规则接口" class="headerlink" title="规则接口"></a>规则接口</h2><p><code>IRule</code></p>
<p> <strong>主要职责</strong></p>
<ul>
<li><p>选择服务器：根据负载均衡器以及关联Key 获取候选的服务器</p>
<blockquote>
<p>我们之前说负载均衡器客户端去选择服务实例，就是调用<code>IRule</code>接口来完成的。</p>
</blockquote>
</li>
<li><p>默认实现： <code>ZoneAvoidanceRule</code></p>
</li>
<li><p>⾃动装配源： <code>RibbonClientConfiguration#ribbonRule(…)</code> </p>
</li>
</ul>
<ul>
<li>随机规则：RandomRule</li>
</ul>
<ul>
<li>最可用规则：BestAvailableRule</li>
<li>轮训规则：RoundRobinRule</li>
<li>重试实现：RetryRule</li>
<li>客户端配置：ClientConfigEnabledRoundRobinRule</li>
<li>可用性过滤规则：AvailabilityFilteringRule</li>
<li>RT权重规则：WeightedResponseTimeRule</li>
<li>规避区域规则：ZoneAvoidanceRule</li>
</ul>
<h2 id="Ping策略"><a href="#Ping策略" class="headerlink" title="Ping策略"></a>Ping策略</h2><p><code>IPing</code></p>
<p> 主要职责</p>
<ul>
<li>活动检测：根据指定的服务器，检测其是否活动<blockquote>
<p>默认实现： <code>DummyPing</code></p>
</blockquote>
</li>
</ul>
<p>⾃动装配源： <code>RibbonClientConfiguration#ribbonPing(…)</code> </p>
<h2 id="服务器列表"><a href="#服务器列表" class="headerlink" title="服务器列表"></a>服务器列表</h2><p><code>ServerList</code></p>
<p><strong>主要职责</strong></p>
<ul>
<li><p>获取初始化服务器列表</p>
</li>
<li><p>获取更新服务器列表</p>
</li>
</ul>
<p>默认实现： <code>ConfigurationBasedServerList</code> 或 <code>DiscoveryEnabledNIWSServerList</code> </p>
<p>⾃动装配源： <code>RibbonClientConfiguration</code> </p>
<h1 id="Netflix-Ribbon-⾃动装配"><a href="#Netflix-Ribbon-⾃动装配" class="headerlink" title="Netflix Ribbon ⾃动装配"></a>Netflix Ribbon ⾃动装配</h1><ul>
<li><p><code>RibbonAutoConfiguration</code></p>
<ul>
<li><p><code>LoadBalancerClient</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(LoadBalancerClient.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> LoadBalancerClient <span class="title">loadBalancerClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> RibbonLoadBalancerClient(springClientFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>  &gt; 你可以自己定制一些bean，然后交给IoC容器，然后我这边就不再new了，这是利用了条件装配的特性。
  &gt;
  &gt; 如果我们的application.properties/application.yml文件有了一些配置项，Spring Boot就会利用条件装配的特性，就加载我们的配置项，而不加载默认的配置项。
  &gt;
  &gt; @EnableAutoConfiguration这个注解就是去加载那些自动配置项，这里自然包含条件装配，我们可以覆盖默认配置，通过动态代理形成一个Java Config配置类。
  &gt;
  &gt; 这里解释了什么是约定优于配置的核心原理。
  &gt;
  &gt; 我们的自动配置，就会说，我有这个比如说 server.port配置，你那边别整了；或者我自定义了一个bean，你框架别帮我自动加载了。请忽略框架你自己的代码，用我程序员的自定义bean。

+ `PropertiesFactory`

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertiesFactory <span class="title">propertiesFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> PropertiesFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PropertiesFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PropertiesFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		classToProperty.put(ILoadBalancer.class, <span class="string">"NFLoadBalancerClassName"</span>);</span><br><span class="line">		classToProperty.put(IPing.class, <span class="string">"NFLoadBalancerPingClassName"</span>);</span><br><span class="line">		classToProperty.put(IRule.class, <span class="string">"NFLoadBalancerRuleClassName"</span>);</span><br><span class="line">		classToProperty.put(ServerList.class, <span class="string">"NIWSServerListClassName"</span>);</span><br><span class="line">		classToProperty.put(ServerListFilter.class, <span class="string">"NIWSServerListFilterClassName"</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


  &gt; 这个构造器说明，PropertiesFactory对ILoadBalancer等bean在内存中进行了一份缓存。
</code></pre><ul>
<li><p><code>LoadBalancerAutoConfiguration</code></p>
<ul>
<li><code>@LoadBalanced</code></li>
<li><code>RestTemplate</code> </li>
</ul>
</li>
<li><p><code>RibbonClientConfiguration</code></p>
<ul>
<li>LoadBalancerContext</li>
</ul>
<ul>
<li><p>IRule</p>
</li>
<li><p>IPing</p>
</li>
<li><p>ServerList</p>
<ul>
<li>ILoadBalancer</li>
</ul>
</li>
<li><p>IClientConfig </p>
<p><code>org.springframework.cloud.netflix.ribbon.RibbonClientConfiguration</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IClientConfig <span class="title">ribbonClientConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	DefaultClientConfigImpl config = <span class="keyword">new</span> DefaultClientConfigImpl();</span><br><span class="line">	config.loadProperties(<span class="keyword">this</span>.name);</span><br><span class="line">	config.set(CommonClientConfigKey.ConnectTimeout, DEFAULT_CONNECT_TIMEOUT);</span><br><span class="line">	config.set(CommonClientConfigKey.ReadTimeout, DEFAULT_READ_TIMEOUT);</span><br><span class="line">	<span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IRule.class, config, name);</span><br><span class="line">	&#125;</span><br><span class="line">	ZoneAvoidanceRule rule = <span class="keyword">new</span> ZoneAvoidanceRule();</span><br><span class="line">	rule.initWithNiwsConfig(config);</span><br><span class="line">	<span class="keyword">return</span> rule;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IPing <span class="title">ribbonPing</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IPing.class, name)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IPing.class, config, name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DummyPing();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerList&lt;Server&gt; <span class="title">ribbonServerList</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ServerList.class, name)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ServerList.class, config, name);</span><br><span class="line">	&#125;</span><br><span class="line">	ConfigurationBasedServerList serverList = <span class="keyword">new</span> ConfigurationBasedServerList();</span><br><span class="line">	serverList.initWithNiwsConfig(config);</span><br><span class="line">	<span class="keyword">return</span> serverList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">		ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">		IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ILoadBalancer.class, config, name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">			serverListFilter, serverListUpdater);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RibbonLoadBalancerContext <span class="title">ribbonLoadBalancerContext</span><span class="params">(ILoadBalancer loadBalancer,</span></span></span><br><span class="line"><span class="function"><span class="params">		IClientConfig config, RetryHandler retryHandler)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> RibbonLoadBalancerContext(loadBalancer, config, retryHandler);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RetryHandler <span class="title">retryHandler</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DefaultLoadBalancerRetryHandler(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>条件装配，一目了然</p>
</blockquote>
<h1 id="分析调用链路"><a href="#分析调用链路" class="headerlink" title="分析调用链路"></a>分析调用链路</h1><h2 id="选择服务器逻辑"><a href="#选择服务器逻辑" class="headerlink" title="选择服务器逻辑"></a>选择服务器逻辑</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">""</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">"ajin"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择指定的 serviceId对应的一台服务实例，也就是一个ip+port+"......"</span></span><br><span class="line">    ServiceInstance serviceInstance = loadBalancerClient.choose(serviceProviderAppName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行服务</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loadBalancerClient.execute(serviceProviderAppName, serviceInstance, instance -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务器实例，获取 主机名（IP) 和端口</span></span><br><span class="line">        String host = instance.getHost();</span><br><span class="line">        <span class="keyword">int</span> port = instance.getPort();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拼接请求url</span></span><br><span class="line">        String url = <span class="string">"http://"</span> + host + <span class="string">":"</span> + port + <span class="string">"/user/save"</span>;</span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(url, user, String.class);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ServiceInstance serviceInstance = loadBalancerClient.choose(serviceProviderAppName);</code></p>
<p><code>LoadBalancerClient</code>（LoadBalancerClient） -&gt; <code>ILoadBalancer</code>（ZoneAwareLoadBalancer） -&gt; <code>IRule</code>(ZoneAvoidanceRule)</p>
<blockquote>
<p>整个<code>LoadBalancerClient#choose()</code>选择指定一台服务器的逻辑，就是去从<code>ZoneAwareLoadBalancer</code>里去取服务器。</p>
</blockquote>
<p>我们看一下<code>ZoneAwareLoadBalancer#choose()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (zone != <span class="keyword">null</span>) &#123;</span><br><span class="line"> BaseLoadBalancer zoneLoadBalancer = getLoadBalancer(zone);</span><br><span class="line"> server = zoneLoadBalancer.chooseServer(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再接着<code>zoneLoadBalancer.chooseServer(key)</code>找到负载均衡器，调用<code>chooseServer(key)</code></p>
</blockquote>
<p>go on to <code></code>chooseServer(key)`</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">chooseServer</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (counter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            counter = createCounter();</span><br><span class="line">        &#125;</span><br><span class="line">        counter.increment();</span><br><span class="line">        <span class="keyword">if</span> (rule == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这个不就是Rule吗？？？</span></span><br><span class="line">                <span class="keyword">return</span> rule.choose(key);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.warn(<span class="string">"LoadBalancer [&#123;&#125;]:  Error choosing server for key &#123;&#125;"</span>, name, key, e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一目了然</p>
</blockquote>
<h3 id="自定义IRule"><a href="#自定义IRule" class="headerlink" title="自定义IRule"></a>自定义IRule</h3><p>我们可以自定义IRule来实现自定义的选择服务器的规则。我们自定义的规则，会覆盖掉框架默认的规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义&#123;<span class="doctag">@link</span> com.netflix.loadbalancer.IRule&#125;实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: ajin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/4/29 20:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRule</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ILoadBalancer loadBalancer = getLoadBalancer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有可达服务器</span></span><br><span class="line">        List&lt;Server&gt; reachableServers = loadBalancer.getReachableServers();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(reachableServers==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 随机访问一台服务器</span></span><br><span class="line">        <span class="keyword">int</span> serverNum = reachableServers.size();</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> randomServerNum = random.nextInt(serverNum);</span><br><span class="line">        <span class="keyword">return</span> reachableServers.get(randomServerNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要将其暴露成bean交给IoC</p>
<blockquote>
<p>参考之前的自动装配</p>
</blockquote>
<p><code>org.springframework.cloud.netflix.ribbon.RibbonClientConfiguration</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IRule.class, config, name);</span><br><span class="line">	&#125;</span><br><span class="line">	ZoneAvoidanceRule rule = <span class="keyword">new</span> ZoneAvoidanceRule();</span><br><span class="line">	rule.initWithNiwsConfig(config);</span><br><span class="line">	<span class="keyword">return</span> rule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们将自定义的或则MyRule暴露给Bean</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将 &#123;<span class="doctag">@link</span> MyRule&#125;暴露给&#123;<span class="doctag">@link</span> Bean&#125;</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRule <span class="title">iRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyRule();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过debug启动项目发现的确是我们的<code>MyRule</code>在起作用</p>
</blockquote>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture334.png" alt=""></p>
<h1 id="Netflix-Ribbon-配置化组件"><a href="#Netflix-Ribbon-配置化组件" class="headerlink" title="Netflix Ribbon 配置化组件"></a>Netflix Ribbon 配置化组件</h1><blockquote>
<p>通过学习<code>PropertiesFactory</code> 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; 	<span class="function"><span class="keyword">public</span> <span class="title">PropertiesFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; 		classToProperty.put(ILoadBalancer.class, <span class="string">"NFLoadBalancerClassName"</span>);</span><br><span class="line">&gt; 		classToProperty.put(IPing.class, <span class="string">"NFLoadBalancerPingClassName"</span>);</span><br><span class="line">&gt; 		classToProperty.put(IRule.class, <span class="string">"NFLoadBalancerRuleClassName"</span>);</span><br><span class="line">&gt; 		classToProperty.put(ServerList.class, <span class="string">"NIWSServerListClassName"</span>);</span><br><span class="line">&gt; 		classToProperty.put(ServerListFilter.class, <span class="string">"NIWSServerListFilterClassName"</span>);</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>可知<code>NFLoadBalancerClassName</code> 等是可以配置的</p>
</blockquote>
<h2 id="实现-IPing-MyPing"><a href="#实现-IPing-MyPing" class="headerlink" title="实现 IPing : MyPing"></a>实现 <code>IPing</code> : <code>MyPing</code></h2><p>我们浏览器地址栏输入：<a href="http://localhost:9090/health（服务提供方的health端口）返回：" target="_blank" rel="noopener">http://localhost:9090/health（服务提供方的health端口）返回：</a></p>
<blockquote>
<p>{</p>
<p><strong>status</strong>: “UP”</p>
<p>}</p>
</blockquote>
<p>所以说我们<code>MyPing</code>去ping一下这个地址，看状态码。这样就实现了对服务端的health check.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.segumentfault.spring.cloud.lesson7.user.ribbon.client.ping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.IPing;</span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.Server;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.util.UriComponentsBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 &#123;<span class="doctag">@link</span> IPing&#125; 接口：检查对象 /health 是否正常状态码:200</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPing</span> <span class="keyword">implements</span> <span class="title">IPing</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String host = server.getHost();</span><br><span class="line">        <span class="keyword">int</span> port = server.getPort();</span><br><span class="line">        <span class="comment">// /health endpoint</span></span><br><span class="line">        <span class="comment">// 通过 Spring 组件来实现URL 拼装</span></span><br><span class="line">        UriComponentsBuilder builder = UriComponentsBuilder.newInstance();</span><br><span class="line">        builder.scheme(<span class="string">"http"</span>);</span><br><span class="line">        builder.host(host);</span><br><span class="line">        builder.port(port);</span><br><span class="line">        builder.path(<span class="string">"/health"</span>);</span><br><span class="line">        URI uri = builder.build().toUri();</span><br><span class="line"></span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"></span><br><span class="line">        ResponseEntity responseEntity = restTemplate.getForEntity(uri, String.class);</span><br><span class="line">        <span class="comment">// 当响应状态等于 200 时，返回 true ，否则 false</span></span><br><span class="line">        <span class="keyword">return</span> HttpStatus.OK.equals(responseEntity.getStatusCode());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="增加配置"><a href="#增加配置" class="headerlink" title="增加配置"></a>增加配置</h2><p><code>application.properties</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 扩展 IPing 实现</span><br><span class="line">user-service-provider.ribbon.NFLoadBalancerPingClassName = \</span><br><span class="line">  com.segumentfault.spring.cloud.lesson7.user.ribbon.client.ping.MyPing</span><br></pre></td></tr></table></figure>
<h1 id="条件装配的总结"><a href="#条件装配的总结" class="headerlink" title="条件装配的总结"></a>条件装配的总结</h1><p><code>@ConditionalOnBean</code>（仅仅在当前上下文中存在某个对象时，才会实例化一个Bean）<br><code>@ConditionalOnClass</code>（某个class位于类路径上，才会实例化一个Bean）<br><code>@ConditionalOnExpression</code>（当表达式为true的时候，才会实例化一个Bean）<br><code>@ConditionalOnMissingBean</code>（仅仅在当前上下文中不存在某个对象时，才会实例化一个Bean）</p>
<blockquote>
<p>只有在<code>BeanFactory</code>中未包含指定的bean类和/或名称时才匹配。</p>
</blockquote>
<p><code>@ConditionalOnMissingClass</code>（某个class类路径上不存在的时候，才会实例化一个Bean）<br><code>@ConditionalOnNotWebApplication</code>（不是web应用）</p>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>@LoadBalanced</code>给Ribbon带来了什么?</strong></p>
<p>最核心的是<code>@LoadBalanced</code>调了最下面那个方法</p>
<p><code>// private LoadBalancerClient loadBalancer;</code></p>
<p><code>this.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution));</code></p>
<p>其实就是我们刚开始写的一个代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	User user = <span class="keyword">new</span> User();</span><br><span class="line">     user.setId(<span class="number">1L</span>);</span><br><span class="line">     user.setName(<span class="string">"ajin"</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 选择指定的 serviceId对应的一台服务实例，也就是一个ip+port+"......"</span></span><br><span class="line">     ServiceInstance serviceInstance = loadBalancerClient.choose(serviceProviderAppName);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 执行服务</span></span><br><span class="line"><span class="comment">// @LoadBalanced</span></span><br><span class="line">     <span class="keyword">return</span> loadBalancerClient.execute(serviceProviderAppName, serviceInstance, instance -&gt; &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 服务器实例，获取 主机名（IP) 和端口</span></span><br><span class="line">         String host = instance.getHost();</span><br><span class="line">         <span class="keyword">int</span> port = instance.getPort();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 拼接请求url</span></span><br><span class="line">         String url = <span class="string">"http://"</span> + host + <span class="string">":"</span> + port + <span class="string">"/user/save"</span>;</span><br><span class="line">         RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> restTemplate.postForObject(url, user, String.class);</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/26/Hystrix学习与总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/26/Hystrix学习与总结/" itemprop="url">Hystrix学习与总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-26T14:12:36+08:00">
                2019-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>服务短路的概念是从家用电器中的短路演变而来。</p>
<blockquote>
<p>系统整体性保护</p>
</blockquote>
<p>相近的词：</p>
<p>服务容错：强调容忍错误，不至于整体故障</p>
<p>服务降级：强调服务非依赖项，不影响主要流程</p>
<blockquote>
<p>使用Spring Cloud的时候，一定要将Spring Cloud版本和Spring Boot的版本相对应。</p>
</blockquote>
<blockquote>
<p>学习Hystrix的过程中定义了一个多module的maven Project（Spring Cloud)，只要在项目中定义好Spring Boot和Spring Cloud的版本以及它的子module，然后各个module定义自己的Spring Cloud具体依赖关系 ，如ribbon等。</p>
<p>项目的pom.xml只定义公共部分，如Spring Boot和Spring Cloud的版本，和项目包含的module。</p>
</blockquote>
<h2 id="Hystrix-的设计原则"><a href="#Hystrix-的设计原则" class="headerlink" title="Hystrix 的设计原则"></a>Hystrix 的设计原则</h2><ul>
<li>对依赖服务调用时出现的调用延迟和调用失败进行<strong>控制和容错保护</strong>。</li>
<li>在复杂的分布式系统中，阻止某一个依赖服务的故障在整个系统中蔓延。比如某一个服务故障了，导致其它服务也跟着故障。</li>
<li>提供 <code>fail-fast</code>（快速失败）和快速恢复的支持。</li>
<li>提供 fallback 优雅降级的支持。</li>
<li>支持近实时的监控、报警以及运维操作。</li>
</ul>
<h2 id="Hystrix-更加细节的设计原则"><a href="#Hystrix-更加细节的设计原则" class="headerlink" title="Hystrix 更加细节的设计原则"></a>Hystrix 更加细节的设计原则</h2><ul>
<li>阻止任何一个依赖服务耗尽所有的资源，比如 tomcat 中的所有线程资源。</li>
<li>避免请求排队和积压，采用限流和 <code>fail fast</code> 来控制故障。</li>
<li>提供 fallback 降级机制来应对故障。</li>
<li>使用资源隔离技术，比如 <code>bulkhead</code>（舱壁隔离技术）、<code>swimlane</code>（泳道技术）、<code>circuit breaker</code>（断路技术）来限制任何一个依赖服务的故障的影响。</li>
<li>通过近实时的统计/监控/报警功能，来提高故障发现的速度。</li>
<li>通过近实时的属性和配置<strong>热修改</strong>功能，来提高故障处理和恢复的速度。</li>
<li>保护依赖服务调用的所有故障情况，而不仅仅只是网络故障情况。</li>
</ul>
<h1 id="Spring-Cloud-Hystrix-源码解读"><a href="#Spring-Cloud-Hystrix-源码解读" class="headerlink" title="Spring Cloud Hystrix 源码解读"></a>Spring Cloud Hystrix 源码解读</h1><h2 id="EnableCircuitBreaker"><a href="#EnableCircuitBreaker" class="headerlink" title="@EnableCircuitBreaker"></a><code>@EnableCircuitBreaker</code></h2><p>主要职责：</p>
<ul>
<li><p>激活服务短路能力</p>
</li>
<li><p>自动装配：<code>HystrixCircuitBreakerConfiguration</code> </p>
<blockquote>
<p>这个自动装配类是通过<code>SpringFactoriesLoader</code>在jar包下META-INF/spring.factories中找到的</p>
<p>E:\mavenRepository\org\springframework\cloud\spring-cloud-netflix-core\1.4.6.RELEASE\spring-cloud-netflix-core-1.4.6.RELEASE-sources.jar!\META-INF\spring.factories</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker=\</span><br><span class="line">org.springframework.cloud.netflix.hystrix.HystrixCircuitBreakerConfiguration</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>导⼊选择器： <code>EnableCircuitBreakerImportSelector</code></p>
<p>设计缺陷：覆盖默认实现 Hystrix 操作繁琐 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import</span>(EnableCircuitBreakerImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCircuitBreaker &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看一下<code>EnableCircuitBreakerImportSelector.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order</span>(Ordered.LOWEST_PRECEDENCE - <span class="number">100</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableCircuitBreakerImportSelector</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">		<span class="title">SpringFactoryImportSelector</span>&lt;<span class="title">EnableCircuitBreaker</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RelaxedPropertyResolver(getEnvironment()).getProperty(</span><br><span class="line">				<span class="string">"spring.cloud.circuit.breaker.enabled"</span>, Boolean.class, Boolean.TRUE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><ul>
<li><code>@EnableCircuitBreaker</code><ul>
<li><code>EnableCircuitBreakerImportSelector</code><ul>
<li><code>HystrixCircuitBreakerConfiguration</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="HystrixCircuitBreakerConfiguration"><a href="#HystrixCircuitBreakerConfiguration" class="headerlink" title="HystrixCircuitBreakerConfiguration"></a><code>HystrixCircuitBreakerConfiguration</code></h2><p>​    <strong>初始化组件</strong></p>
<ul>
<li><code>HystrixCommandAspect</code></li>
<li><code>HystrixShutdownHook</code></li>
<li><code>HystrixStreamEndpoint</code> ： Servlet </li>
<li><code>HystrixMetricsPollerConfiguration</code></li>
</ul>
<ul>
<li><p>Hystrix 命令切⾯： <code>HystrixCommandAspect</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HystrixCommandAspect <span class="title">hystrixCommandAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> HystrixCommandAspect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Hystrix Endpoint： <code>HystrixStreamEndpoint</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"hystrix.stream.endpoint.enabled"</span>, matchIfMissing = <span class="keyword">true</span>) <span class="comment">// 如果没配置hystrix.stream.endpoint.enabled，则默认值为true</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Endpoint.class, HystrixMetricsStreamServlet.class &#125;)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixWebConfiguration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HystrixStreamEndpoint <span class="title">hystrixStreamEndpoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> HystrixStreamEndpoint();</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Hystrix 指标： <code>HystrixMetricsPollerConfiguration</code> </p>
</li>
</ul>
<h1 id="Netflix-Hystrix-源码解读"><a href="#Netflix-Hystrix-源码解读" class="headerlink" title="Netflix Hystrix 源码解读"></a>Netflix Hystrix 源码解读</h1><h2 id="HystrixCommandAspect"><a href="#HystrixCommandAspect" class="headerlink" title="HystrixCommandAspect"></a>HystrixCommandAspect</h2><h3 id="依赖组件"><a href="#依赖组件" class="headerlink" title="依赖组件"></a>依赖组件</h3><ul>
<li><code>MetaHolderFactory</code></li>
<li><code>HystrixCommandFactory</code>: 生成<code>HystrixInvokable</code></li>
<li><code>HystrixInvokable</code></li>
<li><code>CommandCollapser</code></li>
<li><code>GenericObservableCommand</code></li>
<li><code>GenericCommand</code></li>
</ul>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul>
<li><p>拦截标注 <code>@HystrixCommand</code> 或 <code>@HystrixCollapser</code> 的⽅法（<code>@Around</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  	  <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand)"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hystrixCommandAnnotationPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.netflix.hystrix.contrib.javanica.annotation.HystrixCollapser)"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hystrixCollapserAnnotationPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Around</span>(<span class="string">"hystrixCommandAnnotationPointcut() || hystrixCollapserAnnotationPointcut()"</span>)</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">methodsAnnotatedWithHystrixCommand</span><span class="params">(<span class="keyword">final</span> ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          Method method = getMethodFromTarget(joinPoint);</span><br><span class="line">          </span><br><span class="line">      <span class="comment">// 省略其他部分源码</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>⽣成拦截⽅法原信息（<code>MetaHolderFactory</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MetaHolderFactory metaHolderFactory =META_HOLDER_FACTORY_MAP.get(HystrixPointcutType.of(method));</span><br><span class="line"></span><br><span class="line">MetaHolder metaHolder = metaHolderFactory.create(joinPoint); <span class="comment">// 模板方法，交给子类实现</span></span><br></pre></td></tr></table></figure>
<p><code>MetaHolderFactory</code>有两个具体的子类，分别对应<code>@HystrixCommand</code>和<code>@HystrixCollapser</code></p>
<blockquote>
<p>我们看下前者对应的<code>CommandMetaHolderFactory</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandMetaHolderFactory</span> <span class="keyword">extends</span> <span class="title">MetaHolderFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现父类的模板方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MetaHolder <span class="title">create</span><span class="params">(Object proxy, Method method, Object obj, Object[] args, <span class="keyword">final</span> ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取HystrixCommand注解</span></span><br><span class="line">        HystrixCommand hystrixCommand = method.getAnnotation(HystrixCommand.class);</span><br><span class="line">        ExecutionType executionType = ExecutionType.getExecutionType(method.getReturnType());</span><br><span class="line">        MetaHolder.Builder builder = metaHolderBuilder(proxy, method, obj, args, joinPoint);</span><br><span class="line">        <span class="keyword">if</span> (isCompileWeaving()) &#123;</span><br><span class="line">            builder.ajcMethod(getAjcMethodFromTarget(joinPoint));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.defaultCommandKey(method.getName())</span><br><span class="line">                        .hystrixCommand(hystrixCommand)</span><br><span class="line">                        .observableExecutionMode(hystrixCommand.observableExecutionMode())</span><br><span class="line">                        .executionType(executionType)</span><br><span class="line">                        .observable(ExecutionType.OBSERVABLE == executionType)</span><br><span class="line">                        .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>⽣成 <code>HystrixInvokable</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HystrixInvokable invokable = HystrixCommandFactory.getInstance().create(metaHolder);</span><br></pre></td></tr></table></figure>
<p><code>HystrixCommandFactory.getInstance()</code>就是一个单例模式，创建一个<code>HystrixCommandFactory</code>对象，</p>
<blockquote>
<p>我们还原一下create()的详细源码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HystrixInvokable <span class="title">create</span><span class="params">(MetaHolder metaHolder)</span> </span>&#123;</span><br><span class="line">      HystrixInvokable executable;</span><br><span class="line">      <span class="keyword">if</span> (metaHolder.isCollapserAnnotationPresent()) &#123; <span class="comment">// @HystrixCollapser</span></span><br><span class="line">          executable = <span class="keyword">new</span> CommandCollapser(metaHolder);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (metaHolder.isObservable()) &#123; <span class="comment">// Reactive模式</span></span><br><span class="line">          executable = <span class="keyword">new</span> 		   GenericObservableCommand(HystrixCommandBuilderFactory.getInstance().create(metaHolder));</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// @HystrixCommand应该是这种类型</span></span><br><span class="line">         executable = <span class="keyword">new</span> GenericCommand(HystrixCommandBuilderFactory.getInstance().create(metaHolder)); </span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> executable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>metaHolder.isObservable()</code></li>
</ul>
</li>
</ul>
<ul>
<li><code>GenericCommand</code>继承自抽象类<code>HystrixCommand</code></li>
</ul>
<ul>
<li><p>选择执⾏模式（<code>Observable</code> 或⾮ <code>Observable</code>） </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object result;</span><br><span class="line"><span class="keyword">if</span> (!metaHolder.isObservable()) &#123; <span class="comment">// 如果是非观察者模式</span></span><br><span class="line">     result = CommandExecutor.execute(invokable, executionType, metaHolder);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   result = executeObservable(invokable, executionType, metaHolder);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HystrixStreamEndpoint"><a href="#HystrixStreamEndpoint" class="headerlink" title="HystrixStreamEndpoint"></a>HystrixStreamEndpoint</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixStreamEndpoint</span> <span class="keyword">extends</span> <span class="title">ServletWrappingEndpoint</span> </span>&#123;</span><br><span class="line">	<span class="comment">// http://localhost:8080/hystrix.stream</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HystrixStreamEndpoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Servelt类型，servlet名称，servlet的路径</span></span><br><span class="line">		<span class="keyword">super</span>(HystrixMetricsStreamServlet.class, <span class="string">"hystrixStream"</span>, <span class="string">"/hystrix.stream"</span>,</span><br><span class="line">				<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相当于将其变成一个Servlet供外界访问，不可修改。</p>
</blockquote>
<h2 id="Future实现服务熔断"><a href="#Future实现服务熔断" class="headerlink" title="Future实现服务熔断"></a>Future实现服务熔断</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.segmentfault.springcloudlesson9.future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过&#123;<span class="doctag">@link</span> java.util.concurrent.Future&#125;来实现服务熔断</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ajin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureCircuitBreakerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化线程池 创建一个Executor，它使用单个工作线程操作</span></span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        RandomCommand command = <span class="keyword">new</span> RandomCommand();</span><br><span class="line"></span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> command.run(); <span class="comment">// 获取run()计算结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 100毫秒超时时间</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            result=future.get(<span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// fallback方法</span></span><br><span class="line">            result = command.fallback();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机事件执行命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomCommand</span> <span class="keyword">implements</span> <span class="title">Command</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> executeTime = random.nextInt(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过休眠来模拟执行时间</span></span><br><span class="line">            System.out.println(<span class="string">"Execute Time :"</span> + executeTime);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(executeTime);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">fallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Fall back"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 正常执行并且返回结果</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">T <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 错误时返回的容错结果</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">T <span class="title">fallback</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/25/MySQL主从同步深入总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/25/MySQL主从同步深入总结/" itemprop="url">MySQL主从同步深入总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-25T21:32:59+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何实现-MySQL-的读写分离？"><a href="#如何实现-MySQL-的读写分离？" class="headerlink" title="如何实现 MySQL 的读写分离？"></a>如何实现 MySQL 的读写分离？</h1><p>其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。</p>
<h1 id="MySQL-主从复制原理的是啥？"><a href="#MySQL-主从复制原理的是啥？" class="headerlink" title="MySQL 主从复制原理的是啥？"></a>MySQL 主从复制原理的是啥？</h1><p>主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/mysql-master-slave.png" alt=""></p>
<p>这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是<strong>有延时</strong>的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。</p>
<p>而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。</p>
<p>所以 MySQL 实际上在这一块有两个机制，一个是<strong>半同步复制</strong>，用来解决主库数据丢失问题；一个是<strong>并行复制</strong>，用来解决主从同步延时问题。</p>
<p>这个所谓<strong>半同步复制</strong>，也叫 <code>semi-sync</code> 复制，指的就是主库写入 binlog 日志之后，就会将<strong>强制</strong>此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到<strong>至少一个从库</strong>的 ack 之后才会认为写操作完成了。</p>
<p>所谓<strong>并行复制</strong>，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后<strong>并行重放不同库的日志</strong>，这是库级别的并行。</p>
<h1 id="MySQL-主从同步延时问题（精华）"><a href="#MySQL-主从同步延时问题（精华）" class="headerlink" title="MySQL 主从同步延时问题（精华）"></a>MySQL 主从同步延时问题（精华）</h1><p>有个同学是这样写代码逻辑的。先插入一条数据，再把它查出来，然后更新这条数据。在生产环境高峰期，写并发达到了 2000/s，这个时候，主从复制延时大概是在小几十毫秒。线上会发现，每天总有那么一些数据，我们期望更新一些重要的数据状态，但在高峰期时候却没更新。用户跟客服反馈，而客服就会反馈给我们。</p>
<p>我们通过 MySQL 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status</span><br></pre></td></tr></table></figure>
<p>查看 <code>Seconds_Behind_Master</code>，可以看到从库复制主库的数据落后了几 ms。</p>
<p>一般来说，如果主从延迟较为严重，有以下解决方案：</p>
<ul>
<li>分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。</li>
<li>打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。</li>
<li>重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。</li>
<li>如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询<strong>设置直连主库</strong>。<strong>不推荐</strong>这种方法，你要是这么搞，读写分离的意义就丧失了。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/25/消息队列相关总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/25/消息队列相关总结/" itemprop="url">消息队列相关总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-25T20:47:03+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="为什么使用消息队列"><a href="#为什么使用消息队列" class="headerlink" title="为什么使用消息队列"></a>为什么使用消息队列</h1><p>​    </p>
<h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p>看这么个场景。A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃……</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/mq-1.png" alt=""></p>
<p>在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？头发都白了啊！</p>
<p>如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/mq-2.png" alt=""></p>
<p><strong>总结</strong>：通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。</p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/mq-3.png" alt=""></p>
<p>一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。</p>
<p>如果<strong>使用 MQ</strong>，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了，爽！网站做得真好，真快！</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/mq-4.png" alt=""></p>
<h2 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h2><p>每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。</p>
<p>一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。</p>
<p>但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/mq-5.png" alt=""></p>
<p>如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/mq-6.png" alt=""></p>
<p>这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。</p>
<h1 id="消息队列有什么优缺点"><a href="#消息队列有什么优缺点" class="headerlink" title="消息队列有什么优缺点"></a>消息队列有什么优缺点</h1><p>优点上面已经说了，就是<strong>在特殊场景下有其对应的好处</strong>，<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</p>
<p>缺点有以下几个：</p>
<ul>
<li>系统可用性降低<br>系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的，你不就完了？</li>
<li>系统复杂度提高<br>硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。</li>
<li>一致性问题<br>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。</li>
</ul>
<p>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。</p>
<h1 id="如何保证消息队列的高可用"><a href="#如何保证消息队列的高可用" class="headerlink" title="如何保证消息队列的高可用"></a>如何保证消息队列的高可用</h1><p>Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。</p>
<p>这就是<strong>天然的分布式消息队列</strong>，就是说一个 topic 的数据，是<strong>分散放在多个机器上的，每个机器就放一部分数据</strong>。</p>
<p>实际上 RabbmitMQ 之类的，并不是分布式消息队列，它就是传统的消息队列，只不过提供了一些集群、HA(High Availability, 高可用性) 的机制而已，因为无论怎么玩儿，RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</p>
<p>Kafka 0.8 以前，是没有 HA 机制的，就是任何一个 broker 宕机了，那个 broker 上的 partition 就废了，没法写也没法读，没有什么高可用性可言。</p>
<p>比如说，我们假设创建了一个 topic，指定其 partition 数量是 3 个，分别在三台机器上。但是，如果第二台机器宕机了，会导致这个 topic 的 1/3 的数据就丢了，因此这个是做不到高可用的。</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/kafka-before.png" alt=""></p>
<p>Kafka 0.8 以后，提供了 HA 机制，就是 replica（复制品） 副本机制。每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。只能读写 leader？很简单，<strong>要是你可以随意读写每个 follower，那么就要 care 数据一致性的问题</strong>，系统复杂度太高，很容易出问题。Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/kafka-after.png" alt=""></p>
<p>这么搞，就有所谓的<strong>高可用性</strong>了，因为如果某个 broker 宕机了，没事儿，那个 broker上面的 partition 在其他机器上都有副本的，如果这上面有某个 partition 的 leader，那么此时会从 follower 中<strong>重新选举</strong>一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。</p>
<p><strong>写数据</strong>的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</p>
<p><strong>消费</strong>的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</p>
<h1 id="如何保证消息不被重复消费"><a href="#如何保证消息不被重复消费" class="headerlink" title="如何保证消息不被重复消费"></a>如何保证消息不被重复消费</h1><p>如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？</p>
<blockquote>
<p>使用消息队列如何保证幂等性？</p>
</blockquote>
<p>​    </p>
<p>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，<strong>每隔一段时间</strong>（定时定期），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。</p>
<p>但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是没来得及提交 offset，尴尬了。重启之后，少数消息会再次消费一次。</p>
<p>举个栗子。</p>
<p>有这么个场景。数据 1/2/3 依次进入 kafka，kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，我们就假设分配的 offset 依次是 152/153/154。消费者从 kafka 去消费的时候，也是按照这个顺序去消费。假如当消费者消费了 <code>offset=153</code> 的这条数据，刚准备去提交 offset 到 zookeeper，此时消费者进程被重启了。那么此时消费过的数据 1/2 的 offset 并没有提交，kafka 也就不知道你已经消费了 <code>offset=153</code> 这条数据。那么重启之后，消费者会找 kafka 说，嘿，哥儿们，你给我接着把上次我消费到的那个地方后面的数据继续给我传递过来。由于之前的 offset 没有提交成功，那么数据 1/2 会再次传过来，如果此时消费者没有去重的话，那么就会导致重复消费。</p>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/mq-10.png" alt=""></p>
<p>如果消费者干的事儿是拿一条数据就往数据库里写一条，会导致说，你可能就把数据 1/2 在数据库里插入了 2 次，那么数据就错啦。</p>
<p>其实重复消费不可怕，可怕的是你没考虑到重复消费之后，<strong>怎么保证幂等性</strong>。</p>
<p>举个例子吧。假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。</p>
<p>一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。</p>
<blockquote>
<p>幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，<strong>不能出错</strong>。</p>
</blockquote>
<p>所以第二个问题来了，怎么保证消息队列消费的幂等性？</p>
<p>其实还是得结合业务来思考，我这里给几个思路：</p>
<ul>
<li>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。</li>
<li>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。</li>
<li>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li>
<li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</li>
</ul>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/mq-11.png" alt=""></p>
<p>当然，如何保证 MQ 的消费是幂等性的，需要结合具体的业务来看。</p>
<h1 id="如何保证消息的可靠性传输"><a href="#如何保证消息的可靠性传输" class="headerlink" title="如何保证消息的可靠性传输"></a>如何保证消息的可靠性传输</h1><blockquote>
<p>或者说，如何处理消息丢失的问题？</p>
</blockquote>
<p>如果说你这个是用 MQ 来传递非常核心的消息，比如说计费、扣费的一些消息，那必须确保这个 MQ 传递过程中<strong>绝对不会把计费消息给弄丢</strong>。</p>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="消费端弄丢了数据"><a href="#消费端弄丢了数据" class="headerlink" title="消费端弄丢了数据"></a>消费端弄丢了数据</h3><p>唯一可能导致消费者弄丢数据的情况，就是说，你消费到了这个消息，然后消费者那边<strong>自动提交了 offset</strong>，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。</p>
<p>这不是跟 RabbitMQ 差不多吗，大家都知道 Kafka 会自动提交 offset，那么只要<strong>关闭自动提交</strong> offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是<strong>可能会有重复消费</strong>，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。</p>
<p>生产环境碰到的一个问题，就是说我们的 Kafka 消费者消费到了数据之后是写到一个内存的 queue 里先缓冲一下，结果有的时候，你刚把消息写入内存 queue，然后消费者会自动提交 offset。然后此时我们重启了系统，就会导致内存 queue 里还没来得及处理的数据就丢失了。</p>
<h3 id="Kafka-弄丢了数据"><a href="#Kafka-弄丢了数据" class="headerlink" title="Kafka 弄丢了数据"></a>Kafka 弄丢了数据</h3><p>这块比较常见的一个场景，就是 Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。大家想想，要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。</p>
<p>生产环境也遇到过，我们也是，之前 Kafka 的 leader 机器宕机了，将 follower 切换为 leader 之后，就会发现说这个数据就丢了。</p>
<p>所以此时一般是要求起码设置如下 4 个参数：</p>
<ul>
<li>给 topic 设置 <code>replication.factor</code> 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</li>
<li>在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。</li>
<li>在 producer 端设置 <code>acks=all</code>：这个是要求每条数据，必须是<strong>写入所有 replica 之后，才能认为是写成功了</strong>。</li>
<li>在 producer 端设置 <code>retries=MAX</code>（很大很大很大的一个值，无限次重试的意思）：这个是<strong>要求一旦写入失败，就无限重试</strong>，卡在这里了。</li>
</ul>
<p>我们生产环境就是按照上述要求配置的，这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。</p>
<h3 id="生产者会不会弄丢数据？"><a href="#生产者会不会弄丢数据？" class="headerlink" title="生产者会不会弄丢数据？"></a>生产者会不会弄丢数据？</h3><p>如果按照上述的思路设置了 <code>acks=all</code>，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</p>
<h1 id="如何保证消息的顺序性"><a href="#如何保证消息的顺序性" class="headerlink" title="如何保证消息的顺序性"></a>如何保证消息的顺序性</h1><p>我举个例子，我们以前做过一个 mysql <code>binlog</code> 同步的系统，压力还是非常大的，日同步数据要达到上亿，就是说数据从一个 mysql 库原封不动地同步到另一个 mysql 库里面去（mysql -&gt; mysql）。常见的一点在于说比如大数据 team，就需要同步一个 mysql 库过来，对公司的业务系统的数据做各种复杂的操作。</p>
<p>你在 mysql 里增删改一条数据，对应出来了增删改 3 条 <code>binlog</code> 日志，接着这三条 <code>binlog</code> 发送到 MQ 里面，再消费出来依次执行，起码得保证人家是按照顺序来的吧？不然本来是：增加、修改、删除；你楞是换了顺序给执行成删除、修改、增加，不全错了么。</p>
<p>本来这个数据同步过来，应该最后这个数据被删除了；结果你搞错了这个顺序，最后这个数据保留下来了，数据同步就出错了。</p>
<ul>
<li><strong>Kafka</strong>：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。<br>消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞<strong>多个线程来并发处理消息</strong>。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。</li>
</ul>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/kafka-order-01.png" alt=""></p>
<p><strong>解决方案</strong></p>
<ul>
<li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li>
<li>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li>
</ul>
<p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/kafka-order-02.png" alt=""></p>
<h1 id="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"><a href="#如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？" class="headerlink" title="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"></a>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</h1><h2 id="大量消息在-mq-里积压了几个小时了还没解决"><a href="#大量消息在-mq-里积压了几个小时了还没解决" class="headerlink" title="大量消息在 mq 里积压了几个小时了还没解决"></a>大量消息在 mq 里积压了几个小时了还没解决</h2><p>几千万条数据在 MQ 里积压了七八个小时，从下午 4 点多，积压到了晚上 11 点多。这个是我们真实遇到过的一个场景，确实是线上故障了，这个时候要不然就是修复 consumer 的问题，让它恢复消费速度，然后傻傻的等待几个小时消费完毕。这个肯定不能在面试的时候说吧。</p>
<p>一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟就是 18 万条。所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复过来。</p>
<p>一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：</p>
<ul>
<li>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。</li>
<li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。</li>
<li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，<strong>消费之后不做耗时的处理</strong>，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</li>
<li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li>
<li>等快速消费完积压数据之后，<strong>得恢复原先部署的架构</strong>，<strong>重新</strong>用原先的 consumer 机器来消费消息。</li>
</ul>
<h2 id="mq-中的消息过期失效了"><a href="#mq-中的消息过期失效了" class="headerlink" title="mq 中的消息过期失效了"></a>mq 中的消息过期失效了</h2><p>假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是<strong>大量的数据会直接搞丢</strong>。</p>
<p>这个情况下，就不是说要增加 consumer 消费积压的消息，因为实际上没啥积压，而是丢了大量的消息。我们可以采取一个方案，就是<strong>批量重导</strong>，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。</p>
<p>假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</p>
<h2 id="mq-都快写满了"><a href="#mq-都快写满了" class="headerlink" title="mq 都快写满了"></a>mq 都快写满了</h2><p>如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，<strong>消费一个丢弃一个，都不要了</strong>，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。</p>
<h1 id="如果让你写一个消息队列，该如何进行架构设计？"><a href="#如果让你写一个消息队列，该如何进行架构设计？" class="headerlink" title="如果让你写一个消息队列，该如何进行架构设计？"></a>如果让你写一个消息队列，该如何进行架构设计？</h1><p>比如说这个消息队列系统，我们从以下几个角度来考虑一下：</p>
<ul>
<li>首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？</li>
<li>其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。</li>
<li>其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务。</li>
<li>能不能支持数据 0 丢失啊？可以的，参考 kafka 数据零丢失方案。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liutianruo.com/2019/04/25/2.生产者/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘天霸">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间旅行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/25/2.生产者/" itemprop="url">2.生产者</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-25T17:19:41+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>模拟消费者  <code>bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic topic-demo</code></p>
<p>模拟生产者  <code>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic topic-demo</code></p>
<blockquote>
<p>生产者生产了之后，消费者就能接收到消息</p>
</blockquote>
<h1 id="生产者客户端"><a href="#生产者客户端" class="headerlink" title="生产者客户端"></a>生产者客户端</h1><p>生产者就是负责向Kafka发送消息的应用程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerFastStart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String brokerList = <span class="string">"localhost:9092"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String topic = <span class="string">"topic-demo"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">initConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        props.put(<span class="string">"key.serializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        props.put(<span class="string">"value.serializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, brokerList);</span><br><span class="line">		props.put(<span class="string">"client.id"</span>, <span class="string">"producer.client.id.demo"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Properties props = initConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置生产者客户端参数并创建KafkaProducer实例</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;String, String&gt;(props);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建需要发送的消息</span></span><br><span class="line">        ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(topic, <span class="string">"Hello,Kafka!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            producer.send(record);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭生产者客户端</span></span><br><span class="line">        producer.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息对象-ProducerRecord"><a href="#消息对象-ProducerRecord" class="headerlink" title="消息对象(ProducerRecord)"></a>消息对象(ProducerRecord)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerRecord</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic; <span class="comment">//主题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer partition; <span class="comment">//分区</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Headers headers; <span class="comment">//消息头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key; <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V value; <span class="comment">//值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long timestamp; <span class="comment">//消息的时间戳</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>key</code> 是用来指定消息的键，它不仅是消息的附加信息，还可以用来计算分区号进而可以让消息发往特定的分区。 </p>
<p>消息以主题为单位进行归类，而这个 key 可以让消息再进行二次归类，同一个 key 的消息会被划分到同一个分区中 。</p>
</li>
<li><p><code>value</code> 消息体，一般不为空</p>
</li>
<li><p><code>timestamp</code> 消息的时间戳</p>
<ul>
<li><code>CreateTime</code>  消息创建的时间</li>
<li><code>LogAppendTime</code>  消息追加到日志文件的时间</li>
</ul>
</li>
</ul>
<h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><p><code>public static final String brokerList = &quot;localhost:9092&quot;;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">      props.put(<span class="string">"key.serializer"</span>,</span><br><span class="line">              <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">      props.put(<span class="string">"value.serializer"</span>,</span><br><span class="line">              <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">      props.put(<span class="string">"bootstrap.servers"</span>, brokerList);</span><br><span class="line"></span><br><span class="line"> props.put(<span class="string">"client.id"</span>, <span class="string">"producer.client.id.demo"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>bootstrap.servers</code></p>
<p>该参数用来指定生产者客户端连接 Kafka 集群所需的 broker地址清单，具体的内容格式<code>hostl:portl</code>,<code>hos t2:port2</code>，可以设置一个或多个地址，中间以逗号隔开，此参数的默认值为“” 。 注意这里并非需要所有的 <code>broker</code> 地址，因为生产者会从给定的 <code>broker</code> 里查找到其他 <code>broker</code> 的信息 。不过建议至少要设置两个以上的 <code>broker</code> 地址信息，当其中任意一个岩机时，生产者仍然可以连接到 <code>Kafka</code>集群上。 </p>
</li>
<li><p><code>client.id</code></p>
<p>表示客户端的id</p>
</li>
</ul>
<blockquote>
<p>其余的参数配置，不用记忆，用到的时候再来查。</p>
</blockquote>
<h2 id="消息的发送"><a href="#消息的发送" class="headerlink" title="消息的发送"></a>消息的发送</h2><h3 id="生产者实例的构建"><a href="#生产者实例的构建" class="headerlink" title="生产者实例的构建"></a>生产者实例的构建</h3><p><code>KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;String, String&gt;(props);</code></p>
<p>也有其他的方式来构建生产者实例，我们主要采用这种加载配置文件的方式。</p>
<h3 id="消息的构建"><a href="#消息的构建" class="headerlink" title="消息的构建"></a>消息的构建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProducerRecord</span><span class="params">(String topic,Integer partition,Long timestamp, K key,V value,Iterable&lt;Header&gt;headers)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProducerRecord</span><span class="params">(String topic,Integer partition,Long timestamp, K key,V value)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProducerRecord</span><span class="params">(String topic,Integer partition,K key,V value, Iterable&lt;Header&gt;headers)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProducerRecord</span><span class="params">(String topic,Integer partition,K key,V value)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProducerRecord</span><span class="params">(String topic,K key,V value)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProducerRecord</span><span class="params">(String topic,V value)</span></span></span><br></pre></td></tr></table></figure>
<p>我们构建了生产者实例和消息之后，就可以发送消息了。</p>
<h3 id="发送消息的模式"><a href="#发送消息的模式" class="headerlink" title="发送消息的模式"></a>发送消息的模式</h3><ul>
<li><p>发后即忘(fire-and-forget)</p>
<p><code>producer.send(record);</code></p>
<blockquote>
<p>只管往Kafka中发送消息，不关系消息是否正确到达。这种方式性能最好，但是可靠性最差，因为有可能造成消息的丢失。</p>
</blockquote>
</li>
<li><p>同步(sync)</p>
<p><code>producer.send(record).get();</code></p>
<blockquote>
<p>同步发送的方式可靠性高，要么消息被发送成功，要么发生异常。如果发生异常，则可以捕获并进行相应的处理，而不会像“发后即忘”的方式直接造成消息的丢失。不过同步发送的方式的性能会差很多，需要阻塞等待一条消息发送完之后才能发送下一条。</p>
</blockquote>
</li>
<li><p>异步(async)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">producer.send(record, <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception exception)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">                   <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// 实际开发应该记录日志</span></span><br><span class="line">                       exception.printStackTrace();</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       System.out.println(metadata.topic() + <span class="string">"-"</span></span><br><span class="line">                               + metadata.partition() + <span class="string">":"</span></span><br><span class="line">                               + metadata.offset());</span><br><span class="line">                   &#125;</span><br><span class="line">  </span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><code>RecordMetadata</code>和<code>Exception</code>这两个参数是互斥的。</p>
<p>消息发送成功时，metadata个为null而exception为null；</p>
<p>消息发送异常时，metadata为null而exception不为null。</p>
</blockquote>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>谈到序列化，就是数据传递必然需要处理的问题。一个Java对象不可能直接传输出去，离开了JVM，谁都不认识这个对象。所以我们在进行数据传输的时候，需要先将对象序列化，然后再传递给数据的接收方。而数据的接收方在拿到数据以后，再将数据进行反序列化成对象，就可以读取并做进一步的操作了。</p>
<p>对于Kafka来说：</p>
<p>生产者需要用序列化器（ Serializer）把对象转换成字节数组才能通过网络发送给 Kafka。而<br>在对侧，消费者需要用反序列化器（ Deserializer）把从 Kafka 中收到的字节数组转换成相应的<br>对象。 </p>
<p>我们的示例中采用的是<code>StringSerializer</code>，还有其他的序列化器，它们都实现了Serializer接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 配置当前类</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs, <span class="keyword">boolean</span> isKey)</span></span>;</span><br><span class="line">    <span class="comment">// 进行序列化操作</span></span><br><span class="line">    <span class="keyword">byte</span>[] serialize(String topic, T data);</span><br><span class="line">    <span class="comment">// 关闭当前的序列化器，一般不使用</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>StringSerializer#close()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// nothing to do</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一定要注意，生产者的序列化器和消费者的反序列化器要一致。</p>
</blockquote>
<p>可以根据需要自定义序列化器，需要在Properties中配置</p>
<h2 id="分区器"><a href="#分区器" class="headerlink" title="分区器"></a>分区器</h2><p>消息在通过send）方法发往broker的过程中，有可能需要经过拦截器（Interceptor）、序列化器（Serializer）和分区器（Partitioner）的一系列作用之后才能被真正地发往broker。拦截器一般不是必需的，而序列化器是必需的。消息经过序列化之后就需要确定它发往的分区，如果消息<code>ProducerRecord</code>中指定了partition字段，那么就不需要分区器的作用，因为partition代表的就是所要发往的分区号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ProducerRecord</span><span class="params">(String topic, Integer partition, K key, V value, Iterable&lt;Header&gt; headers)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(topic, partition, <span class="keyword">null</span>, key, value, headers);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProducerRecord</span><span class="params">(String topic, Integer partition, K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(topic, partition, <span class="keyword">null</span>, key, value, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ProducerRecord</span><span class="params">(String topic, K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(topic, <span class="keyword">null</span>, <span class="keyword">null</span>, key, value, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ProducerRecord</span><span class="params">(String topic, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(topic, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, value, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果消息ProducerRecord中没有指定 partition字段，那么就需要依赖分区器，根据key这个字段来计算partition的值。</p>
<p>分区器的作用就是为消息分配分区。</p>
</blockquote>
<p>Kafka默认的分区器为：<code>org.apache.kafka.clients.producer.internals.DefaultPartitioner</code></p>
<p><code>DefaultPartitioner</code>实现了<code>Partitioner</code>接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Partitioner</span> <span class="keyword">extends</span> <span class="title">Configurable</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span></span>;</span><br><span class="line">		 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>partition()计算分区号，返回一个int值</strong></p>
<p>在默认分区器<code>DefaultPartitioner</code>的实现中，<code>close()</code>是空方法，而在<code>partition()</code>方法中定义了主要的分区分配逻辑。</p>
<p>如果key不为null，那么默认的分区器会对key进行哈希（采用<code>MurmurHash2</code>算法，具备高运算性能及低碰撞率），最终根据得到的哈希值来计算分区号，拥有相同key的消息会被写入同一个分区。</p>
<p>如果key为null，那么消息将会以轮询的方式发往主题内的各个可用分区。</p>
<p>这个优点类似于Redis集群，如何把请求均衡地发送给不同的机器。如果我现在新增一个分区,key和分区之间的关系就会变化了。</p>
<p>那么我们可以自定义分区器来解决这个问题，也算是对默认分区器的一种优化。</p>
<blockquote>
<p>当然，分区器需要在Properties中设置</p>
</blockquote>
<h2 id="生产者拦截器"><a href="#生产者拦截器" class="headerlink" title="生产者拦截器"></a>生产者拦截器</h2><p>生产者拦截器需要我们自己去定义</p>
<p><code>ProducerInterceptor</code>是我们需要实现的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> ProducerRecord&lt;K,V&gt;onSend(ProducerRecord&lt;K,V&gt; record); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAcknowledgement</span><span class="params">(RecordMetadata metadata,Exception exception)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>onSend()</code>方法会在消息序列化和计算分区之前执行，不要在里面修改key value topic的值</li>
<li><code>onAcknowledgement()</code>在消息被应答(异步发送消息的时候有一个回调函数，在它之前执行)之前或者消息发送失败时被调用，优先于用户异步发送的CallBack之前执行</li>
<li><code>close()</code> 关闭拦截器时执行一些资源的清理工作</li>
</ul>
<blockquote>
<p>注意，设置了拦截器后，需要在Properties中指定拦截器。</p>
</blockquote>
<h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p><img src="https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/picture331.png" alt=""></p>
<p>​                                            【生产者客户端的整体架构】</p>
<p>整个生产者客户端由两个线程协调运行，这两个线程分别为主线程和<code>Sender</code> 线程（发送线程）。在主线程中由<code>KafkaProducer</code>创建消息，然后通过可能的拦截器、序列化器和分区器的作用之后缓存到消息累加器（<code>RecordAccumulator</code>，也称为消息收集器）中。Sender线程负责从<code>RecordAccumulator</code>中获取消息并将其发送到Kafka中。</p>
<p><code>RecordAccumulator</code> 主要用来缓存消息以便Sender线程可以批量发送，进而减少网络传输的资源消耗以提升性能。<code>RecordAccumulator</code>缓存的大小可以通过生产者客户端参数buffer.memory 配置，默认值为33554432B，即32MB。如果生产者发送消息的速度超过发送到服务器的速度，则会导致生产者空间不足，这个时候KafkaProducer的send0方法调用要么被阻塞，要么抛出异常，这个取决于参数max.block.ms的配置，此参数的默认值为60000，即60秒。</p>
<p>主线程中发送过来的消息都会被追加到<code>RecordAccumulator</code>的某个双端队列（<code>Deque</code>）中，在<code>RecordAccumulator</code>的内部为每个分区都维护了一个双端队列，队列中的内容就是<code>ProducerBatch</code>，即<code>Deque&lt;ProducerBatch&gt;</code>。消息写入缓存时，追加到双端队列的尾部；<code>Sender</code>读取消息时，从双端队列的头部读取。</p>
<p><code>ProducerBatch</code> 不是<code>ProducerRecord</code>，<code>ProducerBatch</code>中可以包含一至多个<code>ProducerRecord</code>。通俗地说，<code>ProducerRecord</code>是生产者中创建的消息，而<code>ProducerBatch</code>是指一个<strong>消息批次</strong>，<code>ProducerRecord</code>会被包含在<code>ProducerBatch</code>中，这样可以使字节的使用更加紧凑。</p>
<p>消息在网络上都是以字节（Byte）的形式传输的，在发送之前需要创建一块内存区域来保存对应的消息。在Kafka生产者客户端中，通过java.io.<code>ByteBuffer</code>实现消息内存的创建和释放。不过频繁的创建和释放是比较耗费资源的，在<code>RecordAccumulator</code>的内部还有一个<code>BufferPool</code>，它主要用来实现<code>ByteBuffer</code>的复用，以实现缓存的高效利用。不过<code>BufferPool</code>只针对特定大小的<code>ByteBuffer</code> 进行管理，而其他大小的ByteBuffer不会缓存进<code>BufferPool</code>中，这个特定的大小由batch.size参数来指定，默认值为16384B，即16KB。</p>
<p><code>Sender</code>从<code>RecordAccumulator</code>中获取缓存的消息之后，会进一步将原本&lt;分区，Deque&lt;<br><code>ProducerBatch</code>&gt;&gt;的保存形式转变成<code>&lt;Node，List&lt;ProducerBatch&gt;</code>的形式，其中<code>Node</code>表示Kafka集群的<code>broker</code>节点。对于网络连接来说，生产者客户端是与具体的<code>broker</code>节点建立的连接，也就是向具体的broker节点发送消息，而并不关心消息属于哪一个分区；而对于<code>KafkaProducer</code>的应用逻辑而言，我们只关注向哪个分区中发送哪些消息，所以在这里需要做一个应用逻辑层面到网络I/O层面的转换。</p>
<p>在转换成<code>&lt;Node，List&lt;ProducerBatch&gt;&gt;</code>的形式之后，Sender还会进一步封装成<code>&lt;Node，Request&gt;</code>的形式，这样就可以将Request 请求发往各个Node了，这里的Request是指Kafka的各种协议请求，对于消息发送而言就是指具体的<code>ProduceRequest</code>。</p>
<h1 id="重要的生产者参数"><a href="#重要的生产者参数" class="headerlink" title="重要的生产者参数"></a>重要的生产者参数</h1><ol>
<li><p><code>acks</code>这个参数用来指定分区中必须要有多少个副本收到这条消息，之后生产者才会认为这条消息是成功写入的。<code>acks</code>是生产者客户端中一个非常重要的参数，它涉及消息的可靠性和吞吐量之间的权衡。acks参数有3种类型的值（都是字符串类型）。</p>
<ul>
<li>acks=1。默认值即为1。生产者发送消息之后，只要分区的leader副本成功写入消息，那么它就会收到来自服务端的成功响应。如果消息无法写入leader副本，比如在leader副本崩溃、重新选举新的leader副本的过程中，那么生产者就会收到一个错误的响应，为了避免消息丢失，生产者可以选择重发消息。如果消息写入leader副本并返回成功响应给生产者，且在被其他follower副本拉取之前leader副本崩溃，那么此时消息还是会丢失，因为新选举的leader副本中并没有这条对应的消息。acks设置为1，是消息可靠性和吞吐量之间的折中方案。</li>
<li>acks=0。生产者发送消息之后不需要等待任何服务端的响应。如果在消息从发送到写入Kafka的过程中出现某些异常，导致Kafka并没有收到这条消息，那么生产者也无从得知，消息也就丢失了。在其他配置环境相同的情况下，acks设置为0可以达到最大的吞吐量。</li>
<li>acks=-1或acks=all。生产者在消息发送之后，需要等待ISR中的所有副本都成功写入消息之后才能够收到来自服务端的成功响应。在其他配置环境相同的情况下，acks 设置为-1（all）可以达到最强的可靠性。但这并不意味着消息就一定可靠，因为ISR中可能只有leader副本，这样就退化成了acks=1的情况。要获得更高的消息可靠性需要配合min.insync.replicas等参数的联动。</li>
</ul>
<p><code>properties.put(&quot;acks&quot;, &quot;0&quot;);</code></p>
</li>
<li><p><code>retries</code>和<code>retry.backoff.ms</code> </p>
<p><code>retries</code>参数用来配置生产者重试的次数，默认值为0，即在发生异常的时候不进行任何重试动作。消息在从生产者发出到成功写入服务器之前可能发生一些临时性的异常，比如网络抖动、leader副本的选举等，这种异常往往是可以自行恢复的，生产者可以通过配置retries大于0的值，以此通过内部重试来恢复而不是一味地将异常抛给生产者的应用程序。如果重试达到设定的次数，那么生产者就会放弃重试并返回异常。</p>
<p>不过并不是所有的异常都是可以通过重试来解决的，比如消息太大，超过max.request.size参数配置的值时，这种方式就不可行了。</p>
<p>重试还和另一个参数<code>retry.backoff.ms</code>有关，这个参数的默认值为100，它用来设定两次重试之间的时间间隔，避免无效的频繁重试。在配置 <code>retries</code>和<code>retry.backoff.ms</code>之前，最好先估算一下可能的异常恢复时间，这样可以设定总的重试时间大于这个异常恢复时间，以此来避免生产者过早地放弃重试。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘天霸</p>
              <p class="site-description motion-element" itemprop="description">Java学习记录博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘天霸</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
